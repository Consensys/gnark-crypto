
import (
	"math/big"
	"github.com/consensys/gnark-crypto/ecc/{{.Curve.Name}}/fp"
)

// E2 is a degree two finite field extension of fp.Element
type E2 struct {
	A0, A1 fp.Element
}

// Equal returns true if z equals x, false otherwise
func (z *E2) Equal(x *E2) bool {
    return z.A0.Equal(&x.A0) && z.A1.Equal(&x.A1)
}

// Bits
// TODO @gbotrel fixme this shouldn't return a E2
func (z *E2) Bits() E2 {
r := E2 {}
   r.A0 = z.A0.Bits()
       r.A1 = z.A1.Bits()
       return r
}


// Cmp compares (lexicographic order) z and x and returns:
//
//   -1 if z <  x
//    0 if z == x
//   +1 if z >  x
//
func (z *E2) Cmp(x *E2) int {
    if a1 := z.A1.Cmp(&x.A1); a1 != 0 {
        return a1
    }
    return z.A0.Cmp(&x.A0)
}

// LexicographicallyLargest returns true if this element is strictly lexicographically
// larger than its negation, false otherwise
func (z *E2) LexicographicallyLargest() bool {
    // adapted from github.com/zkcrypto/bls12_381
    if z.A1.IsZero() {
        return z.A0.LexicographicallyLargest()
    }
    return z.A1.LexicographicallyLargest()
}

// SetString sets a E2 element from strings
func (z *E2) SetString(s1, s2 string) *E2 {
    z.A0.SetString(s1)
        z.A1.SetString(s2)
        return z
}

// SetZero sets an E2 elmt to zero
func (z *E2) SetZero() *E2 {
    z.A0.SetZero()
        z.A1.SetZero()
        return z
}

// Set sets an E2 from x
func (z *E2) Set(x *E2) *E2 {
    z.A0 = x.A0
        z.A1 = x.A1
        return z
}

// SetOne sets z to 1 in Montgomery form and returns z
func (z *E2) SetOne() *E2 {
    z.A0.SetOne()
        z.A1.SetZero()
        return z
}

// SetRandom sets a0 and a1 to random values
func (z *E2) SetRandom() (*E2, error) {
    if _, err := z.A0.SetRandom(); err != nil {
        return nil, err
    }
    if _, err := z.A1.SetRandom(); err != nil {
        return nil, err
    }
    return z, nil
}

// MustSetRandom sets a0 and a1 to random values.
// It panics if reading form crypto/rand fails
func (z *E2) MustSetRandom() {
    if _, err := z.SetRandom(); err != nil {
        panic(err)
    }
}

// IsZero returns true if z is zero, false otherwise
func (z *E2) IsZero() bool {
    return z.A0.IsZero() && z.A1.IsZero()
}

// IsOne returns true if z is one, false otherwise
func (z *E2) IsOne() bool {
    return z.A0.IsOne() && z.A1.IsZero()
}

// Add adds two elements of E2
func (z *E2) Add(x, y *E2) *E2 {
    addE2(z, x, y)
        return z
}

// Sub subtracts two elements of E2
func (z *E2) Sub(x, y *E2) *E2 {
    subE2(z, x, y)
        return z
}


// Double doubles an E2 element
func (z *E2) Double(x *E2) *E2 {
    doubleE2(z, x)
        return z
}


// Neg negates an E2 element
func (z *E2) Neg(x *E2) *E2 {
    negE2(z, x)
        return z
}

// String implements Stringer interface for fancy printing
func (z *E2) String() string {
    return z.A0.String() + "+" + z.A1.String() + "*u"
}

// MulByElement multiplies an element in E2 by an element in fp
func (z *E2) MulByElement(x *E2, y *fp.Element) *E2 {
    var yCopy fp.Element
        yCopy.Set(y)
        z.A0.Mul(&x.A0, &yCopy)
        z.A1.Mul(&x.A1, &yCopy)
        return z
}

// Conjugate conjugates an element in E2
func (z *E2) Conjugate(x *E2) *E2 {
    z.A0 = x.A0
        z.A1.Neg(&x.A1)
        return z
}

// Halve sets z to z / 2
func (z *E2) Halve()  {
    z.A0.Halve()
        z.A1.Halve()
}

// Legendre returns the Legendre symbol of z
func (z *E2) Legendre() int {
    var n fp.Element
        z.norm(&n)
        return n.Legendre()
}

// Exp sets z=xᵏ (mod q²) and returns it
func (z *E2) Exp(x E2, k *big.Int) *E2 {
    if k.IsUint64() && k.Uint64() == 0 {
        return z.SetOne()
    }

e := k
       if k.Sign() == -1 {
           // negative k, we invert
           // if k < 0: xᵏ (mod q²) == (x⁻¹)ᵏ (mod q²)
           x.Inverse(&x)

               // we negate k in a temp big.Int since
               // Int.Bit(_) of k and -k is different
               e = bigIntPool.Get().(*big.Int)
               defer bigIntPool.Put(e)
               e.Neg(k)
       }

   z.SetOne()
       b := e.Bytes()
       for i := 0; i < len(b); i++ {
w := b[i]
       for j := 0; j < 8; j++ {
           z.Square(z)
               if (w & (0b10000000 >> j)) != 0 {
                   z.Mul(z, &x)
               }
       }
       }

   return z
}

{{if .Curve.Fp.SqrtQ3Mod4 }}
// Sqrt sets z to the square root of x and returns z
// The function does not test whether the square root
// exists or not, it's up to the caller to call
// Legendre beforehand.
//
// "Optimized One-Dimensional SQIsign Verification
// on Intel and Cortex-M4" by Aardal et al.
// https://eprint.iacr.org/2024/1563.pdf (algo 3)
func (z *E2) Sqrt(a *E2) *E2 {
    if a.A1.IsZero() {
        z.A0.Sqrt(&a.A0)
            z.A1.SetZero()
            return z
    }

    var delta, x0, x1, t0, t1 fp.Element

        x0.Square(&a.A0)
        delta.Square(&a.A1).
        Add(&delta, &x0).
        ExpBySqrtPp1o4(delta)

        x0.Add(&a.A0, &delta)

        t0.Double(&x0)

        x1.ExpBySqrtPm3o4(t0)

	x0.Mul(&x0, &x1)

	x1.Mul(&a.A1, &x1)

	t1.Double(&x0).
		Square(&t1)

	if t1.Equal(&t0) {
		z.A0.Set(&x0)
		z.A1.Set(&x1)
		return z
	} else {
		z.A0.Set(&x1)
		z.A1.Neg(&x0)
		return z
	}
}
{{else }}
// Sqrt sets z to the square root of and returns z
// The function does not test whether the square root
// exists or not, it's up to the caller to call
// Legendre beforehand.
//
// "A note on the calculation of some functions in
// finite fields: Tricks of the Trade" by Michael Scott
// https://eprint.iacr.org/2020/1497.pdf (Sec. 6.3)
func (z *E2) Sqrt(x *E2) *E2 {
	var x0, x1 fp.Element
	x.norm(&x0)
	x0.Sqrt(&x0)
	x1.Add(&x.A0, &x0).Halve()
	if x1.Legendre() != 1 {
		x1.Sub(&x.A0, &x0).Halve()
	}
	var inv fp.Element
	x1.SqrtAndInverse(&x1, &inv)
	z.A0.Set(&x1)
	z.A1.Mul(&x.A1, &inv).
		Mul(&z.A1, &x1).
		Halve()

	return z
}
{{end}}

{{- if or (eq .Curve.E2CbrtP2Mod9 7) (eq .Curve.E2CbrtP2Mod9 4) }}
// Cbrt sets z to the cube root of x and returns z
// if the cube root doesn't exist, Cbrt returns nil
//
// p² ≡ {{.Curve.E2CbrtP2Mod9}} (mod 9), single exponentiation, no adjustment needed.
// Reference: Lemma 3 of https://eprint.iacr.org/2021/1446.pdf
func (z *E2) Cbrt(x *E2) *E2 {
	// If x is in Fp (i.e., x.A1 == 0), use Fp cube root directly
	if x.A1.IsZero() {
		if z.A0.Cbrt(&x.A0) == nil {
			return nil
		}
		z.A1.SetZero()
		return z
	}

	var y, c E2
	y.expByE2Cbrt(*x)

	// Verify y³ = x
	c.Square(&y).Mul(&c, &y)
	if !c.Equal(x) {
		return nil
	}
	return z.Set(&y)
}
{{- else if or (eq .Curve.E2CbrtP2Mod27 10) (eq .Curve.E2CbrtP2Mod27 19) }}
// Cbrt sets z to the cube root of x and returns z
// if the cube root doesn't exist, Cbrt returns nil
//
// p² ≡ {{.Curve.E2CbrtP2Mod27}} (mod 27), single exponentiation + adjustment.
// Reference: Lemma 3 of https://eprint.iacr.org/2021/1446.pdf
func (z *E2) Cbrt(x *E2) *E2 {
	// If x is in Fp (i.e., x.A1 == 0), use Fp cube root directly
	if x.A1.IsZero() {
		if z.A0.Cbrt(&x.A0) == nil {
			return nil
		}
		z.A1.SetZero()
		return z
	}

	var y, c E2
	y.expByE2Cbrt(*x)

	// c = y³
	c.Square(&y).Mul(&c, &y)
	if c.Equal(x) {
		return z.Set(&y)
	}

	// Primitive cube roots of unity ω, ω² (in Fp, embedded as (ω, 0))
	var omega, omega2 E2
	omega.A0 = fp.Element{
		{{- range $i := .Curve.Fp.ThirdRootOne}}
		{{$i}},{{end}}
	}
	omega2.A0 = fp.Element{
		{{- range $i := .Curve.Fp.ThirdRootOneSquare}}
		{{$i}},{{end}}
	}

	// Primitive 9th roots of unity ζ, ζ² (in Fp)
	var zeta, zeta2 E2
	zeta.A0 = fp.Element{
		{{- range $i := .Curve.Fp.CbrtG}}
		{{$i}},{{end}}
	}
	zeta2.A0 = fp.Element{
		{{- range $i := .Curve.Fp.CbrtG2}}
		{{$i}},{{end}}
	}

	// Check if c * ω² = x, then y * ζ is the cube root
	var cw2 E2
	cw2.Mul(&c, &omega2)
	if cw2.Equal(x) {
		return z.Mul(&y, &zeta)
	}

	// Check if c * ω = x, then y * ζ² is the cube root
	var cw E2
	cw.Mul(&c, &omega)
	if cw.Equal(x) {
		return z.Mul(&y, &zeta2)
	}

	// x is not a cubic residue
	return nil
}
{{- else }}
// Cbrt sets z to the cube root of x and returns z
// if the cube root doesn't exist, Cbrt returns nil
func (z *E2) Cbrt(x *E2) *E2 {
	// If x is in Fp (i.e., x.A1 == 0), use Fp cube root directly
	if x.A1.IsZero() {
		if z.A0.Cbrt(&x.A0) == nil {
			return nil
		}
		z.A1.SetZero()
		return z
	}

	var y, c E2
	y.expByE2Cbrt(*x)

	// Verify y³ = x
	c.Square(&y).Mul(&c, &y)
	if !c.Equal(x) {
		return nil
	}
	return z.Set(&y)
}
{{- end }}

// expByE2Cbrt is equivalent to z.Exp(x, {{ .Curve.E2CbrtExponentHex }}).
// It uses an addition chain for efficient exponentiation in E2.
//
// uses {{ .Curve.E2CbrtExponentData.Meta.Module }} {{ .Curve.E2CbrtExponentData.Meta.ReleaseTag }} to generate a shorter addition chain
func (z *E2) expByE2Cbrt(x E2) *E2 {
	// addition chain:
	//
	{{- range lines_ (format_ .Curve.E2CbrtExponentData.Script) }}
	//	{{ . }}
	{{- end }}
	//
	// Operations: {{ .Curve.E2CbrtExponentData.Ops.Doubles }} squares {{ .Curve.E2CbrtExponentData.Ops.Adds }} multiplies

	// Allocate Temporaries.
	var (
		{{- range .Curve.E2CbrtExponentData.Program.Temporaries }}
		{{ . }} = new(E2)
		{{- end -}}
	)

	{{ range $i := .Curve.E2CbrtExponentData.Program.Instructions }}
	{{- with add_ $i.Op }}
	{{ $i.Output }}.Mul({{ ptr_ .X }}{{ .X }}, {{ ptr_ .Y }}{{ .Y }})
	{{ end -}}

	{{- with double_ $i.Op }}
	{{ $i.Output }}.Square({{ ptr_ .X }}{{ .X }})
	{{ end -}}

	{{- with shift_ $i.Op -}}
	{{- $first := 0 -}}
	{{- if ne $i.Output.Identifier .X.Identifier }}
	{{ $i.Output }}.Square({{ ptr_ .X }}{{ .X }})
	{{- $first = 1 -}}
	{{- end }}
	for s := {{ $first }}; s < {{ .S }}; s++ {
		{{ $i.Output }}.Square({{ $i.Output }})
	}
	{{ end -}}
	{{- end }}
	return z
}

// BatchInvertE2 returns a new slice with every element in a inverted.
// It uses Montgomery batch inversion trick.
//
// if a[i] == 0, returns result[i] = a[i]
func BatchInvertE2(a []E2) []E2 {
	res := make([]E2, len(a))
	if len(a) == 0 {
		return res
	}

	zeroes := make([]bool, len(a))
	var accumulator E2
	accumulator.SetOne()

	for i := 0; i < len(a); i++ {
		if a[i].IsZero() {
			zeroes[i] = true
			continue
		}
		res[i].Set(&accumulator)
		accumulator.Mul(&accumulator, &a[i])
	}

	accumulator.Inverse(&accumulator)

	for i := len(a) - 1; i >= 0; i-- {
		if zeroes[i] {
			continue
		}
		res[i].Mul(&res[i], &accumulator)
		accumulator.Mul(&accumulator, &a[i])
	}

	return res
}

{{ template "base" .}}
