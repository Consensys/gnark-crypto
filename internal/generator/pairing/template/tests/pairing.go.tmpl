import (
    "fmt"
	"math/big"
	"testing"

	"github.com/consensys/gnark-crypto/ecc/{{.Name}}/fr"
	"github.com/consensys/gnark-crypto/ecc/{{.Name}}/fp"
{{- if or (eq .Name "bn254") (eq .Name "bls12-381") (eq .Name "bls12-377")}}
	"github.com/consensys/gnark-crypto/ecc/{{.Name}}/internal/fptower"
{{- end}}
    "github.com/leanovate/gopter"
	"github.com/leanovate/gopter/prop"
)

// ------------------------------------------------------------
// tests

func TestPairing(t *testing.T) {

	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	if testing.Short() {
		parameters.MinSuccessfulTests = nbFuzzShort
	} else {
		parameters.MinSuccessfulTests = nbFuzz
	}

	properties := gopter.NewProperties(parameters)

	genR1 := GenFr()
	genR2 := GenFr()

	properties.Property("[{{ toUpper .Name}}] Bilinearity: e(P,Q)^ab == e([a]P,Q)^b == e(P,[b]Q)^a", prop.ForAll(
		func(a, b fr.Element) bool {

			var res, resa, resb, resab, zero GT

			var ag1 G1Affine
			var bg2 G2Affine

			var abigint, bbigint, ab big.Int

			a.BigInt(&abigint)
			b.BigInt(&bbigint)
			ab.Mul(&abigint, &bbigint)

			ag1.ScalarMultiplication(&g1GenAff, &abigint)
			bg2.ScalarMultiplication(&g2GenAff, &bbigint)

			res, _ = Pair([]G1Affine{g1GenAff}, []G2Affine{g2GenAff})
			resa, _ = Pair([]G1Affine{ag1}, []G2Affine{g2GenAff})
			resb, _ = Pair([]G1Affine{g1GenAff}, []G2Affine{bg2})

			resab.Exp(res, &ab)
			resa.Exp(resa, &bbigint)
			resb.Exp(resb, &abigint)

			return resab.Equal(&resa) && resab.Equal(&resb) && !res.Equal(&zero)

		},
		genR1,
		genR2,
	))

	properties.Property("[{{ toUpper .Name}}] Non-degenerancy: e(P,Q) != 1", prop.ForAll(
		func() bool {

			res, _ := Pair([]G1Affine{g1GenAff}, []G2Affine{g2GenAff})
            var one GT
			one.SetOne()

			return !res.Equal(&one)

		},
	))

	properties.Property("[{{ toUpper .Name}}] PairingCheck: e(P,Q) * e(-P,Q) == 1", prop.ForAll(
		func(a, b fr.Element) bool {

			var g1GenAffNeg G1Affine
			g1GenAffNeg.Neg(&g1GenAff)
			tabP := []G1Affine{g1GenAff, g1GenAffNeg}
			tabQ := []G2Affine{g2GenAff, g2GenAff}

			res, _ := PairingCheck(tabP, tabQ)

			return res
		},
		genR1,
		genR2,
	))

	properties.TestingRun(t, gopter.ConsoleReporter(false))
}

func TestFixedPairing(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	if testing.Short() {
		parameters.MinSuccessfulTests = nbFuzzShort
	} else {
		parameters.MinSuccessfulTests = nbFuzz
	}

	properties := gopter.NewProperties(parameters)

	genR1 := GenFr()
	genR2 := GenFr()

{{if or (eq .Name "bn254") (eq .Name "bls12-381") (eq .Name "bls12-377") (eq .Name "bw6-761")}}
	properties.Property("[{{ toUpper .Name}}] doubleAndAddStep: optimized (Eisenträger-Lauter-Montgomery) matches reference implementation", prop.ForAll(
		func(s1, s2 fr.Element) bool {
			var p1, p2, p1Ref G2Affine

			// Get generator
			_, _, _, g2Gen := Generators()

			// Scale by random values
			var s1Int, s2Int big.Int
			s1.BigInt(&s1Int)
			s2.BigInt(&s2Int)
			p1.ScalarMultiplication(&g2Gen, &s1Int)
			p2.ScalarMultiplication(&g2Gen, &s2Int)

			// Fail if points are the same - this indicates a problem with random generation
			if p1.X.Equal(&p2.X) {
				return false
			}

			p1Ref.Set(&p1)

			// Compute using optimized implementation
			var eval1Opt, eval2Opt LineEvaluationAff
			p1.doubleAndAddStep(&eval1Opt, &eval2Opt, &p2)

			// Compute using reference implementation
			var eval1Ref, eval2Ref LineEvaluationAff
			doubleAndAddStepRef(&p1Ref, &eval1Ref, &eval2Ref, &p2)

			// Compare results: resulting point coordinates
			pointsEqual := p1.X.Equal(&p1Ref.X) && p1.Y.Equal(&p1Ref.Y)

			// Compare results: line evaluation 1 (from first addition)
			eval1Equal := eval1Opt.R0.Equal(&eval1Ref.R0) && eval1Opt.R1.Equal(&eval1Ref.R1)

			// Compare results: line evaluation 2 (from doubling step)
			eval2Equal := eval2Opt.R0.Equal(&eval2Ref.R0) && eval2Opt.R1.Equal(&eval2Ref.R1)

			return pointsEqual && eval1Equal && eval2Equal
		},
		genR1,
		genR2,
	))
{{- end}}

	properties.Property("[{{ toUpper .Name}}] Pair should output the same result with MillerLoop or MillerLoopFixedQ", prop.ForAll(
		func(a, b fr.Element) bool {

			var ag1 G1Affine
			var bg2 G2Affine

			var abigint, bbigint big.Int

			a.BigInt(&abigint)
			b.BigInt(&bbigint)

			ag1.ScalarMultiplication(&g1GenAff, &abigint)
			bg2.ScalarMultiplication(&g2GenAff, &bbigint)

			P := []G1Affine{g1GenAff, ag1}
			Q := []G2Affine{g2GenAff, bg2}

			// precompute lines
{{- if (eq .Name "bn254")}}
			linesQ := [][2][len(LoopCounter)]LineEvaluationAff{
{{- else}}
			linesQ := [][2][len(LoopCounter)-1]LineEvaluationAff{
{{- end}}
				PrecomputeLines(g2GenAff),
				PrecomputeLines(bg2),
			}

			res1, _ := Pair(P, Q)
			res2, _ := PairFixedQ(P, linesQ)

			return res1.Equal(&res2)
		},
		genR1,
		genR2,
	))

	properties.Property("[{{ toUpper .Name}}] PrecomputeLines and precomputeLinesRef should produce the same pairing result", prop.ForAll(
		func(a, b fr.Element) bool {
			var ag1 G1Affine
			var bg2 G2Affine

			var abigint, bbigint big.Int
			a.BigInt(&abigint)
			b.BigInt(&bbigint)
			ag1.ScalarMultiplication(&g1GenAff, &abigint)
			bg2.ScalarMultiplication(&g2GenAff, &bbigint)

			P := []G1Affine{ag1}

			// Compute pairing using optimized PrecomputeLines
{{- if (eq .Name "bn254")}}
			linesOpt := [][2][len(LoopCounter)]LineEvaluationAff{
{{- else}}
			linesOpt := [][2][len(LoopCounter)-1]LineEvaluationAff{
{{- end}}
				PrecomputeLines(bg2),
			}
			resOpt, _ := PairFixedQ(P, linesOpt)

			// Compute pairing using reference precomputeLinesRef
{{- if (eq .Name "bn254")}}
			linesRef := [][2][len(LoopCounter)]LineEvaluationAff{
{{- else}}
			linesRef := [][2][len(LoopCounter)-1]LineEvaluationAff{
{{- end}}
				precomputeLinesRef(bg2),
			}
			resRef, _ := PairFixedQ(P, linesRef)

			return resOpt.Equal(&resRef)
		},
		genR1,
		genR2,
	))

{{if or (eq .Name "bn254") (eq .Name "bls12-381") (eq .Name "bls12-377")}}
	properties.Property("[{{ toUpper .Name}}] manyDoubleSteps should match repeated doubleStep calls", prop.ForAll(
		func(a fr.Element) bool {
			var Q G2Affine

			var abigint big.Int
			a.BigInt(&abigint)
			Q.ScalarMultiplication(&g2GenAff, &abigint)

			// Test for k = 1, 3, 10
			for _, k := range []int{1, 3, 10} {
				// Method 1: k individual doubleStep calls
				var Q1 G2Affine
				Q1.Set(&Q)
				evals1 := make([]LineEvaluationAff, k)
				for i := 0; i < k; i++ {
					Q1.doubleStep(&evals1[i])
				}

				// Method 2: single manyDoubleSteps call
				var Q2 G2Affine
				Q2.Set(&Q)
				evals2 := make([]LineEvaluationAff, k)
				Q2.manyDoubleSteps(k, evals2)

				// Compare final points
				if !Q1.X.Equal(&Q2.X) || !Q1.Y.Equal(&Q2.Y) {
					return false
				}

				// Compare line evaluations
				for i := 0; i < k; i++ {
					if !evals1[i].R0.Equal(&evals2[i].R0) || !evals1[i].R1.Equal(&evals2[i].R1) {
						return false
					}
				}
			}

			return true
		},
		genR1,
	))
{{- end}}

	properties.TestingRun(t, gopter.ConsoleReporter(false))
}

func TestMillerLoop(t *testing.T) {

	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	if testing.Short() {
		parameters.MinSuccessfulTests = nbFuzzShort
	} else {
		parameters.MinSuccessfulTests = nbFuzz
	}

	properties := gopter.NewProperties(parameters)

	genR1 := GenFr()
	genR2 := GenFr()

{{- if (eq .Name "bw6-761")}}
       properties.Property("[{{ toUpper .Name}}] Pair should output the same result with MillerLoop or MillerLoopDirect", prop.ForAll(
               func(a, b fr.Element) bool {

                       var ag1 G1Affine
                       var bg2 G2Affine

                       var abigint, bbigint big.Int

                       a.BigInt(&abigint)
                       b.BigInt(&bbigint)

                       ag1.ScalarMultiplication(&g1GenAff, &abigint)
                       bg2.ScalarMultiplication(&g2GenAff, &bbigint)

                       P := []G1Affine{g1GenAff, ag1}
                       Q := []G2Affine{g2GenAff, bg2}

                       ml1, _ := MillerLoop(P, Q)
                       ml2, _ := MillerLoopDirect(P,Q)
                       res1 := FinalExponentiation(&ml1)
                       res2 := FinalExponentiation(&ml2)

                       return res1.Equal(&res2)

               },
               genR1,
               genR2,
                ))
{{- end}}

	properties.Property("[{{ toUpper .Name}}] MillerLoop of pairs should be equal to the product of MillerLoops", prop.ForAll(
		func(a, b fr.Element) bool {

			var simpleProd, factorizedProd GT

			var ag1 G1Affine
			var bg2 G2Affine

			var abigint, bbigint big.Int

			a.BigInt(&abigint)
			b.BigInt(&bbigint)

			ag1.ScalarMultiplication(&g1GenAff, &abigint)
			bg2.ScalarMultiplication(&g2GenAff, &bbigint)

			P0 := []G1Affine{g1GenAff}
			P1 := []G1Affine{ag1}
			Q0 := []G2Affine{g2GenAff}
			Q1 := []G2Affine{bg2}

			// FE( ML(a,b) * ML(c,d) * ML(e,f) * ML(g,h) )
			M1, _ := MillerLoop(P0, Q0)
			M2, _ := MillerLoop(P1, Q0)
			M3, _ := MillerLoop(P0, Q1)
			M4, _ := MillerLoop(P1, Q1)
			simpleProd.Mul(&M1, &M2).Mul(&simpleProd, &M3).Mul(&simpleProd, &M4)
			simpleProd = FinalExponentiation(&simpleProd)

			tabP := []G1Affine{g1GenAff, ag1, g1GenAff, ag1}
			tabQ := []G2Affine{g2GenAff, g2GenAff, bg2, bg2}

			// FE( ML([a,c,e,g] ; [b,d,f,h]) ) -> saves 3 squares in Fqk
			factorizedProd, _ = Pair(tabP, tabQ)

			return simpleProd.Equal(&factorizedProd)
		},
		genR1,
		genR2,
	))

	properties.Property("[{{ toUpper .Name}}] MillerLoop and MillerLoopFixedQ should skip pairs with a point at infinity", prop.ForAll(
		func(a, b fr.Element) bool {

			var one GT

			var ag1, g1Inf G1Affine
			var bg2, g2Inf G2Affine

			var abigint, bbigint big.Int

			one.SetOne()

			a.BigInt(&abigint)
			b.BigInt(&bbigint)

			ag1.ScalarMultiplication(&g1GenAff, &abigint)
			bg2.ScalarMultiplication(&g2GenAff, &bbigint)

			g1Inf.FromJacobian(&g1Infinity)
			g2Inf.FromJacobian(&g2Infinity)

			// e([0,c] ; [b,d])
			// -> should be equal to e(c,d)
			tabP := []G1Affine{g1Inf, ag1}
			tabQ := []G2Affine{g2GenAff, bg2}
			res1, _ := Pair(tabP, tabQ)

			// e([a,c] ; [0,d])
			// -> should be equal to e(c,d)
			tabP = []G1Affine{g1GenAff, ag1}
			tabQ = []G2Affine{g2Inf, bg2}
			res2, _ := Pair(tabP, tabQ)

			// e([0,c] ; [b,d]) with fixed points b and d
			// -> should be equal to e(c,d)
			tabP = []G1Affine{g1Inf, ag1}
{{- if (eq .Name "bn254")}}
			linesQ := [][2][len(LoopCounter)]LineEvaluationAff{
{{- else}}
			linesQ := [][2][len(LoopCounter)-1]LineEvaluationAff{
{{- end}}
				PrecomputeLines(g2GenAff),
				PrecomputeLines(bg2),
			}
			res3, _ := PairFixedQ(tabP, linesQ)

			// e([a,c] ; [0,d]) with fixed points 0 and d
			// -> should be equal to e(c,d)
			tabP = []G1Affine{g1GenAff, ag1}
{{- if (eq .Name "bn254")}}
			linesQ = [][2][len(LoopCounter)]LineEvaluationAff{
{{- else}}
			linesQ = [][2][len(LoopCounter)-1]LineEvaluationAff{
{{- end}}
				PrecomputeLines(g2Inf),
				PrecomputeLines(bg2),
			}
			res4, _ := PairFixedQ(tabP, linesQ)

			// e([0,c] ; [d,0])
			// -> should be equal to 1
			tabP = []G1Affine{g1Inf, ag1}
			tabQ = []G2Affine{bg2, g2Inf}
			res5, _ := Pair(tabP, tabQ)

			// e([0,c] ; [d,0]) with fixed points d and 0
			// -> should be equal to 1
			tabP = []G1Affine{g1Inf, ag1}
{{- if (eq .Name "bn254")}}
			linesQ = [][2][len(LoopCounter)]LineEvaluationAff{
{{- else}}
			linesQ = [][2][len(LoopCounter)-1]LineEvaluationAff{
{{- end}}
				PrecomputeLines(bg2),
				PrecomputeLines(g2Inf),
			}
			res6, _ := PairFixedQ(tabP, linesQ)

			// e([0,0])
			// -> should be equal to 1
			tabP = []G1Affine{g1Inf}
			tabQ = []G2Affine{g2Inf}
			res7, _ := Pair(tabP, tabQ)

			// e([0,0]) with fixed point 0
			// -> should be equal to 1
			tabP = []G1Affine{g1Inf}
{{- if (eq .Name "bn254")}}
			linesQ = [][2][len(LoopCounter)]LineEvaluationAff{
{{- else}}
			linesQ = [][2][len(LoopCounter)-1]LineEvaluationAff{
{{- end}}
				PrecomputeLines(g2Inf),
			}
			res8, _ := PairFixedQ(tabP, linesQ)

			return res1.Equal(&res2) && res2.Equal(&res3) && res3.Equal(&res4) &&
				res5.Equal(&one) && res6.Equal(&one) && res7.Equal(&one) && res8.Equal(&one)
		},
		genR1,
		genR2,
	))

	properties.TestingRun(t, gopter.ConsoleReporter(false))
}

func TestExponentiation(t *testing.T) {

	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	if testing.Short() {
		parameters.MinSuccessfulTests = nbFuzzShort
	} else {
		parameters.MinSuccessfulTests = nbFuzz
	}

	properties := gopter.NewProperties(parameters)

    {{if or (eq .Name "bw6-761") (eq .Name "bw6-633")}}
	genA := GenE6()
    {{else if or (eq .Name "bls24-315") (eq .Name "bls24-317")}}
	genA := GenE24()
    {{ else }}
	genA := GenE12()
    {{- end}}
	genR1 := GenFr()

    properties.Property("[{{ toUpper .Name}}] Exponentiating FinalExpo(a) to r should output 1", prop.ForAll(
		func(a GT) bool {
            b := FinalExponentiation(&a)
			return !a.IsInSubGroup() && b.IsInSubGroup()
		},
		genA,
	))

	properties.Property("[{{ toUpper .Name}}] Exp, CyclotomicExp and ExpGLV results must be the same in GT (small and big exponents)", prop.ForAll(
		func(a GT, e fr.Element, ) bool {

			var res bool

			// exponent > r
			{
				a = FinalExponentiation(&a)
				var _e big.Int
				_e.SetString("169893631828481842931290008859743243489098146141979830311893424751855271950692001433356165550548410610101138388623573573742608490725625288296502860183437011025036209791574001140592327223981416956942076610555083128655330944007957223952510233203018053264066056080064687038560794652180979019775788172491868553073169893631828481842931290008859743243489098146141979830311893424751855271950692001433356165550548410610101138388623573573742608490725625288296502860183437011025036209791574001140592327223981416956942076610555083128655330944007957223952510233203018053264066056080064687038560794652180979019775788172491868553073", 10)
				var b, c, d GT
				b.Exp(a, &_e)
				c.ExpGLV(a, &_e)
				d.CyclotomicExp(a, &_e)
				res = b.Equal(&c) && c.Equal(&d)
			}

			// exponent < r
			{
				a = FinalExponentiation(&a)
				var _e big.Int
				e.BigInt(&_e)
				var b, c, d GT
				b.Exp(a, &_e)
				c.ExpGLV(a, &_e)
				d.CyclotomicExp(a, &_e)
				res = res && b.Equal(&c) && c.Equal(&d)
			}

			return res
		},
		genA,
		genR1,
	))

	properties.Property("[{{ toUpper .Name}}] Expt(Expt) and Exp(t^2) should output the same result in the cyclotomic subgroup", prop.ForAll(
		func(a GT) bool {
			var b, c, d GT
			b.Conjugate(&a)
			a.Inverse(&a)
			b.Mul(&b, &a)
            {{if or (eq .Name "bw6-761") (eq .Name "bw6-633")}}
			a.Frobenius(&b).
            {{else if or (eq .Name "bls24-315") (eq .Name "bls24-317")}}
			a.FrobeniusQuad(&b).
            {{ else }}
			a.FrobeniusSquare(&b).
            {{- end}}
                Mul(&a, &b)

			c.Expt(&a).Expt(&c)
			d.Exp(a, &xGen).Exp(d, &xGen)
			return c.Equal(&d)
		},
		genA,
	))

	properties.TestingRun(t, gopter.ConsoleReporter(false))
}

func TestTorusCompression(t *testing.T) {

	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	if testing.Short() {
		parameters.MinSuccessfulTests = nbFuzzShort
	} else {
		parameters.MinSuccessfulTests = nbFuzz
	}

	properties := gopter.NewProperties(parameters)

	genR1 := GenFr()
	genR2 := GenFr()

	properties.Property("[{{ toUpper .Name}}] compressed pairing", prop.ForAll(
		func(a, b fr.Element) bool {

			var ag1 G1Affine
			var bg2 G2Affine

			var abigint, bbigint big.Int

			a.BigInt(&abigint)
			b.BigInt(&bbigint)

			ag1.ScalarMultiplication(&g1GenAff, &abigint)
			bg2.ScalarMultiplication(&g2GenAff, &bbigint)

			res, _ := Pair([]G1Affine{ag1}, []G2Affine{bg2})

			compressed, _ := res.CompressTorus()
			decompressed := compressed.DecompressTorus()

			return decompressed.Equal(&res)

		},
		genR1,
		genR2,
	))

	properties.TestingRun(t, gopter.ConsoleReporter(false))
}


// ------------------------------------------------------------
// benches

func BenchmarkPairing(b *testing.B) {

	var g1GenAff G1Affine
	var g2GenAff G2Affine

	g1GenAff.FromJacobian(&g1Gen)
	g2GenAff.FromJacobian(&g2Gen)

	b.ResetTimer()
	for i := 0; i < b.N; i++ {
		Pair([]G1Affine{g1GenAff}, []G2Affine{g2GenAff})
	}
}

func BenchmarkMillerLoop(b *testing.B) {

	var g1GenAff G1Affine
	var g2GenAff G2Affine

	g1GenAff.FromJacobian(&g1Gen)
	g2GenAff.FromJacobian(&g2Gen)

	b.ResetTimer()
	for i := 0; i < b.N; i++ {
		MillerLoop([]G1Affine{g1GenAff}, []G2Affine{g2GenAff})
	}
}

func BenchmarkFinalExponentiation(b *testing.B) {

	var a GT
	a.MustSetRandom()

	b.ResetTimer()
	for i := 0; i < b.N; i++ {
		FinalExponentiation(&a)
	}

}

func BenchmarkPrecomputeLines(b *testing.B) {

	var g2GenAff G2Affine
	g2GenAff.FromJacobian(&g2Gen)

	b.ResetTimer()
	for i := 0; i < b.N; i++ {
		PrecomputeLines(g2GenAff)
	}
}

func BenchmarkMultiMiller(b *testing.B) {

	var g1GenAff G1Affine
	var g2GenAff G2Affine

	g1GenAff.FromJacobian(&g1Gen)
	g2GenAff.FromJacobian(&g2Gen)

	n := 10
	P := make([]G1Affine, n)
	Q := make([]G2Affine, n)

	for i := 2; i <= n; i++ {
		for j := 0; j < i; j++ {
			P[j].Set(&g1GenAff)
			Q[j].Set(&g2GenAff)
		}
		b.Run(fmt.Sprintf("%d pairs", i), func(b *testing.B) {
			b.ResetTimer()
			for i := 0; i < b.N; i++ {
				MillerLoop(P, Q)
			}
		})
	}
}

func BenchmarkMultiPair(b *testing.B) {

	var g1GenAff G1Affine
	var g2GenAff G2Affine

	g1GenAff.FromJacobian(&g1Gen)
	g2GenAff.FromJacobian(&g2Gen)

	n := 10
	P := make([]G1Affine, n)
	Q := make([]G2Affine, n)

	for i := 2; i <= n; i++ {
		for j := 0; j < i; j++ {
			P[j].Set(&g1GenAff)
			Q[j].Set(&g2GenAff)
		}
		b.Run(fmt.Sprintf("%d pairs", i), func(b *testing.B) {
			b.ResetTimer()
			for i := 0; i < b.N; i++ {
				Pair(P, Q)
			}
		})
	}
}

func BenchmarkExpGT(b *testing.B) {

	var a GT
	a.MustSetRandom()
	a = FinalExponentiation(&a)

	var e fp.Element
	e.MustSetRandom()
    {{if or (eq .Name "bw6-761") (eq .Name "bw6-633")}}
    k := new(big.Int).SetUint64(6)
    {{else if eq .Name "bls24-315"}}
    k := new(big.Int).SetUint64(24)
    {{ else }}
    k := new(big.Int).SetUint64(12)
    {{- end}}
	e.Exp(e, k)
	var _e big.Int
	e.BigInt(&_e)

	b.Run("Naive windowed Exp", func(b *testing.B) {
		b.ResetTimer()
		for i := 0; i < b.N; i++ {
			a.Exp(a, &_e)
		}
	})

	b.Run("2-NAF cyclotomic Exp", func(b *testing.B) {
		b.ResetTimer()
		for i := 0; i < b.N; i++ {
			a.CyclotomicExp(a, &_e)
		}
	})

	b.Run("windowed 2-dim GLV Exp", func(b *testing.B) {
		b.ResetTimer()
		for i := 0; i < b.N; i++ {
			a.ExpGLV(a, &_e)
		}
	})
}

func BenchmarkPairVsFixedPair(b *testing.B) {

	var g1GenAff G1Affine
	var g2GenAff G2Affine

	g1GenAff.FromJacobian(&g1Gen)
	g2GenAff.FromJacobian(&g2Gen)

	for n := 1; n <= 4; n++ {
		P := make([]G1Affine, n)
		Q := make([]G2Affine, n)
		for j := 0; j < n; j++ {
			P[j].Set(&g1GenAff)
			Q[j].Set(&g2GenAff)
		}

		b.Run(fmt.Sprintf("%d_points/Pair", n), func(b *testing.B) {
			b.ResetTimer()
			for i := 0; i < b.N; i++ {
				Pair(P[:n], Q[:n])
			}
		})

		b.Run(fmt.Sprintf("%d_points/PairFixedQ", n), func(b *testing.B) {
			b.ResetTimer()
			for i := 0; i < b.N; i++ {
				// precompute lines
{{- if (eq .Name "bn254")}}
				linesQ := make([][2][len(LoopCounter)]LineEvaluationAff, n)
{{- else}}
				linesQ := make([][2][len(LoopCounter)-1]LineEvaluationAff, n)
{{- end}}
				for j := 0; j < n; j++ {
					linesQ[j] = PrecomputeLines(Q[j])
				}
				PairFixedQ(P[:n], linesQ)
			}
		})
	}
}

// ------------------------------------------------------------
// reference implementations for testing

{{if or (eq .Name "bn254") (eq .Name "bls12-381") (eq .Name "bls12-377") (eq .Name "bw6-761")}}
// doubleAndAddStepRef is the reference (pre-optimization) implementation
// of the doubleAndAddStep function. It computes 2P+Q using two field inversions.
//
// This version uses the standard chord-tangent method:
//   - λ1 = (y2-y1)/(x2-x1) for P + Q
//   - λ2 = -λ1 - 2y1/(x3-x1) for doubling and adding back
//
// The optimized version uses the Eisenträger-Lauter-Montgomery formula
// (https://eprint.iacr.org/2003/257) which computes both slopes with a single
// field inversion via Montgomery's batch inversion trick.
func doubleAndAddStepRef(p *G2Affine, evaluations1, evaluations2 *LineEvaluationAff, a *G2Affine) {
{{- if eq .Name "bw6-761"}}
	var n, d, l1, x3, l2, x4, y4 fp.Element
{{- else}}
	var n, d, l1, x3, l2, x4, y4 fptower.E2
{{- end}}

	// compute λ1 = (y2-y1)/(x2-x1)
	n.Sub(&p.Y, &a.Y)
	d.Sub(&p.X, &a.X)
	l1.Div(&n, &d)

	// compute x3 =λ1²-x1-x2
	x3.Square(&l1)
	x3.Sub(&x3, &p.X)
	x3.Sub(&x3, &a.X)

	// omit y3 computation

	// compute line1
	evaluations1.R0.Set(&l1)
	evaluations1.R1.Mul(&l1, &p.X)
	evaluations1.R1.Sub(&evaluations1.R1, &p.Y)

	// compute λ2 = -λ1-2y1/(x3-x1)
	n.Double(&p.Y)
	d.Sub(&x3, &p.X)
	l2.Div(&n, &d)
	l2.Add(&l2, &l1)
	l2.Neg(&l2)

	// compute x4 = λ2²-x1-x3
	x4.Square(&l2)
	x4.Sub(&x4, &p.X)
	x4.Sub(&x4, &x3)

	// compute y4 = λ2(x1 - x4)-y1
	y4.Sub(&p.X, &x4)
	y4.Mul(&l2, &y4)
	y4.Sub(&y4, &p.Y)

	// compute line2
	evaluations2.R0.Set(&l2)
	evaluations2.R1.Mul(&l2, &p.X)
	evaluations2.R1.Sub(&evaluations2.R1, &p.Y)

	p.X.Set(&x4)
	p.Y.Set(&y4)
}
{{- end}}

// precomputeLinesRef precomputes the lines for the fixed-argument Miller loop
// using the reference (loop-based) implementation without manyDoubleSteps.
{{- if eq .Name "bn254"}}
func precomputeLinesRef(Q G2Affine) (PrecomputedLines [2][len(LoopCounter)]LineEvaluationAff) {
	var accQ, negQ G2Affine
	accQ.Set(&Q)
	negQ.Neg(&Q)

	for i := len(LoopCounter) - 2; i >= 0; i-- {
		accQ.doubleStep(&PrecomputedLines[0][i])

		switch LoopCounter[i] {
		case 1:
			accQ.addStep(&PrecomputedLines[1][i], &Q)
		case -1:
			accQ.addStep(&PrecomputedLines[1][i], &negQ)
		}
	}

	// Frobenius computations for final lines
	var psiQ, phiQ G2Affine
	phiQ.X.Conjugate(&Q.X).MulByNonResidue1Power2(&phiQ.X)
	phiQ.Y.Conjugate(&Q.Y).MulByNonResidue1Power3(&phiQ.Y)
	psiQ.X.MulByNonResidue2Power2(&Q.X)
	psiQ.Y.MulByNonResidue2Power3(&Q.Y).Neg(&psiQ.Y)

	accQ.addStep(&PrecomputedLines[1][65], &phiQ)
	accQ.addStep(&PrecomputedLines[0][65], &psiQ)

	return PrecomputedLines
}
{{- else if or (eq .Name "bls12-381") (eq .Name "bls12-377")}}
func precomputeLinesRef(Q G2Affine) (PrecomputedLines [2][len(LoopCounter) - 1]LineEvaluationAff) {
	var accQ G2Affine
	accQ.Set(&Q)

	for i := len(LoopCounter) - 2; i >= 0; i-- {
		accQ.doubleStep(&PrecomputedLines[0][i])

		if LoopCounter[i] == 1 {
			accQ.addStep(&PrecomputedLines[1][i], &Q)
		}
	}

	return PrecomputedLines
}
{{- else if or (eq .Name "bls24-315") (eq .Name "bls24-317")}}
func precomputeLinesRef(Q G2Affine) (PrecomputedLines [2][len(LoopCounter) - 1]LineEvaluationAff) {
	var accQ, negQ G2Affine
	accQ.Set(&Q)
	negQ.Neg(&Q)

	for i := len(LoopCounter) - 2; i >= 0; i-- {
		accQ.doubleStep(&PrecomputedLines[0][i])

		switch LoopCounter[i] {
		case 1:
			accQ.addStep(&PrecomputedLines[1][i], &Q)
		case -1:
			accQ.addStep(&PrecomputedLines[1][i], &negQ)
		}
	}

	return PrecomputedLines
}
{{- else if eq .Name "bw6-761"}}
func precomputeLinesRef(Q G2Affine) (PrecomputedLines [2][len(LoopCounter) - 1]LineEvaluationAff) {
	// precomputations
	var accQ, imQ, imQneg, negQ G2Affine
	imQ.Y.Neg(&Q.Y)
	imQ.X.Mul(&Q.X, &thirdRootOneG1)
	negQ.X.Set(&Q.X)
	negQ.Y.Set(&imQ.Y)
	accQ.Set(&imQ)
	imQneg.X.Set(&imQ.X)
	imQneg.Y.Set(&Q.Y)

	for i := len(LoopCounter) - 2; i >= 1; i-- {
		accQ.doubleStep(&PrecomputedLines[0][i])

		j := LoopCounter1[i]*3 + LoopCounter[i]
		switch j {
		case -3:
			accQ.addStep(&PrecomputedLines[1][i], &imQneg)
		case -1:
			accQ.addStep(&PrecomputedLines[1][i], &negQ)
		case 1:
			accQ.addStep(&PrecomputedLines[1][i], &Q)
		case 3:
			accQ.addStep(&PrecomputedLines[1][i], &imQ)
		}
	}

	// i = 0: j = -3, use tangentCompute (not doubleStep)
	accQ.tangentCompute(&PrecomputedLines[0][0])

	return PrecomputedLines
}
{{- else if eq .Name "bw6-633"}}
func precomputeLinesRef(Q G2Affine) (PrecomputedLines [2][len(LoopCounter) - 1]LineEvaluationAff) {
	// precomputations
	var accQ, imQ, imQneg, negQ G2Affine
	imQ.Y.Neg(&Q.Y)
	negQ.X.Set(&Q.X)
	negQ.Y.Set(&imQ.Y)
	imQ.X.Mul(&Q.X, &thirdRootOneG2)
	accQ.Set(&Q)
	imQneg.Neg(&imQ)

	for i := len(LoopCounter) - 2; i >= 1; i-- {
		accQ.doubleStep(&PrecomputedLines[0][i])

		j := LoopCounter[i]*3 + LoopCounter1[i]
		switch j {
		case -3:
			accQ.addStep(&PrecomputedLines[1][i], &imQneg)
		case -1:
			accQ.addStep(&PrecomputedLines[1][i], &negQ)
		case 1:
			accQ.addStep(&PrecomputedLines[1][i], &Q)
		case 3:
			accQ.addStep(&PrecomputedLines[1][i], &imQ)
		}
	}

	// i = 0: j = 1, doubleStep + addStep
	accQ.doubleStep(&PrecomputedLines[0][0])
	accQ.addStep(&PrecomputedLines[1][0], &Q)

	return PrecomputedLines
}
{{- end}}
