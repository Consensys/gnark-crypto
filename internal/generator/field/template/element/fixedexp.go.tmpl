{{- if .SqrtQ3Mod4}}
	{{expByAddChain "SqrtPp1o4" .SqrtQ3Mod4ExponentData .ElementName}}
	{{expByAddChain "SqrtPm3o4" .SqrtQ3Mod4ExponentData2 .ElementName}}
{{- else if .SqrtAtkin}}
	{{expByAddChain "SqrtPm5o8" .SqrtAtkinExponentData .ElementName}}
{{- else if .SqrtTonelliShanks}}
	{{expByAddChain "SqrtExp" .SqrtSMinusOneOver2Data .ElementName}}
{{- end }}

{{- if and (not .UsingP20Inverse) (not (eq .NbWords 1))}}
	{{expByAddChain "LegendreExp" .LegendreExponentData .ElementName}}
{{- end}}

{{- if .CbrtQ2Mod3}}
	{{expByAddChain "Cbrt2q1o3" .CbrtQ2Mod3ExponentData .ElementName}}
{{- else if .CbrtQ1Mod3}}
	{{- if .CbrtQ7Mod9}}
	{{expByAddChain "CbrtQPlus2Div9" .CbrtQPlus2Div9Data .ElementName}}
	{{- else if .CbrtQ4Mod9}}
	{{expByAddChain "Cbrt2QPlus1Div9" .Cbrt2QPlus1Div9Data .ElementName}}
	{{- else if .CbrtQ10Mod27}}
	{{expByAddChain "Cbrt2QPlus7Div27" .Cbrt2QPlus7Div27Data .ElementName}}
	{{- else if .CbrtQ19Mod27}}
	{{expByAddChain "CbrtQPlus8Div27" .CbrtQPlus8Div27Data .ElementName}}
	{{- else if .CbrtSPlus1Div3Data}}
	{{expByAddChain "Cbrts1o3" .CbrtSPlus1Div3Data .ElementName}}
	{{- else if .CbrtSMinus1Div3Data}}
	{{expByAddChain "Cbrts1o3" .CbrtSMinus1Div3Data .ElementName}}
	{{- end}}
{{- end}}

{{- if .SxrtExponentData}}
	{{expByAddChain "SxrtExp" .SxrtExponentData .ElementName}}
{{- end}}

{{define "expByAddChain name data eName"}}

// ExpBy{{.name}} is equivalent to z.Exp(x, {{ .data.N }}).
{{- if eq .name "SqrtPp1o4"}}
// It raises x to the (p+1)/4 power using a shorter addition chain.
{{- else if eq .name "SqrtPm3o4"}}
// It raises x to the (p-3)/4 power using a shorter addition chain.
{{- else if eq .name "SqrtPm5o8"}}
// It raises x to the (p-5)/8 power using a shorter addition chain.
{{- else if eq .name "SqrtExp"}}
// It raises x to the (p-2^s-1)/2^(s+1) power using a shorter addition chain,
// where s the 2-adic valuation of p-1.
{{- else if eq .name "Cbrt2q1o3"}}
// It raises x to the (2q-1)/3 power using a shorter addition chain.
{{- else if eq .name "Cbrts1o3"}}
// It raises x to the (s±1)/3 power using a shorter addition chain,
// where s is such that q-1 = 3^e * s with gcd(s, 3) = 1.
{{- else if eq .name "CbrtQPlus2Div9"}}
// It raises x to the (q+2)/9 power using a shorter addition chain.
// This is used when q ≡ 7 (mod 9) for efficient cube root computation.
{{- else if eq .name "Cbrt2QPlus1Div9"}}
// It raises x to the (2q+1)/9 power using a shorter addition chain.
// This is used when q ≡ 4 (mod 9) for efficient cube root computation.
{{- else if eq .name "Cbrt2QPlus7Div27"}}
// It raises x to the (2q+7)/27 power using a shorter addition chain.
// This is used when q ≡ 10 (mod 27) for efficient cube root computation.
{{- else if eq .name "CbrtQPlus8Div27"}}
// It raises x to the (q+8)/27 power using a shorter addition chain.
// This is used when q ≡ 19 (mod 27) for efficient cube root computation.
{{- else if eq .name "SxrtExp"}}
// It raises x to the appropriate power for sextic root computation.
// Reference: Lemma 5 of https://eprint.iacr.org/2021/1446.pdf
{{- end }}
//
// uses {{ .data.Meta.Module }} {{ .data.Meta.ReleaseTag }} to generate a shorter addition chain
func (z *{{.eName}}) ExpBy{{$.name}}(x {{.eName}}) *{{.eName}} {
	// addition chain:
	//
	{{- range lines_ (format_ .data.Script) }}
	//	{{ . }}
	{{- end }}
	//
	// Operations: {{ .data.Ops.Doubles }} squares {{ .data.Ops.Adds }} multiplies

	// Allocate Temporaries.
	var (
		{{- range .data.Program.Temporaries }}
		{{ . }} = new({{$.eName}})
		{{- end -}}
	)

	// var {{range $i, $e := .data.Program.Temporaries }}{{ $e }} {{- if last_ $i $.data.Program.Temporaries}} {{$.eName}} {{- else }}, {{- end}}{{- end -}}

	{{ range $i := .data.Program.Instructions }}
	// {{ printf "Step %d: %s = x^%#x" $i.Output.Index $i.Output (index $.data.Chain $i.Output.Index) }}
	{{- with add_ $i.Op }}
	{{ $i.Output }}.Mul({{ ptr_ .X }}{{ .X }}, {{ ptr_ .Y }}{{ .Y }})
	{{ end -}}

	{{- with double_ $i.Op }}
	{{ $i.Output }}.Square({{ ptr_ .X }}{{ .X }})
	{{ end -}}

	{{- with shift_ $i.Op -}}
	{{- $first := 0 -}}
	{{- if ne $i.Output.Identifier .X.Identifier }}
	{{ $i.Output }}.Square({{ ptr_ .X }}{{ .X }})
	{{- $first = 1 -}}
	{{- end }}
	for s := {{ $first }}; s < {{ .S }}; s++ {
		{{ $i.Output }}.Square({{ ptr_ $i.Output }}{{ $i.Output }})
	}
	{{ end -}}
	{{- end }}
	return z
}

{{end}}