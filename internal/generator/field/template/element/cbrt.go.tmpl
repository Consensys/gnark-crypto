{{ if not .UseAddChain}}
var _bCbrtExponent{{.ElementName}} *big.Int

func init() {
	{{- if .CbrtQ2Mod3}}
		_bCbrtExponent{{.ElementName}}, _ = new(big.Int).SetString("{{.CbrtQ2Mod3Exponent}}", 16)
	{{- else if .CbrtQ1Mod3}}
		{{- if .CbrtQ7Mod9}}
			_bCbrtExponent{{.ElementName}}, _ = new(big.Int).SetString("{{.CbrtQPlus2Div9}}", 16)
		{{- else if .CbrtQ4Mod9}}
			_bCbrtExponent{{.ElementName}}, _ = new(big.Int).SetString("{{.Cbrt2QPlus1Div9}}", 16)
		{{- else if .CbrtQ10Mod27}}
			_bCbrtExponent{{.ElementName}}, _ = new(big.Int).SetString("{{.Cbrt2QPlus7Div27}}", 16)
		{{- else if .CbrtQ19Mod27}}
			_bCbrtExponent{{.ElementName}}, _ = new(big.Int).SetString("{{.CbrtQPlus8Div27}}", 16)
		{{- else if ne .CbrtSPlus1Div3 ""}}
			_bCbrtExponent{{.ElementName}}, _ = new(big.Int).SetString("{{.CbrtSPlus1Div3}}", 16)
		{{- else}}
			_bCbrtExponent{{.ElementName}}, _ = new(big.Int).SetString("{{.CbrtSMinus1Div3}}", 16)
		{{- end}}
	{{- end }}
}

{{- end }}

// Cbrt z = ∛x (mod q)
// if the cube root doesn't exist (x is not a cube mod q)
// Cbrt leaves z unchanged and returns nil
func (z *{{.ElementName}}) Cbrt(x *{{.ElementName}}) *{{.ElementName}} {
	{{- if .CbrtQ2Mod3}}
		// q ≡ 2 (mod 3)
		// using z = x^((2q-1)/3) (mod q)
		{{- if .UseAddChain}}
		z.ExpByCbrt2q1o3(*x)
		{{- else}}
		z.Exp(*x, _bCbrtExponent{{.ElementName}})
		{{- end }}
		// as we use x^((2q-1)/3), there is no check to do: every element has a unique cube root
		return z
	{{- else if .CbrtQ1Mod3}}
		// q ≡ 1 (mod 3)
		// Reference: "Cube root extraction in finite fields" by Sze
		// https://eprint.iacr.org/2011/103.pdf
		//
		// We write q-1 = 3^e * s where gcd(s,3) = 1
		// Let g be a non-cubic residue, and γ = g^s (a primitive 3^e-th root of unity)

		{{- if .CbrtQ7Mod9}}
		// ============================================================
		// q ≡ 7 (mod 9): cbrt(x) = x^((q+2)/9)
		// Single exponentiation, no adjustment needed.
		// Reference: Lemma 3 of https://eprint.iacr.org/2021/1446.pdf
		// ============================================================

		var y {{.ElementName}}
		{{- if .UseAddChain}}
		y.ExpByCbrtQPlus2Div9(*x)
		{{- else}}
		y.Exp(*x, _bCbrtExponent{{.ElementName}})
		{{- end }}

		// Verify y³ = x (checks both that x is a cubic residue and y is correct)
		var check {{.ElementName}}
		check.Cube(&y)
		if check.IsZero() {
			return z.SetZero()
		}
		if !check.Equal(x) {
			return nil
		}
		return z.Set(&y)

		{{- else if .CbrtQ4Mod9}}
		// ============================================================
		// q ≡ 4 (mod 9): cbrt(x) = x^((2q+1)/9)
		// Single exponentiation, no adjustment needed.
		// Reference: Lemma 3 of https://eprint.iacr.org/2021/1446.pdf
		// ============================================================

		var y {{.ElementName}}
		{{- if .UseAddChain}}
		y.ExpByCbrt2QPlus1Div9(*x)
		{{- else}}
		y.Exp(*x, _bCbrtExponent{{.ElementName}})
		{{- end }}

		// Verify y³ = x (checks both that x is a cubic residue and y is correct)
		var check {{.ElementName}}
		check.Cube(&y)
		if check.IsZero() {
			return z.SetZero()
		}
		if !check.Equal(x) {
			return nil
		}
		return z.Set(&y)

		{{- else if .CbrtQ10Mod27}}
		// ============================================================
		// q ≡ 10 (mod 27): cbrt(x) = x^((2q+7)/27) * ζ^k
		// Single exponentiation + single adjustment.
		// Reference: Lemma 3 of https://eprint.iacr.org/2021/1446.pdf
		// ============================================================

		var y {{.ElementName}}
		{{- if .UseAddChain}}
		y.ExpByCbrt2QPlus7Div27(*x)
		{{- else}}
		y.Exp(*x, _bCbrtExponent{{.ElementName}})
		{{- end }}

		// c = y³
		var c {{.ElementName}}
		c.Cube(&y)
		if c.IsZero() {
			return z.SetZero()
		}

		// Check if y is already the cube root
		if c.Equal(x) {
			return z.Set(&y)
		}

		// Precomputed constants:
		// ζ = primitive 9th root of unity
		// ζ² for adjustment
		// ω = ζ³ = primitive 3rd root of unity
		// ω² = ζ⁶
		var zeta = {{.ElementName}}{
			{{- range $i := .CbrtG}}
			{{$i}},{{end}}
		}
		var zeta2 = {{.ElementName}}{
			{{- range $i := .CbrtG2}}
			{{$i}},{{end}}
		}
		var omega = {{.ElementName}}{
			{{- range $i := .ThirdRootOne}}
			{{$i}},{{end}}
		}
		var omega2 = {{.ElementName}}{
			{{- range $i := .ThirdRootOneSquare}}
			{{$i}},{{end}}
		}

		// Check if c/x = ω (i.e., c * ω² = x)
		// With our convention: omega = ζ⁶, omega2 = ζ³
		// If c * ζ³ = x, then c = x*ζ⁶, and (y*ζ)³ = y³*ζ³ = c*ζ³ = x ✓
		var cw2 {{.ElementName}}
		cw2.Mul(&c, &omega2)
		if cw2.Equal(x) {
			return z.Mul(&y, &zeta)
		}

		// Check if c/x = ω² (i.e., c * ω = x)
		// If c * ζ⁶ = x, then c = x*ζ³, and (y*ζ²)³ = y³*ζ⁶ = c*ζ⁶ = x ✓
		var cw {{.ElementName}}
		cw.Mul(&c, &omega)
		if cw.Equal(x) {
			return z.Mul(&y, &zeta2)
		}

		// x is not a cubic residue
		return nil

		{{- else if .CbrtQ19Mod27}}
		// ============================================================
		// q ≡ 19 (mod 27): cbrt(x) = x^((q+8)/27) * ζ^k
		// Single exponentiation + single adjustment.
		// Reference: Lemma 3 of https://eprint.iacr.org/2021/1446.pdf
		// ============================================================

		var y {{.ElementName}}
		{{- if .UseAddChain}}
		y.ExpByCbrtQPlus8Div27(*x)
		{{- else}}
		y.Exp(*x, _bCbrtExponent{{.ElementName}})
		{{- end }}

		// c = y³
		var c {{.ElementName}}
		c.Cube(&y)
		if c.IsZero() {
			return z.SetZero()
		}

		// Check if y is already the cube root
		if c.Equal(x) {
			return z.Set(&y)
		}

		// Precomputed constants:
		// ζ = primitive 9th root of unity
		// ζ² for adjustment
		// ω = ζ³ = primitive 3rd root of unity
		// ω² = ζ⁶
		var zeta = {{.ElementName}}{
			{{- range $i := .CbrtG}}
			{{$i}},{{end}}
		}
		var zeta2 = {{.ElementName}}{
			{{- range $i := .CbrtG2}}
			{{$i}},{{end}}
		}
		var omega = {{.ElementName}}{
			{{- range $i := .ThirdRootOne}}
			{{$i}},{{end}}
		}
		var omega2 = {{.ElementName}}{
			{{- range $i := .ThirdRootOneSquare}}
			{{$i}},{{end}}
		}

		// Check if c/x = ω (i.e., c * ω² = x)
		// With our convention: omega = ζ⁶, omega2 = ζ³
		// If c * ζ³ = x, then c = x*ζ⁶, and (y*ζ)³ = y³*ζ³ = c*ζ³ = x ✓
		var cw2 {{.ElementName}}
		cw2.Mul(&c, &omega2)
		if cw2.Equal(x) {
			return z.Mul(&y, &zeta)
		}

		// Check if c/x = ω² (i.e., c * ω = x)
		// If c * ζ⁶ = x, then c = x*ζ³, and (y*ζ²)³ = y³*ζ⁶ = c*ζ⁶ = x ✓
		var cw {{.ElementName}}
		cw.Mul(&c, &omega)
		if cw.Equal(x) {
			return z.Mul(&y, &zeta2)
		}

		// x is not a cubic residue
		return nil

		{{- else if eq .CbrtE 2}}
		// ============================================================
		// Optimized path for e = 2 (i.e., 9 || (q-1), meaning 27 ∤ (q-1))
		// The adjustment loop runs at most once.
		// Reference: https://eprint.iacr.org/2021/1446.pdf
		// ============================================================

		var y, t, c {{.ElementName}}

		{{- if ne .CbrtSPlus1Div3 ""}}
		// s ≡ 2 (mod 3), using (s+1)/3
		{{- if .UseAddChain}}
		y.ExpByCbrts1o3(*x)
		{{- else}}
		y.Exp(*x, _bCbrtExponent{{.ElementName}})
		{{- end }}

		// t = x^s
		c.Cube(&y)   // c = y^3 = x^{s+1}
		t.Inverse(x).Mul(&t, &c)   // t = x^s

		{{- else}}
		// s ≡ 1 (mod 3), using (s-1)/3
		var w {{.ElementName}}
		{{- if .UseAddChain}}
		w.ExpByCbrts1o3(*x)
		{{- else}}
		w.Exp(*x, _bCbrtExponent{{.ElementName}})
		{{- end }}

		c.Square(&w)     // c = w^2 = x^{2(s-1)/3}
		y.Mul(x, &c)     // y = x * w^2 = x^{(2s+1)/3}

		// t = x^{2s} = (x^s)^2
		var xs {{.ElementName}}
		xs.Mul(&w, &c).Mul(&xs, x)  // xs = x^s
		t.Square(&xs)               // t = x^{2s}
		{{- end}}

		// Precomputed constants:
		// ζ = primitive 9th root of unity
		// ζ² for adjustment
		// ω = ζ³ = primitive 3rd root of unity
		var zeta = {{.ElementName}}{
			{{- range $i := .CbrtG}}
			{{$i}},{{end}}
		}
		var zeta2 = {{.ElementName}}{
			{{- range $i := .CbrtG2}}
			{{$i}},{{end}}
		}
		var omega = {{.ElementName}}{
			{{- range $i := .ThirdRootOne}}
			{{$i}},{{end}}
		}

		// For e=2, check if x is a cubic residue: t^3 should equal 1
		var check {{.ElementName}}
		check.Cube(&t)
		if check.IsZero() {
			return z.SetZero()
		}
		if !check.IsOne() {
			return nil
		}

		// If t = 1, y is already the cube root
		if t.IsOne() {
			return z.Set(&y)
		}

		// t ≠ 1 but t^3 = 1, so t is a primitive 3rd root of unity (t = ω or t = ω²)
		// We need to adjust y by multiplying with an appropriate power of ζ
		// With our convention: omega = ζ⁶, so:
		// Check if t * ω = 1 (i.e., t = ω⁻¹ = ζ⁻⁶ = ζ³)
		var tOmega {{.ElementName}}
		tOmega.Mul(&t, &omega)
		if tOmega.IsOne() {
			// t = ζ³, so we multiply y by ζ² (since (ζ²)³ = ζ⁶ cancels with t³ = ζ⁹ = 1)
			return z.Mul(&y, &zeta2)
		}
		// Otherwise t = ζ⁶ = ω, so we multiply y by ζ
		return z.Mul(&y, &zeta)

		{{- else}}
		// ============================================================
		// General Tonelli-Shanks variant for e ≥ 3
		// ============================================================

		var y, t, w, c {{.ElementName}}

		{{- if ne .CbrtSPlus1Div3 ""}}
		// s ≡ 2 (mod 3), using (s+1)/3
		// y = x^((s+1)/3) is the initial candidate
		{{- if .UseAddChain}}
		y.ExpByCbrts1o3(*x)
		{{- else}}
		y.Exp(*x, _bCbrtExponent{{.ElementName}})
		{{- end }}

		// t = y^3 * x^{-1} = x^{s+1} * x^{-1} = x^s
		c.Cube(&y) // c = y^3 = x^{s+1}
		t.Inverse(x).Mul(&t, &c) // t = x^s

		{{- else}}
		// s ≡ 1 (mod 3), using (s-1)/3
		// We compute w = x^((s-1)/3), then y = x * w^2 = x^((2s+1)/3)
		// This gives t = y^3/x = x^{2s} = (x^s)^2 which is a 3^(e-1) root of unity
		{{- if .UseAddChain}}
		w.ExpByCbrts1o3(*x)
		{{- else}}
		w.Exp(*x, _bCbrtExponent{{.ElementName}})
		{{- end }}

		// y = x^((2s+1)/3) = x * (x^((s-1)/3))^2 = x * w^2
		c.Square(&w)     // c = w^2 = x^{2(s-1)/3}
		y.Mul(x, &c)     // y = x * w^2 = x^{(2s+1)/3}

		// t = y^3/x = x^{2s} = (x^s)^2
		// We compute t = (x * w^3)^2 where x * w^3 = x^s
		var xs {{.ElementName}}
		xs.Mul(&w, &c)   // xs = w^3 = x^{s-1}
		xs.Mul(&xs, x)   // xs = x^s
		t.Square(&xs)    // t = (x^s)^2 = x^{2s}

		{{- end}}

		// γ = nonCubicResidue ^ s (a primitive 3^e root of unity)
		var g = {{.ElementName}}{
			{{- range $i := .CbrtG}}
			{{$i}},{{end}}
		}
		r := uint64({{.CbrtE}})

		// Check if x is a cubic residue: x^((q-1)/3) should be 1
		// This equals t^(3^(e-1))
		var check {{.ElementName}}
		check = t
		for i := uint64(0); i < r-1; i++ {
			check.Cube(&check)
		}
		if check.IsZero() {
			return z.SetZero()
		}
		if !check.IsOne() {
			// x is not a cubic residue
			return nil
		}

		// Main loop: adjust y until y^3 = x
		for {
			var m uint64
			check = t

			// Find smallest m ≥ 0 such that t^{3^m} = 1
			for !check.IsOne() {
				check.Cube(&check)
				m++
			}

			if m == 0 {
				// t = 1, so y^3 = x
				return z.Set(&y)
			}

			// Compute δ = g^{3^{r-m}} (a primitive 3^m-th root of unity)
			ge := int(r - m)
			w = g
			for ge > 0 {
				w.Cube(&w)
				ge--
			}

			// Compute cube root of δ: c = g^{3^{r-m-1}}
			// Note: c^3 = g^{3^{r-m}} = w = δ
			ge = int(r - m - 1)
			c = g
			for ge > 0 {
				c.Cube(&c)
				ge--
			}

			// Find k ∈ {1, 2} such that (t * δ^k)^{3^{m-1}} = 1
			// We test k = 1 first
			var tw {{.ElementName}}
			tw.Mul(&t, &w)
			check = tw
			for i := uint64(0); i < m-1; i++ {
				check.Cube(&check)
			}

			if check.IsOne() {
				// k = 1: t_new = t * δ, y_new = y * (cube root of δ) = y * c
				t = tw
				y.Mul(&y, &c)
			} else {
				// k = 2: t_new = t * δ^2, y_new = y * (cube root of δ^2) = y * c^2
				t.Mul(&tw, &w)
				y.Mul(&y, &c).Mul(&y, &c)
			}

			// Update g to be w (primitive 3^m root of unity) for next iteration
			g = w
			r = m
		}
		{{- end}}
	{{- else}}
		panic("not implemented")
	{{- end}}
}

// Cube sets z to x^3 and returns z
func (z *{{.ElementName}}) Cube(x *{{.ElementName}}) *{{.ElementName}} {
	var t {{.ElementName}}
	t.Square(x).Mul(&t, x)
	z.Set(&t)
	return z
}
