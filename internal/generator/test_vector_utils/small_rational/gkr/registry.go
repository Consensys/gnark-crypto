// Copyright 2020-2025 Consensys Software Inc.
// Licensed under the Apache License, Version 2.0. See the LICENSE file for details.

// Code generated by consensys/gnark-crypto DO NOT EDIT

package gkr

import (
	"errors"
	"fmt"
	"github.com/consensys/gnark-crypto/ecc"
	"github.com/consensys/gnark-crypto/internal/generator/test_vector_utils/small_rational"
	"github.com/consensys/gnark-crypto/internal/generator/test_vector_utils/small_rational/polynomial"
	"slices"
	"sync"
)

var (
	gates     = make(map[string]*Gate)
	gatesLock sync.Mutex
)

type registerGateSettings struct {
	solvableVar               int
	noSolvableVarVerification bool
	noDegreeVerification      bool
	degree                    int
}

type RegisterGateOption func(*registerGateSettings)

// WithSolvableVar gives the index of a variable whose value can be uniquely determined from that of the other variables along with the gate's output.
// RegisterGate will return an error if it cannot verify that this claim is correct.
func WithSolvableVar(solvableVar int) RegisterGateOption {
	return func(settings *registerGateSettings) {
		settings.solvableVar = solvableVar
	}
}

// WithUnverifiedSolvableVar sets the index of a variable whose value can be uniquely determined from that of the other variables along with the gate's output.
// RegisterGate will not verify that the given index is correct.
func WithUnverifiedSolvableVar(solvableVar int) RegisterGateOption {
	return func(settings *registerGateSettings) {
		settings.noSolvableVarVerification = true
		settings.solvableVar = solvableVar
	}
}

// WithNoSolvableVar sets the gate as having no variable whose value can be uniquely determined from that of the other variables along with the gate's output.
// RegisterGate will not check the correctness of this claim.
func WithNoSolvableVar() RegisterGateOption {
	return func(settings *registerGateSettings) {
		settings.solvableVar = -1
		settings.noSolvableVarVerification = true
	}
}

// WithUnverifiedDegree sets the degree of the gate. RegisterGate will not verify that the given degree is correct.
func WithUnverifiedDegree(degree int) RegisterGateOption {
	return func(settings *registerGateSettings) {
		settings.noDegreeVerification = true
		settings.degree = degree
	}
}

// WithDegree sets the degree of the gate. RegisterGate will return an error if the degree is not correct.
func WithDegree(degree int) RegisterGateOption {
	return func(settings *registerGateSettings) {
		settings.degree = degree
	}
}

// isAdditive returns whether x_i occurs only in a monomial of total degree 1 in f
func isAdditive(f GateFunction, i, nbIn int) bool {
	// fix all variables except the i-th one at random points
	// pick random value x1 for the i-th variable
	// check if f(-, 0, -) + f(-, 2*x1, -) = 2*f(-, x1, -)
	x := make(small_rational.Vector, nbIn)
	x.MustSetRandom()
	x0 := x[i]
	x[i].SetZero()
	in := slices.Clone(x)
	y0 := f(in...)

	x[i] = x0
	copy(in, x)
	y1 := f(in...)

	x[i].Double(&x[i])
	copy(in, x)
	y2 := f(in...)

	y2.Sub(&y2, &y1)
	y1.Sub(&y1, &y0)

	if !y2.Equal(&y1) {
		return false // not linear
	}

	// check if the coefficient of x_i is nonzero and independent of the other variables (so that we know it is ALWAYS nonzero)
	if y1.IsZero() { // f(-, x1, -) = f(-, 0, -), so the coefficient of x_i is 0
		return false
	}

	// compute the slope with another assignment for the other variables
	x.MustSetRandom()
	x[i].SetZero()
	copy(in, x)
	y0 = f(in...)

	x[i] = x0
	copy(in, x)
	y1 = f(in...)

	y1.Sub(&y1, &y0)

	return y1.Equal(&y2)
}

// fitPoly tries to fit a polynomial of degree less than degreeBound to f.
// degreeBound must be a power of 2.
// It returns the polynomial if successful, nil otherwise
func fitPoly(f GateFunction, nbIn int, degreeBound uint64) polynomial.Polynomial {
	// turn f univariate by defining p(x) as f(x, x, ..., x)
	fIn := make([]small_rational.SmallRational, nbIn)
	p := make(polynomial.Polynomial, degreeBound)
	x := make(small_rational.Vector, degreeBound)
	x.MustSetRandom()
	for i := range x {
		for j := range fIn {
			fIn[j] = x[i]
		}
		p[i] = f(fIn...)
	}

	// obtain p's coefficients
	p, err := interpolate(x, p)
	if err != nil {
		panic(err)
	}

	// check if p is equal to f. This not being the case means that f is of a degree higher than degreeBound
	fIn[0].MustSetRandom()
	for i := range fIn {
		fIn[i] = fIn[0]
	}
	pAt := p.Eval(&fIn[0])
	fAt := f(fIn...)
	if !pAt.Equal(&fAt) {
		return nil
	}

	// trim p
	lastNonZero := len(p) - 1
	for lastNonZero >= 0 && p[lastNonZero].IsZero() {
		lastNonZero--
	}
	return p[:lastNonZero+1]
}

// RegisterGate creates a gate object and stores it in the gates registry
// name is a human-readable name for the gate
// f is the polynomial function defining the gate
// nbIn is the number of inputs to the gate
func RegisterGate(name string, f GateFunction, nbIn int, options ...RegisterGateOption) error {
	s := registerGateSettings{degree: -1, solvableVar: -1}
	for _, option := range options {
		option(&s)
	}

	if s.degree == -1 { // find a degree
		if s.noDegreeVerification {
			panic("invalid settings")
		}
		found := false
		const maxAutoDegreeBound = 32
		for degreeBound := uint64(4); degreeBound <= maxAutoDegreeBound; degreeBound *= 2 {
			if p := fitPoly(f, nbIn, degreeBound); p != nil {
				found = true
				s.degree = len(p) - 1
				break
			}
		}
		if !found {
			return fmt.Errorf("could not find a degree for gate %s: tried up to %d", name, maxAutoDegreeBound-1)
		}
	} else {
		if !s.noDegreeVerification { // check that the given degree is correct
			if p := fitPoly(f, nbIn, ecc.NextPowerOfTwo(uint64(s.degree)+1)); p == nil {
				return fmt.Errorf("detected a higher degree than %d for gate %s", s.degree, name)
			} else if len(p)-1 != s.degree {
				return fmt.Errorf("detected degree %d for gate %s, claimed %d", len(p)-1, name, s.degree)
			}
		}
	}

	if s.solvableVar == -1 {
		if !s.noSolvableVarVerification { // find a solvable variable
			for i := range nbIn {
				if isAdditive(f, i, nbIn) {
					s.solvableVar = i
					break
				}
			}
		}
	} else {
		// solvable variable given
		if !s.noSolvableVarVerification && !isAdditive(f, s.solvableVar, nbIn) {
			return fmt.Errorf("cannot verify the solvability of variable %d in gate %s", s.solvableVar, name)
		}
	}

	gatesLock.Lock()
	defer gatesLock.Unlock()
	gates[name] = &Gate{Evaluate: f, nbIn: nbIn, degree: s.degree, solvableVar: s.solvableVar}
	return nil
}

func GetGate(name string) *Gate {
	gatesLock.Lock()
	defer gatesLock.Unlock()
	return gates[name]
}

func RemoveGate(name string) bool {
	gatesLock.Lock()
	defer gatesLock.Unlock()
	_, found := gates[name]
	if found {
		delete(gates, name)
	}
	return found
}

// interpolate fits a polynomial of degree len(X) - 1 = len(Y) - 1 to the points (X[i], Y[i])
// Note that the runtime is O(len(X)Â³)
func interpolate(X, Y []small_rational.SmallRational) (polynomial.Polynomial, error) {
	if len(X) != len(Y) {
		return nil, errors.New("X and Y must have the same length")
	}

	// solve the system of equations by Gaussian elimination
	augmentedRows := make([][]small_rational.SmallRational, len(X)) // the last column is the Y values
	for i := range augmentedRows {
		augmentedRows[i] = make([]small_rational.SmallRational, len(X)+1)
		augmentedRows[i][0].SetOne()
		augmentedRows[i][1].Set(&X[i])
		for j := 2; j < len(augmentedRows[i])-1; j++ {
			augmentedRows[i][j].Mul(&augmentedRows[i][j-1], &X[i])
		}
		augmentedRows[i][len(augmentedRows[i])-1].Set(&Y[i])
	}

	// make the upper triangle
	for i := range len(augmentedRows) - 1 {
		// use row i to eliminate the ith element in all rows below
		var negInv small_rational.SmallRational
		if augmentedRows[i][i].IsZero() {
			return nil, errors.New("singular matrix")
		}
		negInv.Inverse(&augmentedRows[i][i])
		negInv.Neg(&negInv)
		for j := i + 1; j < len(augmentedRows); j++ {
			var c small_rational.SmallRational
			c.Mul(&augmentedRows[j][i], &negInv)
			// augmentedRows[j][i].SetZero() omitted
			for k := i + 1; k < len(augmentedRows[i]); k++ {
				var t small_rational.SmallRational
				t.Mul(&augmentedRows[i][k], &c)
				augmentedRows[j][k].Add(&augmentedRows[j][k], &t)
			}
		}
	}

	// back substitution
	res := make(polynomial.Polynomial, len(X))
	for i := len(augmentedRows) - 1; i >= 0; i-- {
		res[i] = augmentedRows[i][len(augmentedRows[i])-1]
		for j := i + 1; j < len(augmentedRows[i])-1; j++ {
			var t small_rational.SmallRational
			t.Mul(&res[j], &augmentedRows[i][j])
			res[i].Sub(&res[i], &t)
		}
		res[i].Div(&res[i], &augmentedRows[i][i])
	}

	return res, nil
}
