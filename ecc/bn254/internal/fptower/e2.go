// Copyright 2020-2026 Consensys Software Inc.
// Licensed under the Apache License, Version 2.0. See the LICENSE file for details.

// Code generated by consensys/gnark-crypto DO NOT EDIT

package fptower

import (
	"math/big"

	"github.com/consensys/gnark-crypto/ecc/bn254/fp"
)

// E2 is a degree two finite field extension of fp.Element
type E2 struct {
	A0, A1 fp.Element
}

// Equal returns true if z equals x, false otherwise
func (z *E2) Equal(x *E2) bool {
	return z.A0.Equal(&x.A0) && z.A1.Equal(&x.A1)
}

// Bits
// TODO @gbotrel fixme this shouldn't return a E2
func (z *E2) Bits() E2 {
	r := E2{}
	r.A0 = z.A0.Bits()
	r.A1 = z.A1.Bits()
	return r
}

// Cmp compares (lexicographic order) z and x and returns:
//
//	-1 if z <  x
//	 0 if z == x
//	+1 if z >  x
func (z *E2) Cmp(x *E2) int {
	if a1 := z.A1.Cmp(&x.A1); a1 != 0 {
		return a1
	}
	return z.A0.Cmp(&x.A0)
}

// LexicographicallyLargest returns true if this element is strictly lexicographically
// larger than its negation, false otherwise
func (z *E2) LexicographicallyLargest() bool {
	// adapted from github.com/zkcrypto/bls12_381
	if z.A1.IsZero() {
		return z.A0.LexicographicallyLargest()
	}
	return z.A1.LexicographicallyLargest()
}

// SetString sets a E2 element from strings
func (z *E2) SetString(s1, s2 string) *E2 {
	z.A0.SetString(s1)
	z.A1.SetString(s2)
	return z
}

// SetZero sets an E2 elmt to zero
func (z *E2) SetZero() *E2 {
	z.A0.SetZero()
	z.A1.SetZero()
	return z
}

// Set sets an E2 from x
func (z *E2) Set(x *E2) *E2 {
	z.A0 = x.A0
	z.A1 = x.A1
	return z
}

// SetOne sets z to 1 in Montgomery form and returns z
func (z *E2) SetOne() *E2 {
	z.A0.SetOne()
	z.A1.SetZero()
	return z
}

// SetRandom sets a0 and a1 to random values
func (z *E2) SetRandom() (*E2, error) {
	if _, err := z.A0.SetRandom(); err != nil {
		return nil, err
	}
	if _, err := z.A1.SetRandom(); err != nil {
		return nil, err
	}
	return z, nil
}

// MustSetRandom sets a0 and a1 to random values.
// It panics if reading form crypto/rand fails
func (z *E2) MustSetRandom() {
	if _, err := z.SetRandom(); err != nil {
		panic(err)
	}
}

// IsZero returns true if z is zero, false otherwise
func (z *E2) IsZero() bool {
	return z.A0.IsZero() && z.A1.IsZero()
}

// IsOne returns true if z is one, false otherwise
func (z *E2) IsOne() bool {
	return z.A0.IsOne() && z.A1.IsZero()
}

// Add adds two elements of E2
func (z *E2) Add(x, y *E2) *E2 {
	addE2(z, x, y)
	return z
}

// Sub subtracts two elements of E2
func (z *E2) Sub(x, y *E2) *E2 {
	subE2(z, x, y)
	return z
}

// Double doubles an E2 element
func (z *E2) Double(x *E2) *E2 {
	doubleE2(z, x)
	return z
}

// Neg negates an E2 element
func (z *E2) Neg(x *E2) *E2 {
	negE2(z, x)
	return z
}

// String implements Stringer interface for fancy printing
func (z *E2) String() string {
	return z.A0.String() + "+" + z.A1.String() + "*u"
}

// MulByElement multiplies an element in E2 by an element in fp
func (z *E2) MulByElement(x *E2, y *fp.Element) *E2 {
	var yCopy fp.Element
	yCopy.Set(y)
	z.A0.Mul(&x.A0, &yCopy)
	z.A1.Mul(&x.A1, &yCopy)
	return z
}

// Conjugate conjugates an element in E2
func (z *E2) Conjugate(x *E2) *E2 {
	z.A0 = x.A0
	z.A1.Neg(&x.A1)
	return z
}

// Halve sets z to z / 2
func (z *E2) Halve() {
	z.A0.Halve()
	z.A1.Halve()
}

// Legendre returns the Legendre symbol of z
func (z *E2) Legendre() int {
	var n fp.Element
	z.norm(&n)
	return n.Legendre()
}

// Exp sets z=xᵏ (mod q²) and returns it
func (z *E2) Exp(x E2, k *big.Int) *E2 {
	if k.IsUint64() && k.Uint64() == 0 {
		return z.SetOne()
	}

	e := k
	if k.Sign() == -1 {
		// negative k, we invert
		// if k < 0: xᵏ (mod q²) == (x⁻¹)ᵏ (mod q²)
		x.Inverse(&x)

		// we negate k in a temp big.Int since
		// Int.Bit(_) of k and -k is different
		e = bigIntPool.Get().(*big.Int)
		defer bigIntPool.Put(e)
		e.Neg(k)
	}

	z.SetOne()
	b := e.Bytes()
	for i := 0; i < len(b); i++ {
		w := b[i]
		for j := 0; j < 8; j++ {
			z.Square(z)
			if (w & (0b10000000 >> j)) != 0 {
				z.Mul(z, &x)
			}
		}
	}

	return z
}

// Sqrt sets z to the square root of x and returns z
// The function does not test whether the square root
// exists or not, it's up to the caller to call
// Legendre beforehand.
//
// "Optimized One-Dimensional SQIsign Verification
// on Intel and Cortex-M4" by Aardal et al.
// https://eprint.iacr.org/2024/1563.pdf (algo 3)
func (z *E2) Sqrt(a *E2) *E2 {
	if a.A1.IsZero() {
		z.A0.Sqrt(&a.A0)
		z.A1.SetZero()
		return z
	}

	var delta, x0, x1, t0, t1 fp.Element

	x0.Square(&a.A0)
	delta.Square(&a.A1).
		Add(&delta, &x0).
		ExpBySqrtPp1o4(delta)

	x0.Add(&a.A0, &delta)

	t0.Double(&x0)

	x1.ExpBySqrtPm3o4(t0)

	x0.Mul(&x0, &x1)

	x1.Mul(&a.A1, &x1)

	t1.Double(&x0).
		Square(&t1)

	if t1.Equal(&t0) {
		z.A0.Set(&x0)
		z.A1.Set(&x1)
		return z
	} else {
		z.A0.Set(&x1)
		z.A1.Neg(&x0)
		return z
	}
}

// Cbrt sets z to the cube root of x and returns z
// if the cube root doesn't exist, Cbrt returns nil
//
// p² ≡ 10 (mod 27), single exponentiation + adjustment.
// Reference: Lemma 3 of https://eprint.iacr.org/2021/1446.pdf
func (z *E2) Cbrt(x *E2) *E2 {
	// If x is in Fp (i.e., x.A1 == 0), use Fp cube root directly
	if x.A1.IsZero() {
		if z.A0.Cbrt(&x.A0) == nil {
			return nil
		}
		z.A1.SetZero()
		return z
	}

	var y, c E2
	y.expByE2Cbrt(*x)

	// c = y³
	c.Square(&y).Mul(&c, &y)
	if c.Equal(x) {
		return z.Set(&y)
	}

	// Primitive cube roots of unity ω, ω² (in Fp, embedded as (ω, 0))
	var omega, omega2 E2
	omega.A0 = fp.Element{
		8183898218631979349,
		12014359695528440611,
		12263358156045030468,
		3187210487005268291,
	}
	omega2.A0 = fp.Element{
		3697675806616062876,
		9065277094688085689,
		6918009208039626314,
		2775033306905974752,
	}

	// Primitive 9th roots of unity ζ, ζ² (in Fp)
	var zeta, zeta2 E2
	zeta.A0 = fp.Element{
		9092840637269024442,
		11284133545212953584,
		7919372827184455520,
		1596114425137527684,
	}
	zeta2.A0 = fp.Element{
		1735008219140503419,
		10465829585049341007,
		6017168831245289042,
		1570250484855163800,
	}

	// Check if c * ω² = x, then y * ζ is the cube root
	var cw2 E2
	cw2.Mul(&c, &omega2)
	if cw2.Equal(x) {
		return z.Mul(&y, &zeta)
	}

	// Check if c * ω = x, then y * ζ² is the cube root
	var cw E2
	cw.Mul(&c, &omega)
	if cw.Equal(x) {
		return z.Mul(&y, &zeta2)
	}

	// x is not a cubic residue
	return nil
}

// expByE2Cbrt is equivalent to z.Exp(x, ad76de41a5af60ea315d97688a2286dda209e0149bcd7bb708258216df4faba1830243f61450cc77484dacc5bf5165ad7b68d3edc5898e503f230287a81acb).
// It uses an addition chain for efficient exponentiation in E2.
//
// uses github.com/mmcloughlin/addchain v0.4.0 to generate a shorter addition chain
func (z *E2) expByE2Cbrt(x E2) *E2 {
	// addition chain:
	//
	//	_10       = 2*1
	//	_100      = 2*_10
	//	_101      = 1 + _100
	//	_110      = 1 + _101
	//	_1010     = _100 + _110
	//	_1011     = 1 + _1010
	//	_10001    = _110 + _1011
	//	_10010    = 1 + _10001
	//	_10101    = _100 + _10001
	//	_11101    = _1011 + _10010
	//	_100011   = _110 + _11101
	//	_101001   = _110 + _100011
	//	_101101   = _100 + _101001
	//	_101111   = _10 + _101101
	//	_111011   = _10010 + _101001
	//	_111111   = _100 + _111011
	//	_1000011  = _100 + _111111
	//	_1000111  = _100 + _1000011
	//	_1001011  = _100 + _1000111
	//	_1001111  = _100 + _1001011
	//	_1010001  = _10 + _1001111
	//	_1011001  = _1010 + _1001111
	//	_1101011  = _10010 + _1011001
	//	_1101111  = _100 + _1101011
	//	_1110101  = _110 + _1101111
	//	_10000001 = _10010 + _1101111
	//	_10000011 = _10 + _10000001
	//	_10000101 = _10 + _10000011
	//	_10000111 = _10 + _10000101
	//	_10001001 = _10 + _10000111
	//	_10011011 = _10010 + _10001001
	//	_10100001 = _110 + _10011011
	//	_10110011 = _10010 + _10100001
	//	_10110111 = _100 + _10110011
	//	_10111011 = _100 + _10110111
	//	_10111101 = _10 + _10111011
	//	_11000001 = _100 + _10111101
	//	_11000101 = _100 + _11000001
	//	_11000111 = _10 + _11000101
	//	_11010001 = _1010 + _11000111
	//	_11010011 = _10 + _11010001
	//	_11010111 = _100 + _11010011
	//	_11100001 = _1010 + _11010111
	//	_11101001 = _10010 + _11010111
	//	_11101101 = _100 + _11101001
	//	i62       = ((_10000011 + _11010111) << 8 + _11101101) << 6 + _101111
	//	i91       = ((i62 << 10 + _10000011) << 8 + _1001011) << 9
	//	i107      = ((_10111101 + i91) << 8 + _10000011) << 5 + _10101
	//	i137      = ((i107 << 11 + _11000101) << 7 + _111011) << 10
	//	i156      = ((_10111011 + i137) << 6 + _10001) << 10 + _1010001
	//	i186      = ((i156 << 11 + _10100001) << 8 + _10110111) << 9
	//	i215      = ((_11010001 + i186) << 12 + _1001111) << 14 + _101001
	//	i244      = ((i215 << 9 + _1101111) << 10 + _11010111) << 8
	//	i268      = ((_10111011 + i244) << 9 + _11100001) << 12 + _1001011
	//	i299      = ((i268 << 13 + _10000101) << 8 + _10110111) << 8
	//	i315      = ((_11010011 + i299) << 7 + _1110101) << 6 + _11101
	//	i347      = ((i315 << 12 + _11000001) << 8 + _10000001) << 10
	//	i367      = ((_10000111 + i347) << 6 + _111011) << 11 + _1010001
	//	i396      = ((i367 << 8 + _1000011) << 10 + _11000111) << 9
	//	i420      = ((_11101001 + i396) << 12 + _10011011) << 9 + _10110011
	//	i450      = ((i420 << 11 + _10110111) << 7 + _1110101) << 10
	//	i470      = ((_1011001 + i450) << 8 + _1101011) << 9 + _10111101
	//	i497      = ((i470 << 6 + _101101) << 11 + _11010011) << 8
	//	i516      = ((_11101101 + i497) << 8 + _11000101) << 8 + _10001001
	//	i542      = ((i516 << 7 + _1000111) << 5 + _101) << 12
	//	i567      = ((_111111 + i542) << 8 + _100011) << 14 + _10100001
	//	i595      = ((i567 << 7 + _1110101) << 13 + _1101011) << 6
	//	return      _1011 + i595
	//
	// Operations: 497 squares 99 multiplies

	// Allocate Temporaries.
	var (
		t0  = new(E2)
		t1  = new(E2)
		t2  = new(E2)
		t3  = new(E2)
		t4  = new(E2)
		t5  = new(E2)
		t6  = new(E2)
		t7  = new(E2)
		t8  = new(E2)
		t9  = new(E2)
		t10 = new(E2)
		t11 = new(E2)
		t12 = new(E2)
		t13 = new(E2)
		t14 = new(E2)
		t15 = new(E2)
		t16 = new(E2)
		t17 = new(E2)
		t18 = new(E2)
		t19 = new(E2)
		t20 = new(E2)
		t21 = new(E2)
		t22 = new(E2)
		t23 = new(E2)
		t24 = new(E2)
		t25 = new(E2)
		t26 = new(E2)
		t27 = new(E2)
		t28 = new(E2)
		t29 = new(E2)
		t30 = new(E2)
		t31 = new(E2)
		t32 = new(E2)
		t33 = new(E2)
		t34 = new(E2)
		t35 = new(E2)
		t36 = new(E2)
		t37 = new(E2)
		t38 = new(E2)
		t39 = new(E2)
	)

	t10.Square(&x)

	t9.Square(t10)

	t5.Mul(&x, t9)

	t2.Mul(&x, t5)

	t28.Mul(t9, t2)

	z.Mul(&x, t28)

	t35.Mul(t2, z)

	t17.Mul(&x, t35)

	t36.Mul(t9, t35)

	t25.Mul(z, t17)

	t3.Mul(t2, t25)

	t32.Mul(t2, t3)

	t11.Mul(t9, t32)

	t38.Mul(t10, t11)

	t21.Mul(t17, t32)

	t4.Mul(t9, t21)

	t19.Mul(t9, t4)

	t6.Mul(t9, t19)

	t27.Mul(t9, t6)

	t33.Mul(t9, t27)

	t20.Mul(t10, t33)

	t13.Mul(t28, t33)

	t0.Mul(t17, t13)

	t31.Mul(t9, t0)

	t1.Mul(t2, t31)

	t23.Mul(t17, t31)

	t37.Mul(t10, t23)

	t26.Mul(t10, t37)

	t22.Mul(t10, t26)

	t7.Mul(t10, t22)

	t16.Mul(t17, t7)

	t2.Mul(t2, t16)

	t15.Mul(t17, t2)

	t14.Mul(t9, t15)

	t29.Mul(t9, t14)

	t12.Mul(t10, t29)

	t24.Mul(t9, t12)

	t8.Mul(t9, t24)

	t18.Mul(t10, t8)

	t34.Mul(t28, t18)

	t10.Mul(t10, t34)

	t30.Mul(t9, t10)

	t28.Mul(t28, t30)

	t17.Mul(t17, t30)

	t9.Mul(t9, t17)

	t39.Mul(t37, t30)

	for s := 0; s < 8; s++ {
		t39.Square(t39)
	}

	t39.Mul(t9, t39)

	for s := 0; s < 6; s++ {
		t39.Square(t39)
	}

	t38.Mul(t38, t39)

	for s := 0; s < 10; s++ {
		t38.Square(t38)
	}

	t38.Mul(t37, t38)

	for s := 0; s < 8; s++ {
		t38.Square(t38)
	}

	t38.Mul(t27, t38)

	for s := 0; s < 9; s++ {
		t38.Square(t38)
	}

	t38.Mul(t12, t38)

	for s := 0; s < 8; s++ {
		t38.Square(t38)
	}

	t37.Mul(t37, t38)

	for s := 0; s < 5; s++ {
		t37.Square(t37)
	}

	t36.Mul(t36, t37)

	for s := 0; s < 11; s++ {
		t36.Square(t36)
	}

	t36.Mul(t8, t36)

	for s := 0; s < 7; s++ {
		t36.Square(t36)
	}

	t36.Mul(t21, t36)

	for s := 0; s < 10; s++ {
		t36.Square(t36)
	}

	t36.Mul(t29, t36)

	for s := 0; s < 6; s++ {
		t36.Square(t36)
	}

	t35.Mul(t35, t36)

	for s := 0; s < 10; s++ {
		t35.Square(t35)
	}

	t35.Mul(t20, t35)

	for s := 0; s < 11; s++ {
		t35.Square(t35)
	}

	t35.Mul(t2, t35)

	for s := 0; s < 8; s++ {
		t35.Square(t35)
	}

	t35.Mul(t14, t35)

	for s := 0; s < 9; s++ {
		t35.Square(t35)
	}

	t34.Mul(t34, t35)

	for s := 0; s < 12; s++ {
		t34.Square(t34)
	}

	t33.Mul(t33, t34)

	for s := 0; s < 14; s++ {
		t33.Square(t33)
	}

	t32.Mul(t32, t33)

	for s := 0; s < 9; s++ {
		t32.Square(t32)
	}

	t31.Mul(t31, t32)

	for s := 0; s < 10; s++ {
		t31.Square(t31)
	}

	t30.Mul(t30, t31)

	for s := 0; s < 8; s++ {
		t30.Square(t30)
	}

	t29.Mul(t29, t30)

	for s := 0; s < 9; s++ {
		t29.Square(t29)
	}

	t28.Mul(t28, t29)

	for s := 0; s < 12; s++ {
		t28.Square(t28)
	}

	t27.Mul(t27, t28)

	for s := 0; s < 13; s++ {
		t27.Square(t27)
	}

	t26.Mul(t26, t27)

	for s := 0; s < 8; s++ {
		t26.Square(t26)
	}

	t26.Mul(t14, t26)

	for s := 0; s < 8; s++ {
		t26.Square(t26)
	}

	t26.Mul(t10, t26)

	for s := 0; s < 7; s++ {
		t26.Square(t26)
	}

	t26.Mul(t1, t26)

	for s := 0; s < 6; s++ {
		t26.Square(t26)
	}

	t25.Mul(t25, t26)

	for s := 0; s < 12; s++ {
		t25.Square(t25)
	}

	t24.Mul(t24, t25)

	for s := 0; s < 8; s++ {
		t24.Square(t24)
	}

	t23.Mul(t23, t24)

	for s := 0; s < 10; s++ {
		t23.Square(t23)
	}

	t22.Mul(t22, t23)

	for s := 0; s < 6; s++ {
		t22.Square(t22)
	}

	t21.Mul(t21, t22)

	for s := 0; s < 11; s++ {
		t21.Square(t21)
	}

	t20.Mul(t20, t21)

	for s := 0; s < 8; s++ {
		t20.Square(t20)
	}

	t19.Mul(t19, t20)

	for s := 0; s < 10; s++ {
		t19.Square(t19)
	}

	t18.Mul(t18, t19)

	for s := 0; s < 9; s++ {
		t18.Square(t18)
	}

	t17.Mul(t17, t18)

	for s := 0; s < 12; s++ {
		t17.Square(t17)
	}

	t16.Mul(t16, t17)

	for s := 0; s < 9; s++ {
		t16.Square(t16)
	}

	t15.Mul(t15, t16)

	for s := 0; s < 11; s++ {
		t15.Square(t15)
	}

	t14.Mul(t14, t15)

	for s := 0; s < 7; s++ {
		t14.Square(t14)
	}

	t14.Mul(t1, t14)

	for s := 0; s < 10; s++ {
		t14.Square(t14)
	}

	t13.Mul(t13, t14)

	for s := 0; s < 8; s++ {
		t13.Square(t13)
	}

	t13.Mul(t0, t13)

	for s := 0; s < 9; s++ {
		t13.Square(t13)
	}

	t12.Mul(t12, t13)

	for s := 0; s < 6; s++ {
		t12.Square(t12)
	}

	t11.Mul(t11, t12)

	for s := 0; s < 11; s++ {
		t11.Square(t11)
	}

	t10.Mul(t10, t11)

	for s := 0; s < 8; s++ {
		t10.Square(t10)
	}

	t9.Mul(t9, t10)

	for s := 0; s < 8; s++ {
		t9.Square(t9)
	}

	t8.Mul(t8, t9)

	for s := 0; s < 8; s++ {
		t8.Square(t8)
	}

	t7.Mul(t7, t8)

	for s := 0; s < 7; s++ {
		t7.Square(t7)
	}

	t6.Mul(t6, t7)

	for s := 0; s < 5; s++ {
		t6.Square(t6)
	}

	t5.Mul(t5, t6)

	for s := 0; s < 12; s++ {
		t5.Square(t5)
	}

	t4.Mul(t4, t5)

	for s := 0; s < 8; s++ {
		t4.Square(t4)
	}

	t3.Mul(t3, t4)

	for s := 0; s < 14; s++ {
		t3.Square(t3)
	}

	t2.Mul(t2, t3)

	for s := 0; s < 7; s++ {
		t2.Square(t2)
	}

	t1.Mul(t1, t2)

	for s := 0; s < 13; s++ {
		t1.Square(t1)
	}

	t0.Mul(t0, t1)

	for s := 0; s < 6; s++ {
		t0.Square(t0)
	}

	z.Mul(z, t0)

	return z
}

// BatchInvertE2 returns a new slice with every element in a inverted.
// It uses Montgomery batch inversion trick.
//
// if a[i] == 0, returns result[i] = a[i]
func BatchInvertE2(a []E2) []E2 {
	res := make([]E2, len(a))
	if len(a) == 0 {
		return res
	}

	zeroes := make([]bool, len(a))
	var accumulator E2
	accumulator.SetOne()

	for i := 0; i < len(a); i++ {
		if a[i].IsZero() {
			zeroes[i] = true
			continue
		}
		res[i].Set(&accumulator)
		accumulator.Mul(&accumulator, &a[i])
	}

	accumulator.Inverse(&accumulator)

	for i := len(a) - 1; i >= 0; i-- {
		if zeroes[i] {
			continue
		}
		res[i].Mul(&res[i], &accumulator)
		accumulator.Mul(&accumulator, &a[i])
	}

	return res
}

// Select is conditional move.
// If cond = 0, it sets z to caseZ and returns it. otherwise caseNz.
func (z *E2) Select(cond int, caseZ *E2, caseNz *E2) *E2 {
	//Might be able to save a nanosecond or two by an aggregate implementation

	z.A0.Select(cond, &caseZ.A0, &caseNz.A0)
	z.A1.Select(cond, &caseZ.A1, &caseNz.A1)

	return z
}

// Div divides an element in E2 by an element in E2
func (z *E2) Div(x *E2, y *E2) *E2 {
	var r E2
	r.Inverse(y).Mul(x, &r)
	return z.Set(&r)
}
