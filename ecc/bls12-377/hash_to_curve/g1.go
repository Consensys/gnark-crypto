// Copyright 2020-2026 Consensys Software Inc.
// Licensed under the Apache License, Version 2.0. See the LICENSE file for details.

// Code generated by consensys/gnark-crypto DO NOT EDIT

package hash_to_curve

import (
	"sync"

	"github.com/consensys/gnark-crypto/ecc/bls12-377/fp"
)

// Note: This only works for simple extensions

var (
	g1sswuCurveACoeff = fp.Element{17252667382019449424, 8408110001211059699, 18415587021986261264, 10797086888535946954, 9462758283094809199, 54995354010328751}
	g1sswuCurveBCoeff = fp.Element{11130294635325289193, 6502679372128844082, 15863297759487624914, 16270683149854112145, 3560014356538878812, 27923742146399959}
)

var g1sswuCurveZ = fp.Element{9871116327010172167, 9167007004823125620, 18338974479346628539, 5649234265355377548, 13442091487463296847, 77904398905292312}

// G1SSWUCurveCoefficients returns the coefficients of the SSWU curve.
func G1SSWUIsogenyCurveCoefficients() (A fp.Element, B fp.Element) {
	return g1sswuCurveACoeff, g1sswuCurveBCoeff
}

// G1SSWUIsogenyZ returns the recommended Z value of the SSWU curve.
//
// See https://www.rfc-editor.org/rfc/rfc9380.html#weierstrass
func G1SSWUIsogenyZ() fp.Element {
	return g1sswuCurveZ
}

var (
	g1IsogenyXNumeratorMap = []fp.Element{
		{9381318728011785451, 8795417190580748876, 15171640721257608922, 11815547924113428908, 15499908520243100994, 75408755324413256},
		{12414498063752772717, 9915153185132073893, 5598625970987438951, 3342254783599619135, 3349592178919125510, 9993871847068096},
		{4662210776746950618, 10687085762534440940, 7484820859645808636, 2221301482234255553, 10609677459585442106, 9950135580589350},
	}
	g1IsogenyXDenominatorMap = []fp.Element{
		{12764504107591987636, 2767124593109192342, 3947759810240204190, 13369019134398476541, 13398368715676502040, 39975487388272384},
	}
	g1IsogenyYNumeratorMap = []fp.Element{
		{13844135623281082635, 637899392157745290, 5176720401210677272, 4780940929980393029, 13803251044890140836, 51447363642369244},
		{512010462697120695, 609509684909242946, 13763343875136563934, 2839514380057330869, 15407015190976871917, 114223893455203604},
		{14191436515319700132, 6479619458373647736, 9513056055282499867, 15178407828209519654, 12166396751953702822, 75539964123849493},
		{2331105388373475309, 5343542881267220470, 12965782466677680126, 1110650741117127776, 5304838729792721053, 4975067790294675},
	}
	g1IsogenyYDenominatorMap = []fp.Element{
		{8694832399336342723, 13482963304561246841, 6984108042366343277, 8355250559073919616, 16937021447778317421, 44890599540624877},
		{1100361703846424922, 5005767817281133373, 917019320419705433, 14251746270386956490, 5522097789867984932, 4443041874334878},
		{1400024175356859676, 8301373779327577028, 11843279430720612570, 3213569255776326391, 3301617999610402890, 119926462164817154},
	}
)

// G1IsogenyMap returns the isogeny map for the curve.
// The isogeny map is a list of polynomial coefficients for the x and y coordinate computation.
// The order of the coefficients is as follows:
// - x numerator, x denominator, y numerator, y denominator.
func G1IsogenyMap() [4][]fp.Element {
	return [4][]fp.Element{
		g1IsogenyXNumeratorMap,
		g1IsogenyXDenominatorMap,
		g1IsogenyYNumeratorMap,
		g1IsogenyYDenominatorMap,
	}
}

func g1IsogenyXNumerator(dst *fp.Element, x *fp.Element) {
	g1EvalPolynomial(dst, false, g1IsogenyXNumeratorMap, x)
}

func g1IsogenyXDenominator(dst *fp.Element, x *fp.Element) {
	g1EvalPolynomial(dst, true, g1IsogenyXDenominatorMap, x)
}

func g1IsogenyYNumerator(dst *fp.Element, x *fp.Element, y *fp.Element) {
	var _dst fp.Element
	g1EvalPolynomial(&_dst, false, g1IsogenyYNumeratorMap, x)
	dst.Mul(&_dst, y)
}

func g1IsogenyYDenominator(dst *fp.Element, x *fp.Element) {
	g1EvalPolynomial(dst, true, g1IsogenyYDenominatorMap, x)
}

// G1 computes the isogeny map of the curve element, given by its coordinates pX and pY.
// It mutates the coordinates pX and pY to the new coordinates of the isogeny map.
func G1Isogeny(pX, pY *fp.Element) {

	den := make([]fp.Element, 2)

	g1IsogenyYDenominator(&den[1], pX)
	g1IsogenyXDenominator(&den[0], pX)

	g1IsogenyYNumerator(pY, pX, pY)
	g1IsogenyXNumerator(pX, pX)

	den = fp.BatchInvert(den)

	pX.Mul(pX, &den[0])
	pY.Mul(pY, &den[1])
}

// G1SqrtRatio computes the square root of u/v and returns 0 iff u/v was indeed a quadratic residue.
// If not, we get sqrt(Z * u / v). Recall that Z is non-residue.
// If v = 0, u/v is meaningless and the output is unspecified, without raising an error.
// The main idea is that since the computation of the square root involves taking large powers of u/v, the inversion of v can be avoided
func G1SqrtRatio(z *fp.Element, u *fp.Element, v *fp.Element) uint64 {

	// Sarkar's algorithm for SqrtRatio - optimized for high 2-adicity fields
	// Computes sqrt(u/v) as sqrt(u*v) / v to avoid explicit division
	// Reference: "On the computation of square roots in finite fields" by Palash Sarkar

	// Handle u = 0 case: sqrt(0/v) = 0, which is a quadratic residue
	if u.IsZero() {
		z.SetZero()
		return 0
	}

	// Initialize Sarkar precomputed tables (thread-safe, runs once)
	g1InitSarkarOnce.Do(g1InitSarkar)

	// x = u * v
	var x fp.Element
	x.Mul(u, v)

	// w = x^((m-1)/2) = (u*v)^((m-1)/2)
	var w fp.Element
	w.ExpBySqrtExp(x)

	// xM = x^m = x * w^2 = (u*v)^m
	var xM fp.Element
	xM.Square(&w)
	xM.Mul(&xM, &x)

	// Check if u/v is QR by checking if (u*v)^m has order dividing 2^(e-1)
	// Note: (u/v | p) = (u*v | p) since (v^(-1) | p) = (v | p) for Legendre symbols
	t := xM
	for i := 0; i < g1SarkarN-1; i++ {
		t.Square(&t)
	}
	isQNr := !t.IsOne() // t should be Â±1; if -1 then u/v is not QR
	isQNrInt := uint64(0)
	if isQNr {
		isQNrInt = 1
		// If not QR, we compute sqrt(Z*u/v) = sqrt(Z*u*v) / v instead
		// x already holds u*v, so we just multiply by Z
		G1MulByZ(&x, &x)  // x = Z*u*v
		w.ExpBySqrtExp(x) // w = (Z*u*v)^((m-1)/2)
		xM.Square(&w)
		xM.Mul(&xM, &x) // xM = (Z*u*v)^m
	}

	// Precompute xM^(2^i) for i = 0..e-1
	var xPow [g1SarkarN]fp.Element
	xPow[0] = xM
	for i := 1; i < g1SarkarN; i++ {
		xPow[i].Square(&xPow[i-1])
	}

	// Compute xis[i] = xM^(2^(e-1-sumL[i])) where sumL[i] = L[0]+...+L[i]
	var xis [g1SarkarK]fp.Element
	var sumL uint64
	for i := 0; i < g1SarkarK; i++ {
		sumL += g1SarkarL[i]
		idx := g1SarkarN - 1 - int(sumL)
		xis[i] = xPow[idx]
	}

	// Main Sarkar loop
	var s, tt uint64
	for i := 0; i < g1SarkarK; i++ {
		tt = (s + tt) >> g1SarkarL[i]
		var gamma fp.Element
		g1SarkarPowG(&gamma, tt)
		var alpha fp.Element
		alpha.Mul(&xis[i], &gamma)
		s = g1SarkarEval(&alpha)
	}

	tt = s + tt
	var gamma fp.Element
	g1SarkarPowG(&gamma, tt>>1)

	// Compute the square root
	// sqrt(x) = x * x^((m-1)/2) * gamma = x * w * gamma
	// sqrt(u/v) = sqrt(u*v) / v = (u*v) * w * gamma / v = u * w * gamma
	// For non-QR: sqrt(Z*u/v) = sqrt(Z*u*v) / v = Z*u * w * gamma
	z.Mul(u, &w)
	z.Mul(z, &gamma)
	if isQNr {
		G1MulByZ(z, z)
	}

	return isQNrInt
}

// Sarkar constants for G1 SqrtRatio
const (
	g1SarkarN = 46 // 2-adicity
	g1SarkarK = 7  // number of blocks
)

var g1SarkarL = [g1SarkarK]uint64{
	6,
	6,
	6,
	6,
	7,
	7,
	7,
}

// g = Z^m, primitive 2^e-th root of unity
var g1SarkarG = fp.Element{7563926049028936178, 2688164645460651601, 12112688591437172399, 3177973240564633687, 14764383749841851163, 52487407124055189}

var g1SarkarGPow [g1SarkarN]fp.Element
var g1MinusOne fp.Element
var g1InitSarkarOnce sync.Once

func g1InitSarkar() {
	g1SarkarGPow[0] = g1SarkarG
	for i := 1; i < g1SarkarN; i++ {
		g1SarkarGPow[i].Square(&g1SarkarGPow[i-1])
	}
	g1MinusOne.SetOne()
	g1MinusOne.Neg(&g1MinusOne)
}

// g1SarkarPowG sets z to g^exp, where g has order 2^e and exp < 2^e.
func g1SarkarPowG(z *fp.Element, exp uint64) *fp.Element {
	if exp == 0 {
		return z.SetOne()
	}
	var acc fp.Element
	acc.SetOne()
	i := 0
	for exp > 0 {
		if exp&1 == 1 {
			acc.Mul(&acc, &g1SarkarGPow[i])
		}
		exp >>= 1
		i++
	}
	return z.Set(&acc)
}

// g1SarkarFind returns the smallest i >= 0 such that delta^(2^i) = -1.
func g1SarkarFind(delta *fp.Element) uint64 {
	var mu fp.Element
	mu.Set(delta)
	var i uint64
	for !mu.Equal(&g1MinusOne) {
		mu.Square(&mu)
		i++
	}
	return i
}

// g1SarkarEval returns s such that alpha * g^s = 1, where alpha^(2^l) = 1 for some l.
func g1SarkarEval(alpha *fp.Element) uint64 {
	var delta fp.Element
	delta.Set(alpha)
	var s uint64
	for !delta.IsOne() {
		i := g1SarkarFind(&delta)
		s += uint64(1) << uint(g1SarkarN-1-int(i))
		if i > 0 {
			delta.Mul(&delta, &g1SarkarGPow[g1SarkarN-1-int(i)])
		} else {
			delta.Neg(&delta)
		}
	}
	return s
}

// G1MulByZ multiplies x by [5] and stores the result in z
func G1MulByZ(z *fp.Element, x *fp.Element) {

	res := *x

	res.Double(&res)
	res.Double(&res)
	res.Add(&res, x)

	*z = res
}

func g1EvalPolynomial(z *fp.Element, monic bool, coefficients []fp.Element, x *fp.Element) {
	dst := coefficients[len(coefficients)-1]

	if monic {
		dst.Add(&dst, x)
	}

	for i := len(coefficients) - 2; i >= 0; i-- {
		dst.Mul(&dst, x)
		dst.Add(&dst, &coefficients[i])
	}

	z.Set(&dst)
}

// G1Sgn0 is an algebraic substitute for the notion of sign in ordered fields.
// Namely, every non-zero quadratic residue in a finite field of characteristic =/= 2 has exactly two square roots, one of each sign.
//
// See: https://www.rfc-editor.org/rfc/rfc9380.html#name-the-sgn0-function
//
// The sign of an element is not obviously related to that of its Montgomery form
func G1Sgn0(z *fp.Element) uint64 {

	nonMont := z.Bits()

	// m == 1
	return nonMont[0] % 2

}

func G1NotZero(x *fp.Element) uint64 {

	return x[0] | x[1] | x[2] | x[3] | x[4] | x[5]

}
