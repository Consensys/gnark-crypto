// Copyright 2020-2025 Consensys Software Inc.
// Licensed under the Apache License, Version 2.0. See the LICENSE file for details.

// Code generated by consensys/gnark-crypto DO NOT EDIT

package fp

// ExpBySqrtPp1o4 is equivalent to z.Exp(x, 3fffffffc0000000400000000000000000000000400000000000000000000000).
// It raises x to the (p+1)/4 power using a shorter addition chain.
//
// uses github.com/mmcloughlin/addchain v0.4.0 to generate a shorter addition chain
func (z *Element) ExpBySqrtPp1o4(x Element) *Element {
	// addition chain:
	//
	//	_10       = 2*1
	//	_11       = 1 + _10
	//	_1100     = _11 << 2
	//	_1111     = _11 + _1100
	//	_11110000 = _1111 << 4
	//	_11111111 = _1111 + _11110000
	//	x16       = _11111111 << 8 + _11111111
	//	x32       = x16 << 16 + x16
	//	return      ((x32 << 32 + 1) << 96 + 1) << 94
	//
	// Operations: 253 squares 7 multiplies

	// Allocate Temporaries.
	var (
		t0 = new(Element)
	)

	// var t0 Element
	// Step 1: z = x^0x2
	z.Square(&x)

	// Step 2: z = x^0x3
	z.Mul(&x, z)

	// Step 4: t0 = x^0xc
	t0.Square(z)
	for s := 1; s < 2; s++ {
		t0.Square(t0)
	}

	// Step 5: z = x^0xf
	z.Mul(z, t0)

	// Step 9: t0 = x^0xf0
	t0.Square(z)
	for s := 1; s < 4; s++ {
		t0.Square(t0)
	}

	// Step 10: z = x^0xff
	z.Mul(z, t0)

	// Step 18: t0 = x^0xff00
	t0.Square(z)
	for s := 1; s < 8; s++ {
		t0.Square(t0)
	}

	// Step 19: z = x^0xffff
	z.Mul(z, t0)

	// Step 35: t0 = x^0xffff0000
	t0.Square(z)
	for s := 1; s < 16; s++ {
		t0.Square(t0)
	}

	// Step 36: z = x^0xffffffff
	z.Mul(z, t0)

	// Step 68: z = x^0xffffffff00000000
	for s := 0; s < 32; s++ {
		z.Square(z)
	}

	// Step 69: z = x^0xffffffff00000001
	z.Mul(&x, z)

	// Step 165: z = x^0xffffffff00000001000000000000000000000000
	for s := 0; s < 96; s++ {
		z.Square(z)
	}

	// Step 166: z = x^0xffffffff00000001000000000000000000000001
	z.Mul(&x, z)

	// Step 260: z = x^0x3fffffffc0000000400000000000000000000000400000000000000000000000
	for s := 0; s < 94; s++ {
		z.Square(z)
	}

	return z
}

// ExpBySqrtPm3o4 is equivalent to z.Exp(x, 3fffffffc00000004000000000000000000000003fffffffffffffffffffffff).
// It raises x to the (p-3)/4 power using a shorter addition chain.
//
// uses github.com/mmcloughlin/addchain v0.4.0 to generate a shorter addition chain
func (z *Element) ExpBySqrtPm3o4(x Element) *Element {
	// addition chain:
	//
	//	_10     = 2*1
	//	_11     = 1 + _10
	//	_110    = 2*_11
	//	_111    = 1 + _110
	//	_111000 = _111 << 3
	//	_111111 = _111 + _111000
	//	x12     = _111111 << 6 + _111111
	//	x15     = x12 << 3 + _111
	//	x16     = 2*x15 + 1
	//	x32     = x16 << 16 + x16
	//	i53     = x32 << 15
	//	x47     = x15 + i53
	//	i263    = ((i53 << 17 + 1) << 143 + x47) << 47
	//	return    x47 + i263
	//
	// Operations: 253 squares 11 multiplies

	// Allocate Temporaries.
	var (
		t0 = new(Element)
		t1 = new(Element)
	)

	// var t0,t1 Element
	// Step 1: z = x^0x2
	z.Square(&x)

	// Step 2: z = x^0x3
	z.Mul(&x, z)

	// Step 3: z = x^0x6
	z.Square(z)

	// Step 4: z = x^0x7
	z.Mul(&x, z)

	// Step 7: t0 = x^0x38
	t0.Square(z)
	for s := 1; s < 3; s++ {
		t0.Square(t0)
	}

	// Step 8: t0 = x^0x3f
	t0.Mul(z, t0)

	// Step 14: t1 = x^0xfc0
	t1.Square(t0)
	for s := 1; s < 6; s++ {
		t1.Square(t1)
	}

	// Step 15: t0 = x^0xfff
	t0.Mul(t0, t1)

	// Step 18: t0 = x^0x7ff8
	for s := 0; s < 3; s++ {
		t0.Square(t0)
	}

	// Step 19: z = x^0x7fff
	z.Mul(z, t0)

	// Step 20: t0 = x^0xfffe
	t0.Square(z)

	// Step 21: t0 = x^0xffff
	t0.Mul(&x, t0)

	// Step 37: t1 = x^0xffff0000
	t1.Square(t0)
	for s := 1; s < 16; s++ {
		t1.Square(t1)
	}

	// Step 38: t0 = x^0xffffffff
	t0.Mul(t0, t1)

	// Step 53: t0 = x^0x7fffffff8000
	for s := 0; s < 15; s++ {
		t0.Square(t0)
	}

	// Step 54: z = x^0x7fffffffffff
	z.Mul(z, t0)

	// Step 71: t0 = x^0xffffffff00000000
	for s := 0; s < 17; s++ {
		t0.Square(t0)
	}

	// Step 72: t0 = x^0xffffffff00000001
	t0.Mul(&x, t0)

	// Step 215: t0 = x^0x7fffffff80000000800000000000000000000000000000000000
	for s := 0; s < 143; s++ {
		t0.Square(t0)
	}

	// Step 216: t0 = x^0x7fffffff800000008000000000000000000000007fffffffffff
	t0.Mul(z, t0)

	// Step 263: t0 = x^0x3fffffffc00000004000000000000000000000003fffffffffff800000000000
	for s := 0; s < 47; s++ {
		t0.Square(t0)
	}

	// Step 264: z = x^0x3fffffffc00000004000000000000000000000003fffffffffffffffffffffff
	z.Mul(z, t0)

	return z
}

// ExpByLegendreExp is equivalent to z.Exp(x, 7fffffff800000008000000000000000000000007fffffffffffffffffffffff).
//
// uses github.com/mmcloughlin/addchain v0.4.0 to generate a shorter addition chain
func (z *Element) ExpByLegendreExp(x Element) *Element {
	// addition chain:
	//
	//	_10     = 2*1
	//	_11     = 1 + _10
	//	_110    = 2*_11
	//	_111    = 1 + _110
	//	_111000 = _111 << 3
	//	_111111 = _111 + _111000
	//	x12     = _111111 << 6 + _111111
	//	x15     = x12 << 3 + _111
	//	x16     = 2*x15 + 1
	//	x32     = x16 << 16 + x16
	//	i53     = x32 << 15
	//	x47     = x15 + i53
	//	i263    = ((i53 << 17 + 1) << 143 + x47) << 47
	//	return    2*(x47 + i263) + 1
	//
	// Operations: 254 squares 12 multiplies

	// Allocate Temporaries.
	var (
		t0 = new(Element)
		t1 = new(Element)
	)

	// var t0,t1 Element
	// Step 1: z = x^0x2
	z.Square(&x)

	// Step 2: z = x^0x3
	z.Mul(&x, z)

	// Step 3: z = x^0x6
	z.Square(z)

	// Step 4: z = x^0x7
	z.Mul(&x, z)

	// Step 7: t0 = x^0x38
	t0.Square(z)
	for s := 1; s < 3; s++ {
		t0.Square(t0)
	}

	// Step 8: t0 = x^0x3f
	t0.Mul(z, t0)

	// Step 14: t1 = x^0xfc0
	t1.Square(t0)
	for s := 1; s < 6; s++ {
		t1.Square(t1)
	}

	// Step 15: t0 = x^0xfff
	t0.Mul(t0, t1)

	// Step 18: t0 = x^0x7ff8
	for s := 0; s < 3; s++ {
		t0.Square(t0)
	}

	// Step 19: z = x^0x7fff
	z.Mul(z, t0)

	// Step 20: t0 = x^0xfffe
	t0.Square(z)

	// Step 21: t0 = x^0xffff
	t0.Mul(&x, t0)

	// Step 37: t1 = x^0xffff0000
	t1.Square(t0)
	for s := 1; s < 16; s++ {
		t1.Square(t1)
	}

	// Step 38: t0 = x^0xffffffff
	t0.Mul(t0, t1)

	// Step 53: t0 = x^0x7fffffff8000
	for s := 0; s < 15; s++ {
		t0.Square(t0)
	}

	// Step 54: z = x^0x7fffffffffff
	z.Mul(z, t0)

	// Step 71: t0 = x^0xffffffff00000000
	for s := 0; s < 17; s++ {
		t0.Square(t0)
	}

	// Step 72: t0 = x^0xffffffff00000001
	t0.Mul(&x, t0)

	// Step 215: t0 = x^0x7fffffff80000000800000000000000000000000000000000000
	for s := 0; s < 143; s++ {
		t0.Square(t0)
	}

	// Step 216: t0 = x^0x7fffffff800000008000000000000000000000007fffffffffff
	t0.Mul(z, t0)

	// Step 263: t0 = x^0x3fffffffc00000004000000000000000000000003fffffffffff800000000000
	for s := 0; s < 47; s++ {
		t0.Square(t0)
	}

	// Step 264: z = x^0x3fffffffc00000004000000000000000000000003fffffffffffffffffffffff
	z.Mul(z, t0)

	// Step 265: z = x^0x7fffffff800000008000000000000000000000007ffffffffffffffffffffffe
	z.Square(z)

	// Step 266: z = x^0x7fffffff800000008000000000000000000000007fffffffffffffffffffffff
	z.Mul(&x, z)

	return z
}
