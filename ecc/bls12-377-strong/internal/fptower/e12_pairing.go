package fptower

func (z *E12) nSquare(n int) {
	for i := 0; i < n; i++ {
		z.CyclotomicSquare(z)
	}
}

func (z *E12) nSquareCompressed(n int) {
	for i := 0; i < n; i++ {
		z.CyclotomicSquareCompressed(z)
	}
}

// Expt set z to x^t in E12 and return z
func (z *E12) Expt(x *E12) *E12 {
	// Expt computation is derived from the addition chain:
	//
	//	_10    = 2*1
	//	_100   = 2*_10
	//	_101   = 1 + _100
	//	_111   = _10 + _101
	//	_1011  = _100 + _111
	//	_1101  = _10 + _1011
	//	_10000 = _101 + _1011
	//	i30    = ((_10000 << 6 + _1011) << 8 + _1011) << 7
	//	i46    = ((_1101 + i30) << 6 + _111) << 7 + _1101
	//	return   (2*i46 + _101) << 24 + 1
	//
	// Operations: 61 squares 12 multiplies
	//
	// Generated by github.com/mmcloughlin/addchain v0.4.0.

	// Allocate Temporaries.
	var result E12
	var (
		t0 = new(E12)
		t1 = new(E12)
		t2 = new(E12)
		t3 = new(E12)
	)

	// Step 1: t0 = x^0x2
	t0.CyclotomicSquare(x)

	// Step 2: t2 = x^0x4
	t2.CyclotomicSquare(t0)

	// Step 3: result = x^0x5
	result.Mul(x, t2)

	// Step 4: t1 = x^0x7
	t1.Mul(t0, &result)

	// Step 5: t2 = x^0xb
	t2.Mul(t2, t1)

	// Step 6: t0 = x^0xd
	t0.Mul(t0, t2)

	// Step 7: t3 = x^0x10
	t3.Mul(&result, t2)

	// Step 13: t3 = x^0x400
	t3.nSquare(6)

	// Step 14: t3 = x^0x40b
	t3.Mul(t2, t3)

	// Step 22: t3 = x^0x40b00
	t3.nSquare(8)

	// Step 23: t2 = x^0x40b0b
	t2.Mul(t2, t3)

	// Step 30: t2 = x^0x2058580
	t2.nSquare(7)

	// Step 31: t2 = x^0x205858d
	t2.Mul(t0, t2)

	// Step 37: t2 = x^0x81616340
	t2.nSquare(6)

	// Step 38: t1 = x^0x81616347
	t1.Mul(t1, t2)

	// Step 45: t1 = x^0x40b0b1a380
	t1.nSquare(7)

	// Step 46: t0 = x^0x40b0b1a38d
	t0.Mul(t0, t1)

	// Step 47: t0 = x^0x816163471a
	t0.CyclotomicSquare(t0)

	// Step 48: &result = x^0x816163471f
	result.Mul(&result, t0)

	// Step 72: &result = x^0x816163471f000000
	result.nSquareCompressed(24)
	result.DecompressKarabina(&result)

	// Step 73: &result = x^0x816163471f000001
	result.Mul(x, &result)

	return z.Conjugate(&result) // negative seed
}

// MulBy034 multiplication by sparse element (c0,0,0,c3,c4,0)
func (z *E12) MulBy034(c0, c3, c4 *E2) *E12 {

	var a, b, d E6

	a.MulByE2(&z.C0, c0)

	b.Set(&z.C1)
	b.MulBy01(c3, c4)

	var d0 E2
	d0.Add(c0, c3)
	d.Add(&z.C0, &z.C1)
	d.MulBy01(&d0, c4)

	z.C1.Add(&a, &b).Neg(&z.C1).Add(&z.C1, &d)
	z.C0.MulByNonResidue(&b).Add(&z.C0, &a)

	return z
}

// MulBy34 multiplication by sparse element (1,0,0,c3,c4,0)
func (z *E12) MulBy34(c3, c4 *E2) *E12 {

	var a, b, d E6

	a.Set(&z.C0)

	b.Set(&z.C1)
	b.MulBy01(c3, c4)

	var d0 E2
	d0.SetOne().Add(&d0, c3)
	d.Add(&z.C0, &z.C1)
	d.MulBy01(&d0, c4)

	z.C1.Add(&a, &b).Neg(&z.C1).Add(&z.C1, &d)
	z.C0.MulByNonResidue(&b).Add(&z.C0, &a)

	return z
}

// Mul034By034 multiplication of sparse element (c0,0,0,c3,c4,0) by sparse element (d0,0,0,d3,d4,0)
func Mul034By034(d0, d3, d4, c0, c3, c4 *E2) [5]E2 {
	var z00, tmp, x0, x3, x4, x04, x03, x34 E2
	x0.Mul(c0, d0)
	x3.Mul(c3, d3)
	x4.Mul(c4, d4)
	tmp.Add(c0, c4)
	x04.Add(d0, d4).
		Mul(&x04, &tmp).
		Sub(&x04, &x0).
		Sub(&x04, &x4)
	tmp.Add(c0, c3)
	x03.Add(d0, d3).
		Mul(&x03, &tmp).
		Sub(&x03, &x0).
		Sub(&x03, &x3)
	tmp.Add(c3, c4)
	x34.Add(d3, d4).
		Mul(&x34, &tmp).
		Sub(&x34, &x3).
		Sub(&x34, &x4)

	z00.MulByNonResidue(&x4).
		Add(&z00, &x0)

	return [5]E2{z00, x3, x34, x03, x04}
}

// Mul34By34 multiplication of sparse element (1,0,0,c3,c4,0) by sparse element (1,0,0,d3,d4,0)
func Mul34By34(d3, d4, c3, c4 *E2) [5]E2 {
	var z00, tmp, x0, x3, x4, x04, x03, x34 E2
	x3.Mul(c3, d3)
	x4.Mul(c4, d4)
	x04.Add(c4, d4)
	x03.Add(c3, d3)
	tmp.Add(c3, c4)
	x34.Add(d3, d4).
		Mul(&x34, &tmp).
		Sub(&x34, &x3).
		Sub(&x34, &x4)

	x0.SetOne()
	z00.MulByNonResidue(&x4).
		Add(&z00, &x0)

	return [5]E2{z00, x3, x34, x03, x04}
}

// MulBy01234 multiplies z by an E12 sparse element of the form (x0, x1, x2, x3, x4, 0)
func (z *E12) MulBy01234(x *[5]E2) *E12 {
	var c1, a, b, c, z0, z1 E6
	c0 := &E6{B0: x[0], B1: x[1], B2: x[2]}
	c1.B0 = x[3]
	c1.B1 = x[4]
	a.Add(&z.C0, &z.C1)
	b.Add(c0, &c1)
	a.Mul(&a, &b)
	b.Mul(&z.C0, c0)
	c.Set(&z.C1).MulBy01(&x[3], &x[4])
	z1.Sub(&a, &b)
	z1.Sub(&z1, &c)
	z0.MulByNonResidue(&c)
	z0.Add(&z0, &b)

	z.C0 = z0
	z.C1 = z1

	return z
}
