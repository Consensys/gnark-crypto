// Copyright 2020-2025 Consensys Software Inc.
// Licensed under the Apache License, Version 2.0. See the LICENSE file for details.

// Code generated by consensys/gnark-crypto DO NOT EDIT

package ecdsa

import (
	"crypto/subtle"
	"errors"
	"github.com/consensys/gnark-crypto/ecc/secp256k1/fr"
	"io"
	"math/big"

	"github.com/consensys/gnark-crypto/ecc/secp256k1"
	"github.com/consensys/gnark-crypto/ecc/secp256k1/fr"
)

var errWrongSize = errors.New("wrong size buffer")
var errRBiggerThanRMod = errors.New("r >= r_mod")
var errSBiggerThanHalfRMod = errors.New("s > r_mod/2")
var errZero = errors.New("zero value")

// Bytes returns the binary representation of the public key as concatenation
// of the X and Y coordinates.
func (pk *PublicKey) Bytes() []byte {
	var res [sizePublicKey]byte
	pkBin := pk.A.RawBytes()
	subtle.ConstantTimeCopy(1, res[:sizePublicKey], pkBin[:])
	return res[:]
}

// SetBytes sets the public key from the serialized reprsentation obtained
// using [PublicKey.Bytes].
//
// The length of the input buffer must be at least the size of the compressed
// public key. It returns an error if:
// * the buffer is too short
// * computing valid point from compressed representation fails
//
// Any excess bytes in the input buffer are ignored. The method returns the number of bytes
// read.
func (pk *PublicKey) SetBytes(buf []byte) (int, error) {
	n := 0
	if len(buf) < sizePublicKey {
		return n, io.ErrShortBuffer
	}
	if _, err := pk.A.SetBytes(buf[:sizePublicKey]); err != nil {
		return 0, err
	}
	n += sizePublicKey
	return n, nil
}

// RecoverFrom recovers the public key from the message msg, recovery
// information v and decomposes signature {r,s}. If recovery succeeded, the
// methods sets the current public key to the recovered value. Otherwise returns
// error and leaves current public key unchanged.
func (pk *PublicKey) RecoverFrom(msg []byte, v uint, r, s *big.Int) error {
	if s.Cmp(fr.Modulus()) >= 0 {
		return errors.New("s is larger than modulus")
	}
	if s.Cmp(big.NewInt(0)) <= 0 {
		return errors.New("s is negative")
	}
	P, err := recoverP(v, r)
	if err != nil {
		return err
	}
	z := HashToInt(msg)
	rinv := new(big.Int).ModInverse(r, fr.Modulus())
	u1 := new(big.Int).Mul(z, rinv)
	u1.Neg(u1)
	u1.Mod(u1, fr.Modulus())
	u2 := new(big.Int).Mul(s, rinv)
	u2.Mod(u2, fr.Modulus())
	var Q secp256k1.G1Jac
	Q.JointScalarMultiplicationBase(P, u1, u2)
	pk.A.FromJacobian(&Q)
	return nil
}

// Bytes returns the binary representation of the private key. The binary representation
// of the private key consists of the concatenation of the binary representation of the
// corresponding public key and the private key scalar encoded in big-endian format.
//
// See also [PublicKey.Bytes].
func (privKey *PrivateKey) Bytes() []byte {
	var res [sizePrivateKey]byte
	pubkBin := privKey.PublicKey.A.RawBytes()
	subtle.ConstantTimeCopy(1, res[:sizePublicKey], pubkBin[:])
	subtle.ConstantTimeCopy(1, res[sizePublicKey:sizePrivateKey], privKey.scalar[:])
	return res[:]
}

// SetBytes sets the private key from the serialized representation obtained
// using [PrivateKey.Bytes].
//
// The length of the input buffer must be at least the size of the private key. It returns an error if:
// * the buffer is too short
// * computing valid point from compressed representation fails
//
// Any excess bytes in the input buffer are ignored. The method returns the number of bytes
// read.
func (privKey *PrivateKey) SetBytes(buf []byte) (int, error) {
	n := 0
	if len(buf) < sizePrivateKey {
		return n, io.ErrShortBuffer
	}
	if _, err := privKey.PublicKey.A.SetBytes(buf[:sizePublicKey]); err != nil {
		return 0, err
	}
	n += sizePublicKey
	subtle.ConstantTimeCopy(1, privKey.scalar[:], buf[sizePublicKey:sizePrivateKey])
	n += sizeFr
	return n, nil
}

// Bytes returns the binary representation of the signature. The binary
// representation is the concatenation of the big-endian encoding of the r and s
// values of the signature, padded to full scalar size.
func (sig *Signature) Bytes() []byte {
	var res [sizeSignature]byte
	subtle.ConstantTimeCopy(1, res[:sizeFr], sig.R[:])
	subtle.ConstantTimeCopy(1, res[sizeFr:], sig.S[:])
	return res[:]
}

// SetBytes sets signature value from the binary representation. The binary
// representation is assumed to be the concatenation of the big-endian encoding
// of the r and s values of the signature, padded to full scalar size (see
// [Signature.Bytes]).
//
// It returns an error if:
// * the buffer is shorter than the expected signature size
// * r is not in the interval [1, r_mod-1] (to avoid malleability)
// * s is not in the interval [1, (r_mod-1)/2] (to avoid malleability)
//
// Any excess bytes in the input buffer are ignored. The method returns the number of bytes
// read.
func (sig *Signature) SetBytes(buf []byte) (int, error) {
	n := 0
	if len(buf) != sizeSignature {
		return n, errWrongSize
	}

	// S, R < R_mod (to avoid malleability)
	frMod := fr.Modulus()
	zero := big.NewInt(0)
	bufBigInt := new(big.Int)
	bufBigInt.SetBytes(buf[:sizeFr])
	if bufBigInt.Cmp(zero) == 0 {
		return 0, errZero
	}
	if bufBigInt.Cmp(frMod) != -1 {
		return 0, errRBiggerThanRMod
	}
	bufBigInt.SetBytes(buf[sizeFr : 2*sizeFr])
	if bufBigInt.Cmp(zero) == 0 {
		return 0, errZero
	}
	bHalfR := new(big.Int)
	bHalfR.Rsh(order, 1)

	if bufBigInt.Cmp(bHalfR) == 1 {
		return 0, errSBiggerThanHalfRMod
	}

	subtle.ConstantTimeCopy(1, sig.R[:], buf[:sizeFr])
	n += sizeFr
	subtle.ConstantTimeCopy(1, sig.S[:], buf[sizeFr:2*sizeFr])
	n += sizeFr
	return n, nil
}
