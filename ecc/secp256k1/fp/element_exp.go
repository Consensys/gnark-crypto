// Copyright 2020-2026 Consensys Software Inc.
// Licensed under the Apache License, Version 2.0. See the LICENSE file for details.

// Code generated by consensys/gnark-crypto DO NOT EDIT

package fp

// ExpBySqrtPp1o4 is equivalent to z.Exp(x, 3fffffffffffffffffffffffffffffffffffffffffffffffffffffffbfffff0c).
// It raises x to the (p+1)/4 power using a shorter addition chain.
//
// uses github.com/mmcloughlin/addchain v0.4.0 to generate a shorter addition chain
func (z *Element) ExpBySqrtPp1o4(x Element) *Element {
	// addition chain:
	//
	//	_10      = 2*1
	//	_11      = 1 + _10
	//	_1100    = _11 << 2
	//	_1111    = _11 + _1100
	//	_11110   = 2*_1111
	//	_11111   = 1 + _11110
	//	_1111100 = _11111 << 2
	//	_1111111 = _11 + _1111100
	//	x11      = _1111111 << 4 + _1111
	//	x22      = x11 << 11 + x11
	//	x27      = x22 << 5 + _11111
	//	x54      = x27 << 27 + x27
	//	x108     = x54 << 54 + x54
	//	x216     = x108 << 108 + x108
	//	x223     = x216 << 7 + _1111111
	//	return     ((x223 << 23 + x22) << 6 + _11) << 2
	//
	// Operations: 253 squares 13 multiplies

	// Allocate Temporaries.
	var (
		t0 = new(Element)
		t1 = new(Element)
		t2 = new(Element)
		t3 = new(Element)
	)

	// var t0,t1,t2,t3 Element
	// Step 1: z = x^0x2
	z.Square(&x)

	// Step 2: z = x^0x3
	z.Mul(&x, z)

	// Step 4: t0 = x^0xc
	t0.Square(z)
	for s := 1; s < 2; s++ {
		t0.Square(t0)
	}

	// Step 5: t0 = x^0xf
	t0.Mul(z, t0)

	// Step 6: t1 = x^0x1e
	t1.Square(t0)

	// Step 7: t2 = x^0x1f
	t2.Mul(&x, t1)

	// Step 9: t1 = x^0x7c
	t1.Square(t2)
	for s := 1; s < 2; s++ {
		t1.Square(t1)
	}

	// Step 10: t1 = x^0x7f
	t1.Mul(z, t1)

	// Step 14: t3 = x^0x7f0
	t3.Square(t1)
	for s := 1; s < 4; s++ {
		t3.Square(t3)
	}

	// Step 15: t0 = x^0x7ff
	t0.Mul(t0, t3)

	// Step 26: t3 = x^0x3ff800
	t3.Square(t0)
	for s := 1; s < 11; s++ {
		t3.Square(t3)
	}

	// Step 27: t0 = x^0x3fffff
	t0.Mul(t0, t3)

	// Step 32: t3 = x^0x7ffffe0
	t3.Square(t0)
	for s := 1; s < 5; s++ {
		t3.Square(t3)
	}

	// Step 33: t2 = x^0x7ffffff
	t2.Mul(t2, t3)

	// Step 60: t3 = x^0x3ffffff8000000
	t3.Square(t2)
	for s := 1; s < 27; s++ {
		t3.Square(t3)
	}

	// Step 61: t2 = x^0x3fffffffffffff
	t2.Mul(t2, t3)

	// Step 115: t3 = x^0xfffffffffffffc0000000000000
	t3.Square(t2)
	for s := 1; s < 54; s++ {
		t3.Square(t3)
	}

	// Step 116: t2 = x^0xfffffffffffffffffffffffffff
	t2.Mul(t2, t3)

	// Step 224: t3 = x^0xfffffffffffffffffffffffffff000000000000000000000000000
	t3.Square(t2)
	for s := 1; s < 108; s++ {
		t3.Square(t3)
	}

	// Step 225: t2 = x^0xffffffffffffffffffffffffffffffffffffffffffffffffffffff
	t2.Mul(t2, t3)

	// Step 232: t2 = x^0x7fffffffffffffffffffffffffffffffffffffffffffffffffffff80
	for s := 0; s < 7; s++ {
		t2.Square(t2)
	}

	// Step 233: t1 = x^0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffff
	t1.Mul(t1, t2)

	// Step 256: t1 = x^0x3fffffffffffffffffffffffffffffffffffffffffffffffffffffff800000
	for s := 0; s < 23; s++ {
		t1.Square(t1)
	}

	// Step 257: t0 = x^0x3fffffffffffffffffffffffffffffffffffffffffffffffffffffffbfffff
	t0.Mul(t0, t1)

	// Step 263: t0 = x^0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc0
	for s := 0; s < 6; s++ {
		t0.Square(t0)
	}

	// Step 264: z = x^0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc3
	z.Mul(z, t0)

	// Step 266: z = x^0x3fffffffffffffffffffffffffffffffffffffffffffffffffffffffbfffff0c
	for s := 0; s < 2; s++ {
		z.Square(z)
	}

	return z
}

// ExpBySqrtPm3o4 is equivalent to z.Exp(x, 3fffffffffffffffffffffffffffffffffffffffffffffffffffffffbfffff0b).
// It raises x to the (p-3)/4 power using a shorter addition chain.
//
// uses github.com/mmcloughlin/addchain v0.4.0 to generate a shorter addition chain
func (z *Element) ExpBySqrtPm3o4(x Element) *Element {
	// addition chain:
	//
	//	_10      = 2*1
	//	_11      = 1 + _10
	//	_1100    = _11 << 2
	//	_1111    = _11 + _1100
	//	_11110   = 2*_1111
	//	_11111   = 1 + _11110
	//	_1111100 = _11111 << 2
	//	_1111111 = _11 + _1111100
	//	x11      = _1111111 << 4 + _1111
	//	x22      = x11 << 11 + x11
	//	x27      = x22 << 5 + _11111
	//	x54      = x27 << 27 + x27
	//	x108     = x54 << 54 + x54
	//	x216     = x108 << 108 + x108
	//	x223     = x216 << 7 + _1111111
	//	i266     = ((x223 << 23 + x22) << 5 + 1) << 3
	//	return     _11 + i266
	//
	// Operations: 253 squares 14 multiplies

	// Allocate Temporaries.
	var (
		t0 = new(Element)
		t1 = new(Element)
		t2 = new(Element)
		t3 = new(Element)
	)

	// var t0,t1,t2,t3 Element
	// Step 1: z = x^0x2
	z.Square(&x)

	// Step 2: z = x^0x3
	z.Mul(&x, z)

	// Step 4: t0 = x^0xc
	t0.Square(z)
	for s := 1; s < 2; s++ {
		t0.Square(t0)
	}

	// Step 5: t0 = x^0xf
	t0.Mul(z, t0)

	// Step 6: t1 = x^0x1e
	t1.Square(t0)

	// Step 7: t2 = x^0x1f
	t2.Mul(&x, t1)

	// Step 9: t1 = x^0x7c
	t1.Square(t2)
	for s := 1; s < 2; s++ {
		t1.Square(t1)
	}

	// Step 10: t1 = x^0x7f
	t1.Mul(z, t1)

	// Step 14: t3 = x^0x7f0
	t3.Square(t1)
	for s := 1; s < 4; s++ {
		t3.Square(t3)
	}

	// Step 15: t0 = x^0x7ff
	t0.Mul(t0, t3)

	// Step 26: t3 = x^0x3ff800
	t3.Square(t0)
	for s := 1; s < 11; s++ {
		t3.Square(t3)
	}

	// Step 27: t0 = x^0x3fffff
	t0.Mul(t0, t3)

	// Step 32: t3 = x^0x7ffffe0
	t3.Square(t0)
	for s := 1; s < 5; s++ {
		t3.Square(t3)
	}

	// Step 33: t2 = x^0x7ffffff
	t2.Mul(t2, t3)

	// Step 60: t3 = x^0x3ffffff8000000
	t3.Square(t2)
	for s := 1; s < 27; s++ {
		t3.Square(t3)
	}

	// Step 61: t2 = x^0x3fffffffffffff
	t2.Mul(t2, t3)

	// Step 115: t3 = x^0xfffffffffffffc0000000000000
	t3.Square(t2)
	for s := 1; s < 54; s++ {
		t3.Square(t3)
	}

	// Step 116: t2 = x^0xfffffffffffffffffffffffffff
	t2.Mul(t2, t3)

	// Step 224: t3 = x^0xfffffffffffffffffffffffffff000000000000000000000000000
	t3.Square(t2)
	for s := 1; s < 108; s++ {
		t3.Square(t3)
	}

	// Step 225: t2 = x^0xffffffffffffffffffffffffffffffffffffffffffffffffffffff
	t2.Mul(t2, t3)

	// Step 232: t2 = x^0x7fffffffffffffffffffffffffffffffffffffffffffffffffffff80
	for s := 0; s < 7; s++ {
		t2.Square(t2)
	}

	// Step 233: t1 = x^0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffff
	t1.Mul(t1, t2)

	// Step 256: t1 = x^0x3fffffffffffffffffffffffffffffffffffffffffffffffffffffff800000
	for s := 0; s < 23; s++ {
		t1.Square(t1)
	}

	// Step 257: t0 = x^0x3fffffffffffffffffffffffffffffffffffffffffffffffffffffffbfffff
	t0.Mul(t0, t1)

	// Step 262: t0 = x^0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffff7ffffe0
	for s := 0; s < 5; s++ {
		t0.Square(t0)
	}

	// Step 263: t0 = x^0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffff7ffffe1
	t0.Mul(&x, t0)

	// Step 266: t0 = x^0x3fffffffffffffffffffffffffffffffffffffffffffffffffffffffbfffff08
	for s := 0; s < 3; s++ {
		t0.Square(t0)
	}

	// Step 267: z = x^0x3fffffffffffffffffffffffffffffffffffffffffffffffffffffffbfffff0b
	z.Mul(z, t0)

	return z
}

// ExpByLegendreExp is equivalent to z.Exp(x, 7fffffffffffffffffffffffffffffffffffffffffffffffffffffff7ffffe17).
//
// uses github.com/mmcloughlin/addchain v0.4.0 to generate a shorter addition chain
func (z *Element) ExpByLegendreExp(x Element) *Element {
	// addition chain:
	//
	//	_10       = 2*1
	//	_100      = 2*_10
	//	_110      = _10 + _100
	//	_111      = 1 + _110
	//	_1110     = 2*_111
	//	_10101    = _111 + _1110
	//	_10111    = _10 + _10101
	//	_101110   = 2*_10111
	//	_10111000 = _101110 << 2
	//	_11100110 = _101110 + _10111000
	//	_11111101 = _10111 + _11100110
	//	x11       = _11111101 << 3 + _10111
	//	x22       = x11 << 11 + x11
	//	i29       = 2*x22
	//	i31       = i29 << 2
	//	i54       = i31 << 22 + i31
	//	i122      = (i54 << 20 + i29) << 46 + i54
	//	x223      = i122 << 110 + i122 + _111
	//	return      (x223 << 23 + x22) << 9 + _10111
	//
	// Operations: 253 squares 15 multiplies

	// Allocate Temporaries.
	var (
		t0 = new(Element)
		t1 = new(Element)
		t2 = new(Element)
		t3 = new(Element)
		t4 = new(Element)
	)

	// var t0,t1,t2,t3,t4 Element
	// Step 1: z = x^0x2
	z.Square(&x)

	// Step 2: t0 = x^0x4
	t0.Square(z)

	// Step 3: t0 = x^0x6
	t0.Mul(z, t0)

	// Step 4: t1 = x^0x7
	t1.Mul(&x, t0)

	// Step 5: t0 = x^0xe
	t0.Square(t1)

	// Step 6: t0 = x^0x15
	t0.Mul(t1, t0)

	// Step 7: z = x^0x17
	z.Mul(z, t0)

	// Step 8: t0 = x^0x2e
	t0.Square(z)

	// Step 10: t2 = x^0xb8
	t2.Square(t0)
	for s := 1; s < 2; s++ {
		t2.Square(t2)
	}

	// Step 11: t0 = x^0xe6
	t0.Mul(t0, t2)

	// Step 12: t0 = x^0xfd
	t0.Mul(z, t0)

	// Step 15: t0 = x^0x7e8
	for s := 0; s < 3; s++ {
		t0.Square(t0)
	}

	// Step 16: t0 = x^0x7ff
	t0.Mul(z, t0)

	// Step 27: t2 = x^0x3ff800
	t2.Square(t0)
	for s := 1; s < 11; s++ {
		t2.Square(t2)
	}

	// Step 28: t0 = x^0x3fffff
	t0.Mul(t0, t2)

	// Step 29: t3 = x^0x7ffffe
	t3.Square(t0)

	// Step 31: t2 = x^0x1fffff8
	t2.Square(t3)
	for s := 1; s < 2; s++ {
		t2.Square(t2)
	}

	// Step 53: t4 = x^0x7ffffe000000
	t4.Square(t2)
	for s := 1; s < 22; s++ {
		t4.Square(t4)
	}

	// Step 54: t2 = x^0x7ffffffffff8
	t2.Mul(t2, t4)

	// Step 74: t4 = x^0x7ffffffffff800000
	t4.Square(t2)
	for s := 1; s < 20; s++ {
		t4.Square(t4)
	}

	// Step 75: t3 = x^0x7fffffffffffffffe
	t3.Mul(t3, t4)

	// Step 121: t3 = x^0x1ffffffffffffffff800000000000
	for s := 0; s < 46; s++ {
		t3.Square(t3)
	}

	// Step 122: t2 = x^0x1fffffffffffffffffffffffffff8
	t2.Mul(t2, t3)

	// Step 232: t3 = x^0x7ffffffffffffffffffffffffffe0000000000000000000000000000
	t3.Square(t2)
	for s := 1; s < 110; s++ {
		t3.Square(t3)
	}

	// Step 233: t2 = x^0x7ffffffffffffffffffffffffffffffffffffffffffffffffffffff8
	t2.Mul(t2, t3)

	// Step 234: t1 = x^0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffff
	t1.Mul(t1, t2)

	// Step 257: t1 = x^0x3fffffffffffffffffffffffffffffffffffffffffffffffffffffff800000
	for s := 0; s < 23; s++ {
		t1.Square(t1)
	}

	// Step 258: t0 = x^0x3fffffffffffffffffffffffffffffffffffffffffffffffffffffffbfffff
	t0.Mul(t0, t1)

	// Step 267: t0 = x^0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffff7ffffe00
	for s := 0; s < 9; s++ {
		t0.Square(t0)
	}

	// Step 268: z = x^0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffff7ffffe17
	z.Mul(z, t0)

	return z
}

// ExpByCbrtQPlus2Div9 is equivalent to z.Exp(x, 1c71c71c71c71c71c71c71c71c71c71c71c71c71c71c71c71c71c71c555554e9).
// It raises x to the (q+2)/9 power using a shorter addition chain.
// This is used when q â‰¡ 7 (mod 9) for efficient cube root computation.
//
// uses github.com/mmcloughlin/addchain v0.4.0 to generate a shorter addition chain
func (z *Element) ExpByCbrtQPlus2Div9(x Element) *Element {
	// addition chain:
	//
	//	_100      = 1 << 2
	//	_1000     = 2*_100
	//	_1001     = 1 + _1000
	//	_1101     = _100 + _1001
	//	_110100   = _1101 << 2
	//	_110101   = 1 + _110100
	//	_1101010  = 2*_110101
	//	_1101011  = 1 + _1101010
	//	_1101111  = _100 + _1101011
	//	_1110010  = _1000 + _1101010
	//	_11100001 = _1101111 + _1110010
	//	i20       = _11100001 << 6 + _110101
	//	i21       = _1101011 + i20
	//	i22       = i20 + i21
	//	i23       = _1110010 + i22
	//	i79       = ((i23 << 18 + i23) << 18 + i23) << 18
	//	i118      = ((i23 + i79) << 18 + i23) << 18 + i23
	//	i174      = ((i118 << 18 + i23) << 18 + i23) << 18
	//	i213      = ((i23 + i174) << 18 + i23) << 18 + i23
	//	i268      = ((i213 << 18 + i23) << 18 + i22) << 17
	//	return      (i23 + i268 + i21) << 5 + _1001
	//
	// Operations: 250 squares 26 multiplies

	// Allocate Temporaries.
	var (
		t0 = new(Element)
		t1 = new(Element)
		t2 = new(Element)
		t3 = new(Element)
		t4 = new(Element)
	)

	// var t0,t1,t2,t3,t4 Element
	// Step 2: t3 = x^0x4
	t3.Square(&x)
	for s := 1; s < 2; s++ {
		t3.Square(t3)
	}

	// Step 3: t1 = x^0x8
	t1.Square(t3)

	// Step 4: z = x^0x9
	z.Mul(&x, t1)

	// Step 5: t0 = x^0xd
	t0.Mul(t3, z)

	// Step 7: t0 = x^0x34
	for s := 0; s < 2; s++ {
		t0.Square(t0)
	}

	// Step 8: t2 = x^0x35
	t2.Mul(&x, t0)

	// Step 9: t4 = x^0x6a
	t4.Square(t2)

	// Step 10: t0 = x^0x6b
	t0.Mul(&x, t4)

	// Step 11: t3 = x^0x6f
	t3.Mul(t3, t0)

	// Step 12: t1 = x^0x72
	t1.Mul(t1, t4)

	// Step 13: t3 = x^0xe1
	t3.Mul(t3, t1)

	// Step 19: t3 = x^0x3840
	for s := 0; s < 6; s++ {
		t3.Square(t3)
	}

	// Step 20: t2 = x^0x3875
	t2.Mul(t2, t3)

	// Step 21: t0 = x^0x38e0
	t0.Mul(t0, t2)

	// Step 22: t2 = x^0x7155
	t2.Mul(t2, t0)

	// Step 23: t1 = x^0x71c7
	t1.Mul(t1, t2)

	// Step 41: t3 = x^0x1c71c0000
	t3.Square(t1)
	for s := 1; s < 18; s++ {
		t3.Square(t3)
	}

	// Step 42: t3 = x^0x1c71c71c7
	t3.Mul(t1, t3)

	// Step 60: t3 = x^0x71c71c71c0000
	for s := 0; s < 18; s++ {
		t3.Square(t3)
	}

	// Step 61: t3 = x^0x71c71c71c71c7
	t3.Mul(t1, t3)

	// Step 79: t3 = x^0x1c71c71c71c71c0000
	for s := 0; s < 18; s++ {
		t3.Square(t3)
	}

	// Step 80: t3 = x^0x1c71c71c71c71c71c7
	t3.Mul(t1, t3)

	// Step 98: t3 = x^0x71c71c71c71c71c71c0000
	for s := 0; s < 18; s++ {
		t3.Square(t3)
	}

	// Step 99: t3 = x^0x71c71c71c71c71c71c71c7
	t3.Mul(t1, t3)

	// Step 117: t3 = x^0x1c71c71c71c71c71c71c71c0000
	for s := 0; s < 18; s++ {
		t3.Square(t3)
	}

	// Step 118: t3 = x^0x1c71c71c71c71c71c71c71c71c7
	t3.Mul(t1, t3)

	// Step 136: t3 = x^0x71c71c71c71c71c71c71c71c71c0000
	for s := 0; s < 18; s++ {
		t3.Square(t3)
	}

	// Step 137: t3 = x^0x71c71c71c71c71c71c71c71c71c71c7
	t3.Mul(t1, t3)

	// Step 155: t3 = x^0x1c71c71c71c71c71c71c71c71c71c71c0000
	for s := 0; s < 18; s++ {
		t3.Square(t3)
	}

	// Step 156: t3 = x^0x1c71c71c71c71c71c71c71c71c71c71c71c7
	t3.Mul(t1, t3)

	// Step 174: t3 = x^0x71c71c71c71c71c71c71c71c71c71c71c71c0000
	for s := 0; s < 18; s++ {
		t3.Square(t3)
	}

	// Step 175: t3 = x^0x71c71c71c71c71c71c71c71c71c71c71c71c71c7
	t3.Mul(t1, t3)

	// Step 193: t3 = x^0x1c71c71c71c71c71c71c71c71c71c71c71c71c71c0000
	for s := 0; s < 18; s++ {
		t3.Square(t3)
	}

	// Step 194: t3 = x^0x1c71c71c71c71c71c71c71c71c71c71c71c71c71c71c7
	t3.Mul(t1, t3)

	// Step 212: t3 = x^0x71c71c71c71c71c71c71c71c71c71c71c71c71c71c71c0000
	for s := 0; s < 18; s++ {
		t3.Square(t3)
	}

	// Step 213: t3 = x^0x71c71c71c71c71c71c71c71c71c71c71c71c71c71c71c71c7
	t3.Mul(t1, t3)

	// Step 231: t3 = x^0x1c71c71c71c71c71c71c71c71c71c71c71c71c71c71c71c71c0000
	for s := 0; s < 18; s++ {
		t3.Square(t3)
	}

	// Step 232: t3 = x^0x1c71c71c71c71c71c71c71c71c71c71c71c71c71c71c71c71c71c7
	t3.Mul(t1, t3)

	// Step 250: t3 = x^0x71c71c71c71c71c71c71c71c71c71c71c71c71c71c71c71c71c71c0000
	for s := 0; s < 18; s++ {
		t3.Square(t3)
	}

	// Step 251: t2 = x^0x71c71c71c71c71c71c71c71c71c71c71c71c71c71c71c71c71c71c7155
	t2.Mul(t2, t3)

	// Step 268: t2 = x^0xe38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e2aa0000
	for s := 0; s < 17; s++ {
		t2.Square(t2)
	}

	// Step 269: t1 = x^0xe38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e2aa71c7
	t1.Mul(t1, t2)

	// Step 270: t0 = x^0xe38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e2aaaaa7
	t0.Mul(t0, t1)

	// Step 275: t0 = x^0x1c71c71c71c71c71c71c71c71c71c71c71c71c71c71c71c71c71c71c555554e0
	for s := 0; s < 5; s++ {
		t0.Square(t0)
	}

	// Step 276: z = x^0x1c71c71c71c71c71c71c71c71c71c71c71c71c71c71c71c71c71c71c555554e9
	z.Mul(z, t0)

	return z
}

// ExpBySxrtExp is equivalent to z.Exp(x, 238e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e36aaaaa23).
// It raises x to the appropriate power for sextic root computation.
// Reference: Lemma 5 of https://eprint.iacr.org/2021/1446.pdf
//
// uses github.com/mmcloughlin/addchain v0.4.0 to generate a shorter addition chain
func (z *Element) ExpBySxrtExp(x Element) *Element {
	// addition chain:
	//
	//	_10       = 2*1
	//	_11       = 1 + _10
	//	_101      = _10 + _11
	//	_110      = 1 + _101
	//	_1100     = 2*_110
	//	_1101     = 1 + _1100
	//	_1111     = _10 + _1101
	//	_10010    = _11 + _1111
	//	_10111    = _101 + _10010
	//	_11100    = _101 + _10111
	//	_110011   = _10111 + _11100
	//	_1000010  = _1111 + _110011
	//	_1011110  = _11100 + _1000010
	//	_10111100 = 2*_1011110
	//	_11111110 = _1000010 + _10111100
	//	i16       = _1101 + _11111110
	//	i30       = (_10111100 + i16) << 12 + _11111110
	//	i33       = 2*(i16 + i30) + 1
	//	i36       = 2*(i30 + i33) + 1
	//	i42       = (i33 + i36) << 4 + _1100
	//	i43       = _110011 + i42
	//	i44       = i42 + i43
	//	i45       = i43 + i44
	//	i46       = i44 + i45
	//	i47       = _10010 + i46
	//	i48       = i45 + i47
	//	i49       = 2*i47
	//	i51       = 2*i48 + 1
	//	i153      = ((i49 << 34 + i51) << 31 + i47) << 35
	//	i222      = ((i51 + i153) << 31 + i47) << 35 + i51
	//	return      (i222 << 31 + i46) << 25 + i36
	//
	// Operations: 245 squares 35 multiplies

	// Allocate Temporaries.
	var (
		t0 = new(Element)
		t1 = new(Element)
		t2 = new(Element)
		t3 = new(Element)
		t4 = new(Element)
	)

	// var t0,t1,t2,t3,t4 Element
	// Step 1: z = x^0x2
	z.Square(&x)

	// Step 2: t1 = x^0x3
	t1.Mul(&x, z)

	// Step 3: t4 = x^0x5
	t4.Mul(z, t1)

	// Step 4: t0 = x^0x6
	t0.Mul(&x, t4)

	// Step 5: t0 = x^0xc
	t0.Square(t0)

	// Step 6: t3 = x^0xd
	t3.Mul(&x, t0)

	// Step 7: z = x^0xf
	z.Mul(z, t3)

	// Step 8: t2 = x^0x12
	t2.Mul(t1, z)

	// Step 9: t1 = x^0x17
	t1.Mul(t4, t2)

	// Step 10: t4 = x^0x1c
	t4.Mul(t4, t1)

	// Step 11: t1 = x^0x33
	t1.Mul(t1, t4)

	// Step 12: z = x^0x42
	z.Mul(z, t1)

	// Step 13: t4 = x^0x5e
	t4.Mul(t4, z)

	// Step 14: t4 = x^0xbc
	t4.Square(t4)

	// Step 15: z = x^0xfe
	z.Mul(z, t4)

	// Step 16: t3 = x^0x10b
	t3.Mul(t3, z)

	// Step 17: t4 = x^0x1c7
	t4.Mul(t4, t3)

	// Step 29: t4 = x^0x1c7000
	for s := 0; s < 12; s++ {
		t4.Square(t4)
	}

	// Step 30: z = x^0x1c70fe
	z.Mul(z, t4)

	// Step 31: t3 = x^0x1c7209
	t3.Mul(t3, z)

	// Step 32: t3 = x^0x38e412
	t3.Square(t3)

	// Step 33: t3 = x^0x38e413
	t3.Mul(&x, t3)

	// Step 34: z = x^0x555511
	z.Mul(z, t3)

	// Step 35: z = x^0xaaaa22
	z.Square(z)

	// Step 36: z = x^0xaaaa23
	z.Mul(&x, z)

	// Step 37: t3 = x^0xe38e36
	t3.Mul(t3, z)

	// Step 41: t3 = x^0xe38e360
	for s := 0; s < 4; s++ {
		t3.Square(t3)
	}

	// Step 42: t0 = x^0xe38e36c
	t0.Mul(t0, t3)

	// Step 43: t1 = x^0xe38e39f
	t1.Mul(t1, t0)

	// Step 44: t0 = x^0x1c71c70b
	t0.Mul(t0, t1)

	// Step 45: t1 = x^0x2aaaaaaa
	t1.Mul(t1, t0)

	// Step 46: t0 = x^0x471c71b5
	t0.Mul(t0, t1)

	// Step 47: t2 = x^0x471c71c7
	t2.Mul(t2, t0)

	// Step 48: t1 = x^0x71c71c71
	t1.Mul(t1, t2)

	// Step 49: t3 = x^0x8e38e38e
	t3.Square(t2)

	// Step 50: t1 = x^0xe38e38e2
	t1.Square(t1)

	// Step 51: t1 = x^0xe38e38e3
	t1.Mul(&x, t1)

	// Step 85: t3 = x^0x238e38e3800000000
	for s := 0; s < 34; s++ {
		t3.Square(t3)
	}

	// Step 86: t3 = x^0x238e38e38e38e38e3
	t3.Mul(t1, t3)

	// Step 117: t3 = x^0x11c71c71c71c71c7180000000
	for s := 0; s < 31; s++ {
		t3.Square(t3)
	}

	// Step 118: t3 = x^0x11c71c71c71c71c71c71c71c7
	t3.Mul(t2, t3)

	// Step 153: t3 = x^0x8e38e38e38e38e38e38e38e3800000000
	for s := 0; s < 35; s++ {
		t3.Square(t3)
	}

	// Step 154: t3 = x^0x8e38e38e38e38e38e38e38e38e38e38e3
	t3.Mul(t1, t3)

	// Step 185: t3 = x^0x471c71c71c71c71c71c71c71c71c71c7180000000
	for s := 0; s < 31; s++ {
		t3.Square(t3)
	}

	// Step 186: t2 = x^0x471c71c71c71c71c71c71c71c71c71c71c71c71c7
	t2.Mul(t2, t3)

	// Step 221: t2 = x^0x238e38e38e38e38e38e38e38e38e38e38e38e38e3800000000
	for s := 0; s < 35; s++ {
		t2.Square(t2)
	}

	// Step 222: t1 = x^0x238e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e3
	t1.Mul(t1, t2)

	// Step 253: t1 = x^0x11c71c71c71c71c71c71c71c71c71c71c71c71c71c71c71c7180000000
	for s := 0; s < 31; s++ {
		t1.Square(t1)
	}

	// Step 254: t0 = x^0x11c71c71c71c71c71c71c71c71c71c71c71c71c71c71c71c71c71c71b5
	t0.Mul(t0, t1)

	// Step 279: t0 = x^0x238e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e36a000000
	for s := 0; s < 25; s++ {
		t0.Square(t0)
	}

	// Step 280: z = x^0x238e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e36aaaaa23
	z.Mul(z, t0)

	return z
}
