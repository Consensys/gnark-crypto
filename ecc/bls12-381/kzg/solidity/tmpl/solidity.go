package tmpl

const SolidityKzg = `// SPDX-License-Identifier: Apache-2.0

// Copyright 2023 Consensys Software Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Code generated by gnark DO NOT EDIT

pragma solidity ^0.8.20;

contract KzgVerifier {

  uint256 private constant R_MOD = 52435875175126190479447740508185965837690552500527637822603658699938581184513;
  uint256 private constant R_MOD_MINUS_ONE = 52435875175126190479447740508185965837690552500527637822603658699938581184512;
  
  {{ range $index, $element := .Vk.G2 }}
  uint256 private constant G2_SRS_{{ $index }}_X_0_MSB = {{ (fpstrMSB $element.X.A1) }};
  uint256 private constant G2_SRS_{{ $index }}_X_0_LSB = {{ (fpstrLSB $element.X.A1) }};
  uint256 private constant G2_SRS_{{ $index }}_X_1_MSB = {{ (fpstrMSB $element.X.A0) }};
  uint256 private constant G2_SRS_{{ $index }}_X_1_LSB = {{ (fpstrLSB $element.X.A0) }};
  uint256 private constant G2_SRS_{{ $index }}_Y_0_MSB = {{ (fpstrMSB $element.Y.A1) }};
  uint256 private constant G2_SRS_{{ $index }}_Y_0_LSB = {{ (fpstrLSB $element.Y.A1) }};
  uint256 private constant G2_SRS_{{ $index }}_Y_1_MSB = {{ (fpstrMSB $element.Y.A0) }};
  uint256 private constant G2_SRS_{{ $index }}_Y_1_LSB = {{ (fpstrLSB $element.Y.A0) }};
  {{ end }}
  uint256 private constant G1_SRS_X_MSB = {{ fpstrMSB .Vk.G1.X }};
  uint256 private constant G1_SRS_X_LSB = {{ fpstrLSB .Vk.G1.X }};
  uint256 private constant G1_SRS_Y_MSB = {{ fpstrMSB .Vk.G1.Y }};
  uint256 private constant G1_SRS_Y_LSB = {{ fpstrLSB .Vk.G1.Y }};
  // uint256 private constant G1_SRS_Y_NEG = {{ neg .Vk.G1.Y }};


  // -------- proofs layout
  uint256 private constant SINGLE_PROOF_POINT = 0x0;
  uint256 private constant SINGLE_PROOF_CLAIMED_VALUE = 0x20;
  uint256 private constant SINGLE_PROOF_COMMITMENT = 0x40;
  uint256 private constant SINGLE_PROOF_QUOTIENT = 0x80;

  // -------- errors
  uint256 private constant ERROR_STRING_ID = 0x08c379a000000000000000000000000000000000000000000000000000000000; // selector for function Error(string)

  // -------- useful constants
  uint256 private constant SIZE_SCALAR_FIELD = 0x20;
  uint256 private constant SIZE_BASE_FIELD = 0x20;
  uint256 private constant SIZE_POINT = 0x40;
  uint256 private constant GAMMA = 0x67616d6d61; // "gamma" in ascii

  // -------- precompiles
  uint8 private constant SHA256 = 0x2;
  uint8 private constant MOD_EXP = 0x5;
  
  uint8 private constant EC_ADD = 0x0b;
  uint8 private constant EC_MSM = 0x0c;
  uint8 private constant EC_PAIR = 0x0f;
    
  /// @notice verifies a batched opening proof at a single point of a list of polynomials.
  /// @dev Reverts if the proof or the public inputs are malformed.
  /// @param batchOpeningProof serialised KZG proof -> [ point || digests || claimed values || proof ], proof is the quotient
  /// @return success true if the proof passes false otherwise
  function BatchVerifySinglePoint(bytes calldata batchOpeningProof) 

  public view returns (bool) {

    bool res;

    assembly {

      let nb_digests := sub(batchOpeningProof.length, SIZE_BASE_FIELD)
      nb_digests := sub(batchOpeningProof.length, SIZE_POINT_SERIALISED)
      let size_scalar_plus_point_serialised := add(SIZE_POINT_SERIALISED, SIZE_SCALAR_FIELD)
      nb_digests := div(nb_digests, size_scalar_plus_point_serialised)

      let free_mem := mload(0x40)
      let gamma := derive_challenge(batchOpeningProof.offset, nb_digests, free_mem)
      fold_proof(batchOpeningProof.offset, nb_digests, gamma, add(free_mem, size_scalar_plus_point_serialised) ,free_mem)
      
      let offset_quotient := add(SIZE_SCALAR_FIELD, mul(nb_digests,size_scalar_plus_point_serialised))
      res := verify(free_mem, batchOpeningProof.offset, add(batchOpeningProof.offset, offset_quotient))

      /// @notice error returned when SHA256 failed
      function error_sha256() {
        let ptError := mload(0x40)
        mstore(ptError, ERROR_STRING_ID) // selector for function Error(string)
        mstore(add(ptError, 0x4), 0x20)
        mstore(add(ptError, 0x24), 0xc)
        mstore(add(ptError, 0x44), "error sha256")
        revert(ptError, 0x64)
      }

      /// Called when an operation on Bn254 fails
      /// @dev for instance when calling EcMul on a point not on Bn254.
      function error_math_op() {
        let ptError := mload(0x40)
        mstore(ptError, ERROR_STRING_ID) // selector for function Error(string)
        mstore(add(ptError, 0x4), 0x20)
        mstore(add(ptError, 0x24), 0x14)
        mstore(add(ptError, 0x44), "error math operation")
        revert(ptError, 0x64)
      }


      /// @notice verifies a folded kzg proof
      /// @param folded_proof pointer to [ -folded_digest || folded_claimed_value ] on 160 bytes.
      /// @param point calldata pointer to the point
      /// @param quotient calldata pointer to the quotient
      function verify(folded_proof, point, quotient)->res_pairing {

        // *folded_proof = - [ folded_digest + [z]quotient - [folded_claimed_values]G ]
        let _mPtr := add(folded_proof, SIZE_POINT_SERIALISED)
        let folded_claimed_value := mload(_mPtr)
        mstore(_mPtr, R_MOD_MINUS_ONE)
        _mPtr := add(_mPtr, SIZE_SCALAR_FIELD)

        calldatacopy(_mPtr, quotient, SIZE_POINT_SERIALISED)
        _mPtr := add(_mPtr, SIZE_POINT_SERIALISED)
        mstore(_mPtr, sub(R_MOD, calldataload(point)))
        _mPtr := add(_mPtr, SIZE_SCALAR_FIELD)

        mstore(_mPtr, G1_SRS_X_MSB)
        _mPtr := add(_mPtr, 0x20)
        mstore(_mPtr, G1_SRS_X_LSB)
        _mPtr := add(_mPtr, 0x20)
         mstore(_mPtr, G1_SRS_Y_MSB)
        _mPtr := add(_mPtr, 0x20)
        mstore(_mPtr, G1_SRS_Y_LSB)
        _mPtr := add(_mPtr, 0x20)
        mstore(_mPtr, folded_claimed_value)
        let msm_op := staticcall(gas(), EC_MSM, folded_proof, mul(3, add(SIZE_SCALAR_FIELD, SIZE_POINT_SERIALISED)), folded_proof, 0x80)
        if iszero(msm_op) {
          error_math_op()
        }

        // check e(- [ f(\alpha) + [z]H(\alpha) - [f(z)]G ], G2).e(H(\alpha)G1, [\alpha]G2)==1
        _mPtr := add(folded_proof, SIZE_POINT_SERIALISED)
        mstore(_mPtr, G2_SRS_0_X_1_MSB)
        mstore(add(_mPtr,0x20), G2_SRS_0_X_1_LSB)
        mstore(add(_mPtr,0x40), G2_SRS_0_X_0_MSB)
        mstore(add(_mPtr,0x60), G2_SRS_0_X_0_LSB)
        mstore(add(_mPtr,0x80), G2_SRS_0_Y_1_MSB)
        mstore(add(_mPtr,0xa0), G2_SRS_0_Y_1_LSB)
        mstore(add(_mPtr,0xc0), G2_SRS_0_Y_0_MSB)
        mstore(add(_mPtr,0xe0), G2_SRS_0_Y_0_LSB)
        calldatacopy(add(_mPtr, 0x100), quotient, SIZE_POINT_SERIALISED)
        mstore(add(_mPtr,0x180), G2_SRS_1_X_1_MSB)
        mstore(add(_mPtr,0x1a0), G2_SRS_1_X_1_LSB)
        mstore(add(_mPtr,0x1c0), G2_SRS_1_X_0_MSB)
        mstore(add(_mPtr,0x1e0), G2_SRS_1_X_0_LSB)
        mstore(add(_mPtr,0x200), G2_SRS_1_Y_1_MSB)
        mstore(add(_mPtr,0x220), G2_SRS_1_Y_1_LSB)
        mstore(add(_mPtr,0x240), G2_SRS_1_Y_0_MSB)
        mstore(add(_mPtr,0x260), G2_SRS_1_Y_0_LSB)
        let pairing_op := staticcall(gas(), EC_PAIR, folded_proof, 0x300, folded_proof, 0x20)
        if iszero(pairing_op) {
          error_math_op()
        }
        res_pairing := mload(folded_proof) 
      }

      /// @notice compute the challenge for kzg 
      /// @param proof calldata pointer to the proof, [ point || digests || claimed values || proof ]
      /// @param nbDigests number of proofs to fold
      /// @param _gamma challenge for folding the proofs
      /// @param mPtr free memory
      /// @param dst pointer where the result is stored. The result is [-folded_digests, folded_claimed_values]
      function fold_proof(proof, nbDigests, _gamma, mPtr, dst) {

        // compute [c,γ,γ²,..,γⁿ⁻¹]/
        // mPtr will store [digests_0, 1, digest_1, γ, .., digest_{n-1}, γⁿ⁻¹]
        let acc := 1
        let _mPtr := mPtr
        let tmp
        let cur_claimed_value := add(proof, add(SIZE_SCALAR_FIELD, mul(SIZE_POINT_SERIALISED, nbDigests)))
        let cur_digest := add(proof, SIZE_SCALAR_FIELD)
        let folded_claimed_values := 0
        let size_msm
        for {let i := 0} lt(i, nbDigests) {i:=add(i,1)} {
          
          tmp := mulmod(acc, calldataload(cur_claimed_value), R_MOD)
          folded_claimed_values := addmod(folded_claimed_values, tmp, R_MOD)
          
          // _mPtr <- digest_{i} || γ^{i}
          calldatacopy(_mPtr, cur_digest, SIZE_POINT_SERIALISED)
          _mPtr := add(_mPtr, SIZE_POINT_SERIALISED)      
          mstore(_mPtr, acc)
          _mPtr := add(_mPtr, SIZE_SCALAR_FIELD)
          
          cur_claimed_value := add(cur_claimed_value, SIZE_SCALAR_FIELD)
          cur_digest := add(cur_digest, SIZE_POINT_SERIALISED)

          // acc = γ^{i}
          acc := mulmod(acc, _gamma, R_MOD)

          size_msm := add(size_msm, add(SIZE_POINT_SERIALISED, SIZE_SCALAR_FIELD))
        }
        mstore(add(dst, SIZE_POINT_SERIALISED), folded_claimed_values)

        // compute the folded digest
        let msm_op := staticcall(gas(), EC_MSM, mPtr, size_msm, dst, 0x80)
        if iszero(msm_op) {
          error_math_op()
        }

      }

      /// @notice verify the folded proof
      /// @param proof calldata pointer to the proof
      /// @param nbDigests number of digests
      /// @param mPtr free memory
      function derive_challenge(proof, nbDigests, mPtr)->_gamma {

        let offset_proof
        let total_size_data

        // load gamma
        mstore(mPtr, GAMMA)
        let _mPtr := add(mPtr, 0x20)

        // load the point
        mstore(_mPtr, calldataload(proof))
        total_size_data := SIZE_SCALAR_FIELD
        offset_proof := SIZE_SCALAR_FIELD

        // load the digests. Carefull: the elements in the base field are prepended with 16 bytes
        // set to zero.
        // let size_data :=  mul(nbDigests, SIZE_POINT)
        for {let i:=0} lt(i, nbDigests) {i:=add(i,1)} {
          _gamma := calldataload(add(proof, offset_proof))

          // x coordinate
          offset_proof := add(offset_proof, 0x10) // skip the first 16 bytes
          calldatacopy(add(_mPtr, total_size_data), add(proof, offset_proof), SIZE_BASE_FIELD)
          total_size_data := add(total_size_data, SIZE_BASE_FIELD)
          offset_proof := add(offset_proof, SIZE_BASE_FIELD)

          // y coordinate
          offset_proof := add(offset_proof, 0x10) // skip the first 16 bytes
          calldatacopy(add(_mPtr, total_size_data), add(proof, offset_proof), SIZE_BASE_FIELD)
          total_size_data := add(total_size_data, SIZE_BASE_FIELD)
          offset_proof := add(offset_proof, SIZE_BASE_FIELD)
        }

        // load the claimed values
        let size_data := mul(nbDigests, SIZE_SCALAR_FIELD)
        calldatacopy(add(_mPtr, total_size_data), add(proof, offset_proof), size_data)
        total_size_data := add(total_size_data, size_data)
        offset_proof := add(offset_proof, size_data)

        // hash
        total_size_data := add(total_size_data, 5) // add 5 for the challenge's name, "gamma"
        let check_staticcall := staticcall(gas(), SHA256, add(mPtr,0x1b), total_size_data, mPtr, 0x20)
        if iszero(check_staticcall) {
          error_sha256()
        }

        // reduce
        _gamma := mod(mload(mPtr), R_MOD)

      }
    }
    return res;
  
  }
}
`
