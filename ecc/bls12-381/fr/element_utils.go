// Copyright 2020-2025 Consensys Software Inc.
// Licensed under the Apache License, Version 2.0. See the LICENSE file for details.

package fr

// SqrtAndInverse computes both the square root and the inverse of x in E2 by
// doing a single exponentiation to the power (p-2^e-1)/2^(e+1) where e is the
// field 2-adicity.
func (z *Element) SqrtAndInverse(x, inv *Element) (*Element, *Element) {
	// q ≡ 1 (mod 4)
	// see modSqrtTonelliShanks in math/big/int.go

	var y, b, t, w Element
	r := uint64(32)

	// w = x^((s-1)/2))
	w.expBySqrtExp(*x)

	inv.expByC1(x)

	y.Square(&w).
		Square(&y).
		Mul(&y, x)

	for i := uint64(0); i < r-1; i++ {
		y.Square(&y)
	}
	inv.Mul(inv, &y)

	// y = x^((s+1)/2)) = w * x
	y.Mul(x, &w)

	// b = xˢ = w * w * x = y * x
	b.Mul(&w, &y)

	// g = nonResidue ^ s
	var g = Element{
		11289237133041595516,
		2081200955273736677,
		967625415375836421,
		4543825880697944938,
	}

	// compute legendre symbol
	// t = x^((q-1)/2) = r-1 squaring of xˢ
	t = b
	for i := uint64(0); i < r-1; i++ {
		t.Square(&t)
	}
	if t.IsZero() {
		return z.SetZero(), inv
	}
	if !t.IsOne() {
		// t != 1, we don't have a square root
		return nil, inv
	}
	for {
		var m uint64
		t = b

		// for t != 1
		for !t.IsOne() {
			t.Square(&t)
			m++
		}

		if m == 0 {
			return z.Set(&y), inv
		}
		// t = g^(2^(r-m-1)) (mod q)
		ge := int(r - m - 1)
		t = g
		for ge > 0 {
			t.Square(&t)
			ge--
		}

		g.Square(&t)
		y.Mul(&y, &t)
		b.Mul(&b, &g)
		r = m
	}
}

// expByC1 set z to x^c1 and return z
// where c1 = 2^(e-1)-1 and e = 32 is the 2-adicity of Fp.
func (z *Element) expByC1(x *Element) *Element {
	// addition chain:
	//
	//	_10      = 2*1
	//	_11      = 1 + _10
	//	_110     = 2*_11
	//	_111     = 1 + _110
	//	_111000  = _111 << 3
	//	_111111  = _111 + _111000
	//	_1111110 = 2*_111111
	//	_1111111 = 1 + _1111110
	//	x12      = _1111110 << 5 + _111111
	//	x24      = x12 << 12 + x12
	//	return     x24 << 7 + _1111111
	//
	// Operations: 30 squares 7 multiplies
	//
	// Generated by github.com/mmcloughlin/addchain v0.4.0.

	// Allocate Temporaries.
	var (
		t0 = new(Element)
		t1 = new(Element)
	)

	// Step 1: z = x^0x2
	z.Square(x)

	// Step 2: z = x^0x3
	z.Mul(x, z)

	// Step 3: z = x^0x6
	z.Square(z)

	// Step 4: z = x^0x7
	z.Mul(x, z)

	// Step 7: t0 = x^0x38
	t0.Square(z)
	for s := 1; s < 3; s++ {
		t0.Square(t0)
	}

	// Step 8: t0 = x^0x3f
	t0.Mul(z, t0)

	// Step 9: t1 = x^0x7e
	t1.Square(t0)

	// Step 10: z = x^0x7f
	z.Mul(x, t1)

	// Step 15: t1 = x^0xfc0
	for s := 0; s < 5; s++ {
		t1.Square(t1)
	}

	// Step 16: t0 = x^0xfff
	t0.Mul(t0, t1)

	// Step 28: t1 = x^0xfff000
	t1.Square(t0)
	for s := 1; s < 12; s++ {
		t1.Square(t1)
	}

	// Step 29: t0 = x^0xffffff
	t0.Mul(t0, t1)

	// Step 36: t0 = x^0x7fffff80
	for s := 0; s < 7; s++ {
		t0.Square(t0)
	}

	// Step 37: z = x^0x7fffffff
	z.Mul(z, t0)

	return z
}
