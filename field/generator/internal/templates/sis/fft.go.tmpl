import (
	"{{ .FieldPackagePath }}"
	"math/big"
)

// precomputeTwiddlesCoset precomputes twiddlesCoset from twiddles and coset table
// it then return all elements in the correct order for the unrolled FFT.
func precomputeTwiddlesCoset(generator, shifter {{ .FF }}.Element) []{{ .FF }}.Element {
	toReturn := make([]{{ .FF }}.Element,  511)
	var r, s {{ .FF }}.Element
	e := new(big.Int)
	{{ $n := 512}}
	{{ $m := div $n 2}}
	{{ $split := 1}}
	{{ $split = div $split 1}}
	{{ $j := 0}}
	{{- range $step := reverse (iterate 0 9)}} 
		s = shifter
		for k:=0; k <{{$step}};k++ {
			s.Square(&s)
		}
		
		{{- $offset := 0}}
		{{- range $s := iterate 0 $split}}
			{{- $exp := bitReverse $split $s}}
			{{- if eq $exp 0}}
				toReturn[{{$j}}] = s
			{{- else}}
				{{- if eq $step 0}}
				r.Exp(generator, e.SetUint64({{$exp}}))
				{{- else}}
				r.Exp(generator, e.SetUint64({{mul (shl 1 $step) $exp}}))
				{{- end}}
				toReturn[{{$j}}].Mul(&r, &s)

			{{- end}}
			{{- $j = add $j 1}}
		{{- end}}

		{{- $split = mul $split 2}}
	{{- end}}
	return toReturn
}

func fft512(a, twiddles {{.FF}}.Vector) {
	{{$nbStages := 9}}
	{{$nbSplits := 1}}
	{{$split := 512}}
	{{$m := shr $split 1 }}

	{{- range $level := iterate 0 $nbStages}}
		//
		// stage {{ $level }}
		//
		{{- if ne $level 0}}
			{{- range $s := iterate 0 $nbSplits}}
				{{- $j := add (sub $nbSplits 1) $s}}
				{{$startLoop := add (mul $s $split) $m}}
				// split {{$s}}: a[{{sub $startLoop $m}}:{{add $startLoop $m}}] with twiddles[{{$j}}]
				{{- if or (eq $level 0) (and (eq $level 1) (eq $s 0))}}
				
				{{- else}}
				for i := {{sub $startLoop $m}}; i < {{$startLoop}}; i++ {
					a[i+{{$m}}].Mul(&a[i+{{$m}}], &twiddles[{{$j}}])
					koalabear.Butterfly(&a[i], &a[i+{{$m}}])
				}
				{{- end}}
			{{- end}}
		{{- end}}
		{{- $split = shr $split 1}}
		{{- $nbSplits = mul $nbSplits 2}}
		{{$m = shr $split 1}}
	{{- end}}


	// for level := 0; level < nbStages; level++ {
	// 	for s := 0; s < nbSplits; s++ {
	// 		for k := 0; k < split/2; k++ {
	// 			i := s*split+split/2+k
	// 			j := nbSplits-1+s

	// 			a[i].Mul(&a[i], &twiddles[j])
	// 		}
	// 	}

	// 	for s := 0; s < nbSplits; s++ {
	// 		for k := 0; k < split/2; k++ {
	// 			i := s*split+k
	// 			j := s*split+split/2+k
	// 			koalabear.Butterfly(&a[i], &a[j])
	// 		}
	// 	}

	// 	split /= 2
	// 	nbSplits *= 2
	// }
}