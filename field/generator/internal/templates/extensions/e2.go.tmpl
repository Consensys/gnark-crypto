import (
	"math/big"

	fr "{{ .FieldPackagePath }}"
)

// E2 is a degree two finite field extension of fr.Element
type E2 struct {
	A0, A1 fr.Element
}

// Equal returns true if z equals x, false otherwise
func (z *E2) Equal(x *E2) bool {
	return z.A0.Equal(&x.A0) && z.A1.Equal(&x.A1)
}

// Cmp compares (lexicographic order) z and x and returns:
//
//	-1 if z <  x
//	 0 if z == x
//	+1 if z >  x
func (z *E2) Cmp(x *E2) int {
	if a1 := z.A1.Cmp(&x.A1); a1 != 0 {
		return a1
	}
	return z.A0.Cmp(&x.A0)
}

// LexicographicallyLargest returns true if this element is strictly lexicographically
// larger than its negation, false otherwise
func (z *E2) LexicographicallyLargest() bool {
	// adapted from github.com/zkcrypto/bls12_381
	if z.A1.IsZero() {
		return z.A0.LexicographicallyLargest()
	}
	return z.A1.LexicographicallyLargest()
}

// SetString sets a E2 element from strings
func (z *E2) SetString(s1, s2 string) *E2 {
	z.A0.SetString(s1)
	z.A1.SetString(s2)
	return z
}

// SetZero sets an E2 elmt to zero
func (z *E2) SetZero() *E2 {
	z.A0.SetZero()
	z.A1.SetZero()
	return z
}

// Set sets an E2 from x
func (z *E2) Set(x *E2) *E2 {
	z.A0 = x.A0
	z.A1 = x.A1
	return z
}

// SetOne sets z to 1 and returns z
func (z *E2) SetOne() *E2 {
	z.A0.SetOne()
	z.A1.SetZero()
	return z
}

// SetRandom sets a0 and a1 to random values
func (z *E2) SetRandom() (*E2, error) {
	if _, err := z.A0.SetRandom(); err != nil {
		return nil, err
	}
	if _, err := z.A1.SetRandom(); err != nil {
		return nil, err
	}
	return z, nil
}

// MustSetRandom sets a0 and a1 to random values.
// It panics if reading from crypto/rand fails.
func (z *E2) MustSetRandom() *E2 {
	if _, err := z.A0.SetRandom(); err != nil {
		panic(err)
	}
	return z
}

// IsZero returns true if z is zero, false otherwise
func (z *E2) IsZero() bool {
	return z.A0.IsZero() && z.A1.IsZero()
}

// IsOne returns true if z is one, false otherwise
func (z *E2) IsOne() bool {
	return z.A0.IsOne() && z.A1.IsZero()
}

// Add adds two elements of E2
func (z *E2) Add(x, y *E2) *E2 {
	z.A0.Add(&x.A0, &y.A0)
	z.A1.Add(&x.A1, &y.A1)
	return z
}

// Sub subtracts two elements of E2
func (z *E2) Sub(x, y *E2) *E2 {
	z.A0.Sub(&x.A0, &y.A0)
	z.A1.Sub(&x.A1, &y.A1)
	return z
}

// Double doubles an E2 element
func (z *E2) Double(x *E2) *E2 {
	z.A0.Double(&x.A0)
	z.A1.Double(&x.A1)
	return z
}

// Neg negates an E2 element
func (z *E2) Neg(x *E2) *E2 {
	z.A0.Neg(&x.A0)
	z.A1.Neg(&x.A1)
	return z
}

// String implements Stringer interface for fancy printing
func (z *E2) String() string {
	return z.A0.String() + "+" + z.A1.String() + "*u"
}

// MulByElement multiplies an element in E2 by an element in fr
func (z *E2) MulByElement(x *E2, y *fr.Element) *E2 {
	z.A0.Mul(&x.A0, y)
	z.A1.Mul(&x.A1, y)
	return z
}

// Conjugate conjugates an element in E2
func (z *E2) Conjugate(x *E2) *E2 {
	z.A0 = x.A0
	z.A1.Neg(&x.A1)
	return z
}

// Halve sets z to z / 2
func (z *E2) Halve() {
	z.A0.Halve()
	z.A1.Halve()
}

// Legendre returns the Legendre symbol of z
func (z *E2) Legendre() int {
	var n fr.Element
	z.norm(&n)
	return n.Legendre()
}

// Exp sets z=xᵏ (mod q²) and returns it
func (z *E2) Exp(x E2, k *big.Int) *E2 {
	if k.IsUint64() && k.Uint64() == 0 {
		return z.SetOne()
	}

	e := k
	if k.Sign() == -1 {
		// negative k, we invert
		// if k < 0: xᵏ (mod q²) == (x⁻¹)ᵏ (mod q²)
		x.Inverse(&x)

		// we negate k in a temp big.Int since
		// Int.Bit(_) of k and -k is different
		e = bigIntPool.Get().(*big.Int)
		defer bigIntPool.Put(e)
		e.Neg(k)
	}

	z.SetOne()
	b := e.Bytes()
	for i := 0; i < len(b); i++ {
		w := b[i]
		for j := 0; j < 8; j++ {
			z.Square(z)
			if (w & (0b10000000 >> j)) != 0 {
				z.Mul(z, &x)
			}
		}
	}

	return z
}

// Sqrt sets z to the square root of and returns z
// The function does not test whether the square root
// exists or not, it's up to the caller to call
// Legendre beforehand.
//
// "A note on the calculation of some functions in
// finite fields: Tricks of the Trade" by Michael Scott
// https://eprint.iacr.org/2020/1497.pdf (Sec. 6.3)
func (z *E2) Sqrt(x *E2) *E2 {
	var x0, x1 fr.Element
	x.norm(&x0)
	x0.Sqrt(&x0)
	x1.Add(&x.A0, &x0).Halve()
	if x1.Legendre() != 1 {
		x1.Sub(&x.A0, &x0).Halve()
	}
	x1.Sqrt(&x1)
	z.A0.Set(&x1)
	x1.Double(&x1)
	z.A1.Div(&x.A1, &x1)

	return z
}

// BatchInvertE2 returns a new slice with every element in a inverted.
// It uses Montgomery batch inversion trick.
//
// if a[i] == 0, returns result[i] = a[i]
func BatchInvertE2(a []E2) []E2 {
	res := make([]E2, len(a))
	if len(a) == 0 {
		return res
	}

	zeroes := make([]bool, len(a))
	var accumulator E2
	accumulator.SetOne()

	for i := 0; i < len(a); i++ {
		if a[i].IsZero() {
			zeroes[i] = true
			continue
		}
		res[i].Set(&accumulator)
		accumulator.Mul(&accumulator, &a[i])
	}

	accumulator.Inverse(&accumulator)

	for i := len(a) - 1; i >= 0; i-- {
		if zeroes[i] {
			continue
		}
		res[i].Mul(&res[i], &accumulator)
		accumulator.Mul(&accumulator, &a[i])
	}

	return res
}

// Select is conditional move.
// If cond = 0, it sets z to caseZ and returns it. otherwise caseNz.
func (z *E2) Select(cond int, caseZ *E2, caseNz *E2) *E2 {
	//Might be able to save a nanosecond or two by an aggregate implementation

	z.A0.Select(cond, &caseZ.A0, &caseNz.A0)
	z.A1.Select(cond, &caseZ.A1, &caseNz.A1)

	return z
}

// Div divides an element in E2 by an element in E2
func (z *E2) Div(x *E2, y *E2) *E2 {
	var r E2
	r.Inverse(y).Mul(x, &r)
	return z.Set(&r)
}

{{- if eq .FF "babybear"}}
// MulBy11 x *= 11 (mod q)
func MulBy11(x *fr.Element) {
	var y fr.Element
	y.SetUint64(11)
	x.Mul(x, &y)
}
{{- else if eq .FF "goldilocks"}}
// MulBy7 x *= 7 (mod q)
func MulBy7(x *fr.Element) {
	var y fr.Element
	y.SetUint64(7)
	x.Mul(x, &y)
}
{{- end}}

// Mul sets z to the E2-product of x,y, returns z
func (z *E2) Mul(x, y *E2) *E2 {
	var a, b, c, d fr.Element
	a.Add(&x.A0, &x.A1)
	b.Add(&y.A0, &y.A1)
	d.Mul(&x.A0, &y.A0)
	c.Mul(&x.A1, &y.A1)
	a.Mul(&a, &b)

    {{- if eq .FF "koalabear"}}
		d.Add(&d, &c)
		a.Sub(&a, &d)
		d.Add(&d, &c).Add(&d, &c)
		z.A0 = d
		z.A1 = a
    {{- else if eq .FF "babybear"}}
		z.A1.Sub(&a, &d).Sub(&z.A1, &c)
		MulBy11(&c)
		z.A0.Add(&d, &c)
    {{- else if eq .FF "goldilocks"}}
		z.A1.Sub(&a, &d).Sub(&z.A1, &c)
		MulBy7(&c)
		z.A0.Add(&d, &c)
    {{- end}}

	return z
}

// Square sets z to the E2-product of x,x returns z
func (z *E2) Square(x *E2) *E2 {
	var a, b, c fr.Element
	a.Mul(&x.A0, &x.A1)
	c.Square(&x.A0)
	b.Square(&x.A1)
    {{- if eq .FF "koalabear"}}
	fr.MulBy3(&b)
    {{- else if eq .FF "babybear"}}
	MulBy11(&b)
    {{- else if eq .FF "goldilocks"}}
	MulBy7(&b)
    {{- end}}
	z.A0.Add(&c, &b)
	z.A1.Double(&a)
	return z
}

// MulByQuadraticNonResidue multiplies a E2 by u=(0,1)
func (z *E2) MulByQuadraticNonResidue(x *E2) *E2 {
	z.A0, z.A1 = x.A1, x.A0
    {{- if eq .FF "koalabear"}}
	fr.MulBy3(&z.A0)
    {{- else if eq .FF "babybear"}}
	MulBy11(&z.A0)
    {{- else if eq .FF "goldilocks"}}
	MulBy7(&z.A0)
    {{- end}}
	return z
}

{{- if or (eq .FF "koalabear") (eq .FF "babybear")}}
// MulByCubicNonResidue multiplies a E2 by 1+u=(1,1)
func (z *E2) MulByCubicNonResidue(x *E2) *E2 {
	var z0, z1 fr.Element
	z1.Add(&x.A0, &x.A1)
    {{- if eq .FF "koalabear"}}
	z0.Double(&x.A1)
    {{- else if eq .FF "babybear"}}
	z0.Set(&x.A1)
    fr.MulBy3(&z0)
    fr.MulBy3(&z0)
    z0.Add(&z0, &x.A1)
    {{- end}}
    z0.Add(&z0, &z1)
	z.A0 = z0
	z.A1 = z1
	return z
}
{{- end}}

// Inverse sets z to the E2-inverse of x, returns z
func (z *E2) Inverse(x *E2) *E2 {
	// Algorithm 8 from https://eprint.iacr.org/2010/354.pdf
	var t0, t1, tmp fr.Element
	a := &x.A0 // creating the buffers a, b is faster than querying &x.A0, &x.A1 in the functions call below
	b := &x.A1
	t0.Square(a)
	t1.Square(b)
	tmp.Set(&t1)
    {{- if eq .FF "koalabear"}}
	fr.MulBy3(&tmp)
    {{- else if eq .FF "babybear"}}
	MulBy11(&tmp)
    {{- else if eq .FF "goldilocks"}}
	MulBy7(&tmp)
    {{- end}}
	t0.Sub(&t0, &tmp)
	t1.Inverse(&t0)
	z.A0.Mul(a, &t1)
	z.A1.Mul(b, &t1).Neg(&z.A1)

	return z
}

// norm sets x to the norm of z
func (z *E2) norm(x *fr.Element) {
	var tmp fr.Element
	x.Square(&z.A1)
	tmp.Set(x)
    {{- if eq .FF "koalabear"}}
	fr.MulBy3(&tmp)
    {{- else if eq .FF "babybear"}}
	MulBy11(&tmp)
    {{- else if eq .FF "goldilocks"}}
	MulBy7(&tmp)
    {{- end}}
	x.Square(&z.A0).Sub(x, &tmp)
}
