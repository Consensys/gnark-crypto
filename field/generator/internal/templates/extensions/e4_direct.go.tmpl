import fr "{{ .FieldPackagePath }}"

// E4D is a degree 4 finite field extension of fr with v^4 = {{- if .IsKoalaBear }} 3{{- else }} 11{{- end }}.
type E4D struct {
	A0, A1, A2, A3 fr.Element
}

// Equal returns true if z equals x, false otherwise.
func (z *E4D) Equal(x *E4D) bool {
	return z.A0.Equal(&x.A0) &&
		z.A1.Equal(&x.A1) &&
		z.A2.Equal(&x.A2) &&
		z.A3.Equal(&x.A3)
}

// String puts E4D elmt in string form.
func (z *E4D) String() string {
	return (z.A0.String() + "+(" + z.A1.String() + ")*v+(" + z.A2.String() + ")*v**2+(" + z.A3.String() + ")*v**3")
}

// SetString sets an E4D elmt from string.
func (z *E4D) SetString(s1, s2, s3, s4 string) *E4D {
	z.A0.SetString(s1)
	z.A1.SetString(s2)
	z.A2.SetString(s3)
	z.A3.SetString(s4)
	return z
}

// Set copies x into z and returns z.
func (z *E4D) Set(x *E4D) *E4D {
	*z = *x
	return z
}

// SetZero sets z to 0 and returns z.
func (z *E4D) SetZero() *E4D {
	z.A0.SetZero()
	z.A1.SetZero()
	z.A2.SetZero()
	z.A3.SetZero()
	return z
}

// SetOne sets z to 1 and returns z.
func (z *E4D) SetOne() *E4D {
	z.A0.SetOne()
	z.A1.SetZero()
	z.A2.SetZero()
	z.A3.SetZero()
	return z
}

// Add sets z=x+y in E4D and returns z.
func (z *E4D) Add(x, y *E4D) *E4D {
	z.A0.Add(&x.A0, &y.A0)
	z.A1.Add(&x.A1, &y.A1)
	z.A2.Add(&x.A2, &y.A2)
	z.A3.Add(&x.A3, &y.A3)
	return z
}

// Sub sets z to x-y and returns z.
func (z *E4D) Sub(x, y *E4D) *E4D {
	z.A0.Sub(&x.A0, &y.A0)
	z.A1.Sub(&x.A1, &y.A1)
	z.A2.Sub(&x.A2, &y.A2)
	z.A3.Sub(&x.A3, &y.A3)
	return z
}

// Double sets z=2*x and returns z.
func (z *E4D) Double(x *E4D) *E4D {
	z.A0.Double(&x.A0)
	z.A1.Double(&x.A1)
	z.A2.Double(&x.A2)
	z.A3.Double(&x.A3)
	return z
}

// Neg negates an E4D element.
func (z *E4D) Neg(x *E4D) *E4D {
	z.A0.Neg(&x.A0)
	z.A1.Neg(&x.A1)
	z.A2.Neg(&x.A2)
	z.A3.Neg(&x.A3)
	return z
}

// SetRandom used only in tests.
func (z *E4D) SetRandom() (*E4D, error) {
	if _, err := z.A0.SetRandom(); err != nil {
		return nil, err
	}
	if _, err := z.A1.SetRandom(); err != nil {
		return nil, err
	}
	if _, err := z.A2.SetRandom(); err != nil {
		return nil, err
	}
	if _, err := z.A3.SetRandom(); err != nil {
		return nil, err
	}
	return z, nil
}

// MustSetRandom sets z to a random value.
// It panics if reading from crypto/rand fails.
func (z *E4D) MustSetRandom() *E4D {
	if _, err := z.SetRandom(); err != nil {
		panic(err)
	}
	return z
}

// IsZero returns true if z is zero, false otherwise.
func (z *E4D) IsZero() bool {
	return z.A0.IsZero() &&
		z.A1.IsZero() &&
		z.A2.IsZero() &&
		z.A3.IsZero()
}

// IsOne returns true if z is one, false otherwise.
func (z *E4D) IsOne() bool {
	return z.A0.IsOne() &&
		z.A1.IsZero() &&
		z.A2.IsZero() &&
		z.A3.IsZero()
}

{{- if .IsKoalaBear }}

// Mul sets z=x*y in E4D and returns z.
func (z *E4D) Mul(x, y *E4D) *E4D {
	// Unpack elements to uint64 for accumulation
	a0 := uint64(x.A0[0])
	a1 := uint64(x.A1[0])
	a2 := uint64(x.A2[0])
	a3 := uint64(x.A3[0])

	b0 := uint64(y.A0[0])
	b1 := uint64(y.A1[0])
	b2 := uint64(y.A2[0])
	b3 := uint64(y.A3[0])

	// d0 = a0*b0
	d0 := a0 * b0
	r0 := uint64(montReduce(d0))

	// d1 = a0*b1 + a1*b0
	d1 := a0*b1 + a1*b0
	r1 := uint64(montReduce(d1))

	// d2 = a0*b2 + a1*b1 + a2*b0
	d2_a := a0*b2 + a1*b1
	d2_b := a2 * b0
	r2 := uint64(montReduce(d2_a)) + uint64(montReduce(d2_b))

	// d3 = a0*b3 + a1*b2 + a2*b1 + a3*b0
	d3_a := a0*b3 + a1*b2
	d3_b := a2*b1 + a3*b0
	r3 := uint64(montReduce(d3_a)) + uint64(montReduce(d3_b))

	// d4 = a1*b3 + a2*b2 + a3*b1
	d4_a := a1*b3 + a2*b2
	d4_b := a3 * b1
	r4 := uint64(montReduce(d4_a)) + uint64(montReduce(d4_b))

	// d5 = a2*b3 + a3*b2
	d5 := a2*b3 + a3*b2
	r5 := uint64(montReduce(d5))

	// d6 = a3*b3
	d6 := a3 * b3
	r6 := uint64(montReduce(d6))

	// c0 = r0 + 3*r4
	z.A0[0] = reduceSmall(r0 + 3*r4)

	// c1 = r1 + 3*r5
	z.A1[0] = reduceSmall(r1 + 3*r5)

	// c2 = r2 + 3*r6
	z.A2[0] = reduceSmall(r2 + 3*r6)

	// c3 = r3
	z.A3[0] = reduceSmall(r3)

	return z
}

func montReduce(v uint64) uint32 {
	m := uint32(v) * qInvNeg
	t := uint32((v + uint64(m)*uint64(q)) >> 32)
	if t >= q {
		t -= q
	}
	return t
}

func reduceSmall(z uint64) uint32 {
	return uint32(z % uint64(q))
}
{{- else}}



// Mul sets z=x*y in E4D and returns z.
func (z *E4D) Mul(x, y *E4D) *E4D {
	return z.mulNaive(x, y)
}

// mulNaive is the schoolbook multiplication followed by reduction.
func (z *E4D) mulNaive(a, b *E4D) *E4D {
	var d [7]fr.Element
	var t fr.Element

	// degree 0
	d[0].Mul(&a.A0, &b.A0)

	// degree 1
	d[1].Mul(&a.A0, &b.A1)
	t.Mul(&a.A1, &b.A0)
	d[1].Add(&d[1], &t)

	// degree 2
	d[2].Mul(&a.A0, &b.A2)
	t.Mul(&a.A1, &b.A1)
	d[2].Add(&d[2], &t)
	t.Mul(&a.A2, &b.A0)
	d[2].Add(&d[2], &t)

	// degree 3
	d[3].Mul(&a.A0, &b.A3)
	t.Mul(&a.A1, &b.A2)
	d[3].Add(&d[3], &t)
	t.Mul(&a.A2, &b.A1)
	d[3].Add(&d[3], &t)
	t.Mul(&a.A3, &b.A0)
	d[3].Add(&d[3], &t)

	// degree 4
	d[4].Mul(&a.A1, &b.A3)
	t.Mul(&a.A2, &b.A2)
	d[4].Add(&d[4], &t)
	t.Mul(&a.A3, &b.A1)
	d[4].Add(&d[4], &t)

	// degree 5
	d[5].Mul(&a.A2, &b.A3)
	t.Mul(&a.A3, &b.A2)
	d[5].Add(&d[5], &t)

	// degree 6
	d[6].Mul(&a.A3, &b.A3)

	{{- if .IsKoalaBear }}
	// Reduce using v^4 = 3.
	var t3 fr.Element
	t3.Set(&d[4])
	fr.MulBy3(&t3)
	d[0].Add(&d[0], &t3)

	t3.Set(&d[5])
	fr.MulBy3(&t3)
	d[1].Add(&d[1], &t3)

	t3.Set(&d[6])
	fr.MulBy3(&t3)
	d[2].Add(&d[2], &t3)
	{{- else }}
	// Reduce using v^4 = 11.
	var t11 fr.Element
	t11.Set(&d[4])
	MulBy11(&t11)
	d[0].Add(&d[0], &t11)

	t11.Set(&d[5])
	MulBy11(&t11)
	d[1].Add(&d[1], &t11)

	t11.Set(&d[6])
	MulBy11(&t11)
	d[2].Add(&d[2], &t11)
	{{- end }}

	z.A0.Set(&d[0])
	z.A1.Set(&d[1])
	z.A2.Set(&d[2])
	z.A3.Set(&d[3])

	return z
}

{{- end }}

// Square sets z=x*x in E4D and returns z.
func (z *E4D) Square(x *E4D) *E4D {
	return z.Mul(x, x)
}

// FromTower converts an E4 element in tower representation to direct E4D.
func FromTower(x *E4) *E4D {
	var z E4D
	z.A0.Set(&x.B0.A0)
	z.A1.Set(&x.B1.A0)
	z.A2.Set(&x.B0.A1)
	z.A3.Set(&x.B1.A1)
	return &z
}

// ToTower converts a direct E4D element to tower representation.
func ToTower(x *E4D) *E4 {
	var z E4
	z.B0.A0.Set(&x.A0)
	z.B0.A1.Set(&x.A2)
	z.B1.A0.Set(&x.A1)
	z.B1.A1.Set(&x.A3)
	return &z
}
