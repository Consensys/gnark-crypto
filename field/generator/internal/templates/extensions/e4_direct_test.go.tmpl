import (
	"testing"

	"github.com/leanovate/gopter"
	"github.com/leanovate/gopter/prop"
)

func TestE4DReceiverIsOperand(t *testing.T) {

	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100

	properties := gopter.NewProperties(parameters)

	genA := GenE4D()
	genB := GenE4D()

	properties.Property("[(direct) {{.FF}}] conversion between direct and tower extensions", prop.ForAll(
		func(a *E4D) bool {
			b := ToTower(a)
			c := FromTower(b)
			return a.Equal(c)
		},
		genA,
	))

	properties.Property("[(direct) {{.FF}}] Having the receiver as operand (addition) should output the same result", prop.ForAll(
		func(a, b *E4D) bool {
			var c, d E4D
			d.Set(a)
			c.Add(a, b)
			a.Add(a, b)
			b.Add(&d, b)
			return a.Equal(b) && a.Equal(&c) && b.Equal(&c)
		},
		genA,
		genB,
	))

	properties.Property("[(direct) {{.FF}}] Having the receiver as operand (sub) should output the same result", prop.ForAll(
		func(a, b *E4D) bool {
			var c, d E4D
			d.Set(a)
			c.Sub(a, b)
			a.Sub(a, b)
			b.Sub(&d, b)
			return a.Equal(b) && a.Equal(&c) && b.Equal(&c)
		},
		genA,
		genB,
	))

	properties.Property("[(direct) {{.FF}}] Having the receiver as operand (mul) should output the same result", prop.ForAll(
		func(a, b *E4D) bool {
			var c, d E4D
			d.Set(a)
			c.Mul(a, b)
			a.Mul(a, b)
			b.Mul(&d, b)
			return a.Equal(b) && a.Equal(&c) && b.Equal(&c)
		},
		genA,
		genB,
	))

	properties.Property("[(direct) {{.FF}}] Having the receiver as operand (square) should output the same result", prop.ForAll(
		func(a *E4D) bool {
			var b E4D
			b.Square(a)
			a.Square(a)
			return a.Equal(&b)
		},
		genA,
	))

	properties.Property("[(direct) {{.FF}}] Having the receiver as operand (double) should output the same result", prop.ForAll(
		func(a *E4D) bool {
			var b E4D
			b.Double(a)
			a.Double(a)
			return a.Equal(&b)
		},
		genA,
	))

	properties.Property("[(direct) {{.FF}}] Having the receiver as operand (Inverse) should output the same result", prop.ForAll(
		func(a *E4D) bool {
			var b E4D
			b.Inverse(a)
			a.Inverse(a)
			return a.Equal(&b)
		},
		genA,
	))

	properties.Property("[(direct) {{.FF}}] Having the receiver as operand (Conjugate) should output the same result", prop.ForAll(
		func(a *E4D) bool {
			var b E4D
			b.Conjugate(a)
			a.Conjugate(a)
			return a.Equal(&b)
		},
		genA,
	))

	properties.TestingRun(t, gopter.ConsoleReporter(false))
}

func TestE4DOps(t *testing.T) {

	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100

	properties := gopter.NewProperties(parameters)

	genA := GenE4D()
	genB := GenE4D()

	properties.Property("[(direct) {{.FF}}] sub & add should leave an element invariant", prop.ForAll(
		func(a, b *E4D) bool {
			var c E4D
			c.Set(a)
			c.Add(&c, b).Sub(&c, b)
			return c.Equal(a)
		},
		genA,
		genB,
	))

	properties.Property("[(direct) {{.FF}}] tower mul and direct mul are the same", prop.ForAll(
		func(a, b *E4D) bool {
			var c E4D
			c.Mul(a, b)
			var _c E4
			_a := ToTower(a)
			_b := ToTower(b)
			_c.Mul(_a, _b)
			return c.Equal(FromTower(&_c))
		},
		genA,
		genB,
	))

	properties.Property("[(direct) {{.FF}}] mul & inverse should leave an element invariant", prop.ForAll(
		func(a, b *E4D) bool {
			var c, d E4D
			d.Inverse(b)
			c.Set(a)
			c.Mul(&c, b).Mul(&c, &d)
			return c.Equal(a)
		},
		genA,
		genB,
	))

	properties.Property("[(direct) {{.FF}}] inverse twice should leave an element invariant", prop.ForAll(
		func(a *E4D) bool {
			var b E4D
			b.Inverse(a).Inverse(&b)
			return a.Equal(&b)
		},
		genA,
	))

	properties.Property("[(direct) {{.FF}}] square and mul should output the same result", prop.ForAll(
		func(a *E4D) bool {
			var b, c E4D
			b.Mul(a, a)
			c.Square(a)
			return b.Equal(&c)
		},
		genA,
	))

	properties.TestingRun(t, gopter.ConsoleReporter(false))
}
