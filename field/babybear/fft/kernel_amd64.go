//go:build !purego

// Copyright 2020-2025 Consensys Software Inc.
// Licensed under the Apache License, Version 2.0. See the LICENSE file for details.

// Code generated by consensys/gnark-crypto DO NOT EDIT

package fft

import (
	"github.com/consensys/gnark-crypto/field/babybear"
	fext "github.com/consensys/gnark-crypto/field/babybear/extensions"
	"github.com/consensys/gnark-crypto/utils/cpu"
)

// q + r'.r = 1, i.e., qInvNeg = - q⁻¹ mod r
// used for Montgomery reduction
const qInvNeg = 2013265919
const q = 2013265921

// index table used in avx512 shuffling
var vInterleaveIndices = []uint64{
	2, 3, 8, 9, 6, 7, 12, 13,
}

//go:noescape
func innerDIFWithTwiddles_avx512(a, twiddles *babybear.Element, start, end, m int)

//go:noescape
func innerDITWithTwiddles_avx512(a, twiddles *babybear.Element, start, end, m int)

func innerDIFWithTwiddles(a []babybear.Element, twiddles []babybear.Element, start, end, m int) {
	if !cpu.SupportAVX512 || m < 16 {
		innerDIFWithTwiddlesGeneric(a, twiddles, start, end, m)
		return
	}
	innerDIFWithTwiddles_avx512(&a[0], &twiddles[0], start, end, m)
}

func innerDITWithTwiddles(a []babybear.Element, twiddles []babybear.Element, start, end, m int) {
	if !cpu.SupportAVX512 || m < 16 {
		innerDITWithTwiddlesGeneric(a, twiddles, start, end, m)
		return
	}
	innerDITWithTwiddles_avx512(&a[0], &twiddles[0], start, end, m)
}

//go:noescape
func kerDIFNP_256_avx512(a []babybear.Element, twiddles [][]babybear.Element, stage int)

func kerDIFNP_256(a []babybear.Element, twiddles [][]babybear.Element, stage int) {
	if !cpu.SupportAVX512 {
		kerDIFNP_256generic(a, twiddles, stage)
		return
	}
	kerDIFNP_256_avx512(a, twiddles, stage)
}

//go:noescape
func kerDITNP_256_avx512(a []babybear.Element, twiddles [][]babybear.Element, stage int)

func kerDITNP_256(a []babybear.Element, twiddles [][]babybear.Element, stage int) {
	if !cpu.SupportAVX512 {
		kerDITNP_256generic(a, twiddles, stage)
		return
	}
	kerDITNP_256_avx512(a, twiddles, stage)
}

func ConvertE4SliceToCoefficientSlices(input []fext.E4) [4][]babybear.Element {
	n := len(input)

	// Create the four output slices, each with the same length as the input slice
	outputC0 := make([]babybear.Element, n)
	outputC1 := make([]babybear.Element, n)
	outputC2 := make([]babybear.Element, n)
	outputC3 := make([]babybear.Element, n)

	// Iterate through the input slice and distribute the coefficients
	for i := 0; i < n; i++ {
		e4Element := input[i] // Get the current fext.E4 element

		// Extract coefficients and place them into the corresponding output slices
		outputC0[i] = e4Element.B0.A0
		outputC1[i] = e4Element.B0.A1
		outputC2[i] = e4Element.B1.A0
		outputC3[i] = e4Element.B1.A1
	}

	// Return the four slices packaged in an array
	return [4][]babybear.Element{outputC0, outputC1, outputC2, outputC3}
}

func innerDIFWithTwiddlesExt(a []fext.E4, twiddles []babybear.Element, start, end, m int) {
	if !cpu.SupportAVX512 || m < 16 {
		innerDIFWithTwiddlesGenericExt(a, twiddles, start, end, m)
		return
	}
	for _, v := range ConvertE4SliceToCoefficientSlices(a) {
		innerDIFWithTwiddles_avx512(&v[0], &twiddles[0], start, end, m)
	}
}

func innerDITWithTwiddlesExt(a []fext.E4, twiddles []babybear.Element, start, end, m int) {
	if !cpu.SupportAVX512 || m < 16 {
		innerDITWithTwiddlesGenericExt(a, twiddles, start, end, m)
		return
	}
	for _, v := range ConvertE4SliceToCoefficientSlices(a) {
		innerDITWithTwiddles_avx512(&v[0], &twiddles[0], start, end, m)
	}
}

func kerDIFNP_256Ext(a []fext.E4, twiddles [][]babybear.Element, stage int) {
	if !cpu.SupportAVX512 {
		kerDIFNP_256genericExt(a, twiddles, stage)
		return
	}
	for _, v := range ConvertE4SliceToCoefficientSlices(a) {
		kerDIFNP_256_avx512(v, twiddles, stage)
	}
}

func kerDITNP_256Ext(a []fext.E4, twiddles [][]babybear.Element, stage int) {
	if !cpu.SupportAVX512 {
		kerDITNP_256genericExt(a, twiddles, stage)
		return
	}
	for _, v := range ConvertE4SliceToCoefficientSlices(a) {
		kerDITNP_256_avx512(v, twiddles, stage)
	}
}
