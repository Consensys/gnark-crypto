//go:build !purego

// Code generated by gnark-crypto/generator. DO NOT EDIT.

#include "textflag.h"
#include "funcdata.h"
#include "go_asm.h"

// innerDITWithTwiddles_neon(a, twiddles *Element, start, end, m int)
// Processes 4 elements at a time using NEON
// For i := start; i < end; i++ { a[i+m].Mul(&a[i+m], &twiddles[i]); Butterfly(&a[i], &a[i+m]) }
TEXT ·innerDITWithTwiddles_neon(SB), NOFRAME|NOSPLIT, $0-40
	LDP   a+0(FP), (R0, R1)
	LDP   start+16(FP), (R2, R3)
	MOVD  m+32(FP), R4
	SUB   R2, R3, R3
	LSR   $2, R3, R3
	VMOVS $const_q, V0
	VDUP  V0.S[0], V0.S4         // broadcast P
	MOVD  $const_mu, R6
	VDUP  R6, V1.S4              // broadcast MU
	LSL   $2, R2, R2
	ADD   R2, R0, R0
	ADD   R2, R1, R1
	LSL   $2, R4, R4
	MOVD  R0, R5
	ADD   R4, R5, R5

loop1:
	CBZ    R3, done2
	VLD1.P 16(R0), [V2.S4]
	VLD1.P 16(R5), [V3.S4]
	VLD1.P 16(R1), [V4.S4]
	WORD   $0x4ea4b467         // SQDMULH V7.4S, V3.4S, V4.4S - c_hi = (2*am*tw) >> 32
	WORD   $0x4ea49c63         // MUL V3.4S, V3.4S, V4.4S - q_lo = am * tw
	WORD   $0x4ea19c63         // MUL V3.4S, V3.4S, V1.4S - q_lo = q_lo * mu
	WORD   $0x4ea0b468         // SQDMULH V8.4S, V3.4S, V0.4S - qp_hi = (2*q_lo*P) >> 32
	WORD   $0x4ea824e3         // SHSUB V3.4S, V7.4S, V8.4S - am = (c_hi - qp_hi) / 2
	WORD   $0x4ea73509         // CMGT V9.4S, V8.4S, V7.4S - underflow mask
	WORD   $0x6ea09523         // MLS V3.4S, V9.4S, V0.4S - am += P if underflow
	VADD   V2.S4, V3.S4, V5.S4 // t0 = a + am
	VSUB   V3.S4, V2.S4, V3.S4 // am = a - am
	VSUB   V0.S4, V5.S4, V2.S4 // a = t0 - p
	VUMIN  V5.S4, V2.S4, V2.S4 // a = min(t0, a)
	VADD   V0.S4, V3.S4, V6.S4 // t1 = am + p
	VUMIN  V6.S4, V3.S4, V3.S4 // am = min(t1, am)
	SUB    $16, R0, R6
	VST1.P [V2.S4], 0(R6)      // store a[i]
	SUB    $16, R5, R6
	VST1.P [V3.S4], 0(R6)      // store a[i+m]
	SUB    $1, R3, R3
	JMP    loop1

done2:
	RET

// innerDIFWithTwiddles_neon(a, twiddles *Element, start, end, m int)
// Processes 4 elements at a time using NEON
// For i := start; i < end; i++ { Butterfly(&a[i], &a[i+m]); a[i+m].Mul(&a[i+m], &twiddles[i]) }
TEXT ·innerDIFWithTwiddles_neon(SB), NOFRAME|NOSPLIT, $0-40
	LDP   a+0(FP), (R0, R1)
	LDP   start+16(FP), (R2, R3)
	MOVD  m+32(FP), R4
	SUB   R2, R3, R3
	LSR   $2, R3, R3
	VMOVS $const_q, V0
	VDUP  V0.S[0], V0.S4         // broadcast P
	MOVD  $const_mu, R6
	VDUP  R6, V1.S4              // broadcast MU
	LSL   $2, R2, R2
	ADD   R2, R0, R0
	ADD   R2, R1, R1
	LSL   $2, R4, R4
	MOVD  R0, R5
	ADD   R4, R5, R5

loop3:
	CBZ    R3, done4
	VLD1.P 16(R0), [V2.S4]
	VLD1.P 16(R5), [V3.S4]
	VLD1.P 16(R1), [V4.S4]
	VSUB   V3.S4, V2.S4, V6.S4 // t1 = a - am
	VADD   V2.S4, V3.S4, V5.S4 // t0 = a + am
	VSUB   V0.S4, V5.S4, V2.S4 // a = t0 - p
	VUMIN  V5.S4, V2.S4, V2.S4 // a = min(t0, a)
	VADD   V0.S4, V6.S4, V3.S4 // am_temp = t1 + p
	VUMIN  V6.S4, V3.S4, V3.S4 // am = min(t1, t1+p)
	WORD   $0x4ea4b467         // SQDMULH V7.4S, V3.4S, V4.4S - c_hi = (2*am*tw) >> 32
	WORD   $0x4ea49c63         // MUL V3.4S, V3.4S, V4.4S - q_lo = am * tw
	WORD   $0x4ea19c63         // MUL V3.4S, V3.4S, V1.4S - q_lo = q_lo * mu
	WORD   $0x4ea0b468         // SQDMULH V8.4S, V3.4S, V0.4S - qp_hi = (2*q_lo*P) >> 32
	WORD   $0x4ea824e3         // SHSUB V3.4S, V7.4S, V8.4S - am = (c_hi - qp_hi) / 2
	WORD   $0x4ea73509         // CMGT V9.4S, V8.4S, V7.4S - underflow mask
	WORD   $0x6ea09523         // MLS V3.4S, V9.4S, V0.4S - am += P if underflow
	SUB    $16, R0, R6
	VST1.P [V2.S4], 0(R6)      // store a[i]
	SUB    $16, R5, R6
	VST1.P [V3.S4], 0(R6)      // store a[i+m]
	SUB    $1, R3, R3
	JMP    loop3

done4:
	RET
