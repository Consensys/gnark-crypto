// Copyright 2020-2025 Consensys Software Inc.
// Licensed under the Apache License, Version 2.0. See the LICENSE file for details.

// Code generated by consensys/gnark-crypto DO NOT EDIT

package extensions

import (
	"math/bits"
	"unsafe"

	fr "github.com/consensys/gnark-crypto/field/babybear"
)

type Vector []E4

func (vector Vector) Add(a, b Vector) {
	N := len(a)
	if N != len(b) || N != len(vector) {
		panic("vector.Add: vectors don't have the same length")
	}
	vectorAddGeneric(vector, a, b)
}

func (vector Vector) Sub(a, b Vector) {
	N := len(a)
	if N != len(b) || N != len(vector) {
		panic("vector.Sub: vectors don't have the same length")
	}
	vectorSubGeneric(vector, a, b)
}

func (vector Vector) Mul(a, b Vector) {
	N := len(a)
	if N != len(b) || N != len(vector) {
		panic("vector.Mul: vectors don't have the same length")
	}
	vectorMulGeneric(vector, a, b)
}

func (vector Vector) ScalarMul(a Vector, b *E4) {
	N := len(a)
	if N != len(vector) {
		panic("vector.ScalarMul: vectors don't have the same length")
	}
	vectorScalarMulGeneric(vector, a, b)
}

// Sum computes the sum of all elements in the vector.
func (vector Vector) Sum() E4 {
	return vectorSumGeneric(vector)
}

func (vector Vector) InnerProductByElement(a fr.Vector) E4 {
	N := len(vector)
	if len(a) != N {
		panic("vector.InnerProduct: vectors don't have the same length")
	}
	return vectorInnerProductByElementGeneric(vector, a)
}

func (vector Vector) InnerProduct(a Vector) E4 {
	N := len(vector)
	if len(a) != N {
		panic("vector.InnerProduct: vectors don't have the same length")
	}
	return vectorInnerProductGeneric(vector, a)
}

func (vector Vector) MulByElement(a Vector, b fr.Vector) {
	N := len(vector)
	if len(a) != N || len(b) != N {
		panic("vector.MulByElement: vectors don't have the same length")
	}
	vectorMulByElementGeneric(vector, a, b)
}

// Butterfly computes the in-place butterfly operation on two vectors of E4 elements
// If other overlaps with vector, result is undefined, caller should use a temp vector.
func (vector Vector) Butterfly(other Vector) {
	N := len(other)
	if N != len(vector) {
		panic("vector.Butterfly: vectors don't have the same length")
	}
	vectorButterflyGeneric(vector, other)
}

// ButterflyPair computes the in-place butterfly operation of each pair in the vector
// vector[0], vector[1]; vector[2], vector[3]; ...
func (vector Vector) ButterflyPair() {
	N := len(vector)
	if N%2 != 0 {
		panic("vector.ButterflyPair: vector length must be even")
	}
	for i := 0; i < N; i += 2 {
		Butterfly(&vector[i], &vector[i+1])
	}
}

func (vector Vector) ScalarMulByElement(a Vector, b *fr.Element) {
	if len(a) != len(vector) {
		panic("vector.ScalarMulByElement: vectors don't have the same length")
	}
	if len(vector) == 0 {
		return
	}

	// for this one, since mul by element scales each coordinates, we cast a to a fr.Vector,
	// and call the already optimized fr.Vector.ScalarMul
	M := len(a) * 4
	vBase := fr.Vector(unsafe.Slice((*fr.Element)(unsafe.Pointer(&a[0])), M))
	vRes := fr.Vector(unsafe.Slice((*fr.Element)(unsafe.Pointer(&vector[0])), M))
	vRes.ScalarMul(vBase, b)
}

// Exp sets vector[i] = a[i]ᵏ for all i
func (vector Vector) Exp(a Vector, k int64) {
	N := len(a)
	if N != len(vector) {
		panic("vector.Exp: vectors don't have the same length")
	}
	if k == 0 {
		for i := range vector {
			vector[i].SetOne()
		}
		return
	}
	base := a
	exp := k
	if k < 0 {
		// call batch inverse
		base = BatchInvertE4(a)
		exp = -k // if k == math.MinInt64, -k overflows, but uint64(-k) is correct
	} else if N > 0 {
		// ensure that vector and a are not the same slice; else we need to copy a into base
		v0 := &vector[0] // #nosec G602 we check that N > 0 above
		a0 := &a[0]      // #nosec G602 we check that N > 0 above
		if v0 == a0 {
			base = make(Vector, N)
			copy(base, a)
		}
	}

	copy(vector, base)

	// Use bits.Len64 to iterate only over significant bits
	for i := bits.Len64(uint64(exp)) - 2; i >= 0; i-- {
		vector.Mul(vector, vector)
		if (uint64(exp)>>uint(i))&1 != 0 {
			vector.Mul(vector, base)
		}
	}
}

// MulAccByElement multiplies each element of the vector v by the E4 element alpha,
// accumulating the result in the same vector.
func (vector Vector) MulAccByElement(scale []fr.Element, alpha *E4) {
	N := len(vector)
	if N != len(scale) {
		panic("MulAccByElement: len(vector) != len(scale)")
	}
	vectorMulAccByElementGeneric(vector, scale, alpha)
}

func vectorAddGeneric(res, a, b Vector) {
	for i := 0; i < len(res); i++ {
		res[i].Add(&a[i], &b[i])
	}
}
func vectorSubGeneric(res, a, b Vector) {
	for i := 0; i < len(res); i++ {
		res[i].Sub(&a[i], &b[i])
	}
}
func vectorMulGeneric(res, a, b Vector) {
	for i := 0; i < len(res); i++ {
		res[i].Mul(&a[i], &b[i])
	}
}
func vectorScalarMulGeneric(res, a Vector, b *E4) {
	for i := 0; i < len(res); i++ {
		res[i].Mul(&a[i], b)
	}
}

func vectorInnerProductGeneric(a, b Vector) E4 {
	var res, tmp E4
	for i := 0; i < len(a); i++ {
		tmp.Mul(&a[i], &b[i])
		res.Add(&res, &tmp)
	}
	return res
}

func vectorInnerProductByElementGeneric(a Vector, b fr.Vector) E4 {
	var res, tmp E4
	for i := 0; i < len(a); i++ {
		tmp.MulByElement(&a[i], &b[i])
		res.Add(&res, &tmp)
	}
	return res
}

func vectorSumGeneric(v Vector) E4 {
	var sum E4
	for i := 0; i < len(v); i++ {
		sum.Add(&sum, &v[i])
	}
	return sum
}

func vectorMulAccByElementGeneric(v Vector, scale []fr.Element, alpha *E4) {
	var tmp E4
	for i := 0; i < len(v); i++ {
		tmp.MulByElement(alpha, &scale[i])
		v[i].Add(&v[i], &tmp)
	}
}

func vectorMulByElementGeneric(res, a Vector, b fr.Vector) {
	for i := 0; i < len(res); i++ {
		res[i].MulByElement(&a[i], &b[i])
	}
}

func vectorButterflyGeneric(a, b Vector) {
	for i := 0; i < len(a); i++ {
		Butterfly(&a[i], &b[i])
	}
}
