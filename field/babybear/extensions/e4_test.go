// Copyright 2020-2025 Consensys Software Inc.
// Licensed under the Apache License, Version 2.0. See the LICENSE file for details.

// Code generated by consensys/gnark-crypto DO NOT EDIT

package extensions

import (
	"bytes"
	"github.com/leanovate/gopter"
	"github.com/leanovate/gopter/prop"
	"math/big"
	"os"
	"reflect"
	"runtime"
	"sort"
	"testing"

	"fmt"
	fr "github.com/consensys/gnark-crypto/field/babybear"

	"github.com/stretchr/testify/require"
)

// ------------------------------------------------------------
// tests

func TestE4ReceiverIsOperand(t *testing.T) {

	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100

	properties := gopter.NewProperties(parameters)

	genA := genE4()
	genB := genE4()

	properties.Property("[babybear] Having the receiver as operand (addition) should output the same result", prop.ForAll(
		func(a, b E4) bool {
			var c, d E4
			d.Set(&a)
			c.Add(&a, &b)
			a.Add(&a, &b)
			b.Add(&d, &b)
			return a.Equal(&b) && a.Equal(&c) && b.Equal(&c)
		},
		genA,
		genB,
	))

	properties.Property("[babybear] Having the receiver as operand (sub) should output the same result", prop.ForAll(
		func(a, b E4) bool {
			var c, d E4
			d.Set(&a)
			c.Sub(&a, &b)
			a.Sub(&a, &b)
			b.Sub(&d, &b)
			return a.Equal(&b) && a.Equal(&c) && b.Equal(&c)
		},
		genA,
		genB,
	))

	properties.Property("[babybear] Having the receiver as operand (mul) should output the same result", prop.ForAll(
		func(a, b E4) bool {
			var c, d E4
			d.Set(&a)
			c.Mul(&a, &b)
			a.Mul(&a, &b)
			b.Mul(&d, &b)
			return a.Equal(&b) && a.Equal(&c) && b.Equal(&c)
		},
		genA,
		genB,
	))

	properties.Property("[babybear] Having the receiver as operand (square) should output the same result", prop.ForAll(
		func(a E4) bool {
			var b E4
			b.Square(&a)
			a.Square(&a)
			return a.Equal(&b)
		},
		genA,
	))

	properties.Property("[babybear] Having the receiver as operand (double) should output the same result", prop.ForAll(
		func(a E4) bool {
			var b E4
			b.Double(&a)
			a.Double(&a)
			return a.Equal(&b)
		},
		genA,
	))

	properties.Property("[babybear] Having the receiver as operand (mul by non residue) should output the same result", prop.ForAll(
		func(a E4) bool {
			var b E4
			b.MulByNonResidue(&a)
			a.MulByNonResidue(&a)
			return a.Equal(&b)
		},
		genA,
	))

	properties.Property("[babybear] Having the receiver as operand (Inverse) should output the same result", prop.ForAll(
		func(a E4) bool {
			var b E4
			b.Inverse(&a)
			a.Inverse(&a)
			return a.Equal(&b)
		},
		genA,
	))

	properties.Property("[babybear] Having the receiver as operand (Conjugate) should output the same result", prop.ForAll(
		func(a E4) bool {
			var b E4
			b.Conjugate(&a)
			a.Conjugate(&a)
			return a.Equal(&b)
		},
		genA,
	))

	properties.Property("[babybear] Having the receiver as operand (Sqrt) should output the same result", prop.ForAll(
		func(a E4) bool {
			var b, c, d, s E4

			s.Square(&a)
			a.Set(&s)
			b.Set(&s)

			a.Sqrt(&a)
			b.Sqrt(&b)

			c.Square(&a)
			d.Square(&b)
			return c.Equal(&d)
		},
		genA,
	))

	properties.TestingRun(t, gopter.ConsoleReporter(false))
}

func TestE4Ops(t *testing.T) {

	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100

	properties := gopter.NewProperties(parameters)

	genA := genE4()
	genB := genE4()

	properties.Property("[babybear] sub & add should leave an element invariant", prop.ForAll(
		func(a, b E4) bool {
			var c E4
			c.Set(&a)
			c.Add(&c, &b).Sub(&c, &b)
			return c.Equal(&a)
		},
		genA,
		genB,
	))

	properties.Property("[babybear] mul & inverse should leave an element invariant", prop.ForAll(
		func(a, b E4) bool {
			var c, d E4
			d.Inverse(&b)
			c.Set(&a)
			c.Mul(&c, &b).Mul(&c, &d)
			return c.Equal(&a)
		},
		genA,
		genB,
	))

	properties.Property("[babybear] BatchInvertE4 should output the same result as Inverse", prop.ForAll(
		func(a, b, c E4) bool {

			batch := BatchInvertE4([]E4{a, b, c})
			a.Inverse(&a)
			b.Inverse(&b)
			c.Inverse(&c)
			return a.Equal(&batch[0]) && b.Equal(&batch[1]) && c.Equal(&batch[2])
		},
		genA,
		genA,
		genB,
	))

	properties.Property("[babybear] inverse twice should leave an element invariant", prop.ForAll(
		func(a E4) bool {
			var b E4
			b.Inverse(&a).Inverse(&b)
			return a.Equal(&b)
		},
		genA,
	))

	properties.Property("[babybear] square and mul should output the same result", prop.ForAll(
		func(a E4) bool {
			var b, c E4
			b.Mul(&a, &a)
			c.Square(&a)
			return b.Equal(&c)
		},
		genA,
	))

	properties.Property("[babybear] Legendre on square should output 1", prop.ForAll(
		func(a E4) bool {
			var b E4
			b.Square(&a)
			c := b.Legendre()
			return c == 1
		},
		genA,
	))

	properties.Property("[babybear] square(sqrt) should leave an element invariant", prop.ForAll(
		func(a E4) bool {
			var b, c, d, e E4
			b.Square(&a)
			c.Sqrt(&b)
			d.Square(&c)
			e.Neg(&a)
			return (c.Equal(&a) || c.Equal(&e)) && d.Equal(&b)
		},
		genA,
	))

	properties.TestingRun(t, gopter.ConsoleReporter(false))
}

func TestE4Exp(t *testing.T) {
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100

	properties := gopter.NewProperties(parameters)
	genA := genE4()

	properties.Property("[babybear] Exp(x, 0) should return one", prop.ForAll(
		func(a E4) bool {
			var res E4
			var one E4
			one.SetOne()
			res.Exp(a, big.NewInt(0))
			return res.Equal(&one)
		},
		genA,
	))

	properties.Property("[babybear] Exp(x, 1) should return x", prop.ForAll(
		func(a E4) bool {
			var res E4
			res.Exp(a, big.NewInt(1))
			return res.Equal(&a)
		},
		genA,
	))

	properties.Property("[babybear] Exp(x, 2) should return x squared", prop.ForAll(
		func(a E4) bool {
			var res, sq E4
			res.Exp(a, big.NewInt(2))
			sq.Square(&a)
			return res.Equal(&sq)
		},
		genA,
	))

	properties.Property("[babybear] Exp(x, k) should match repeated multiplication", prop.ForAll(
		func(a E4) bool {
			var res, mul E4
			k := int64(0b101101) // 45
			res.Exp(a, big.NewInt(k))
			mul.SetOne()
			for i := int64(0); i < k; i++ {
				mul.Mul(&mul, &a)
			}
			return res.Equal(&mul)
		},
		genA,
	))

	properties.TestingRun(t, gopter.ConsoleReporter(false))
}

func TestVectorOps(t *testing.T) {
	parameters := gopter.DefaultTestParameters()
	if testing.Short() {
		parameters.MinSuccessfulTests = 2
	} else {
		parameters.MinSuccessfulTests = 10
	}
	properties := gopter.NewProperties(parameters)

	addVector := func(a, b Vector) bool {
		c := make(Vector, len(a))
		c.Add(a, b)

		for i := 0; i < len(a); i++ {
			var tmp E4
			tmp.Add(&a[i], &b[i])
			if !tmp.Equal(&c[i]) {
				return false
			}
		}
		return true
	}

	subVector := func(a, b Vector) bool {
		c := make(Vector, len(a))
		c.Sub(a, b)

		for i := 0; i < len(a); i++ {
			var tmp E4
			tmp.Sub(&a[i], &b[i])
			if !tmp.Equal(&c[i]) {
				return false
			}
		}
		return true
	}

	scalarMulVector := func(a Vector, b E4) bool {
		c := make(Vector, len(a))
		c.ScalarMul(a, &b)

		for i := 0; i < len(a); i++ {
			var tmp E4
			tmp.Mul(&a[i], &b)
			if !tmp.Equal(&c[i]) {
				return false
			}
		}
		return true
	}

	sumVector := func(a Vector) bool {
		var sum E4
		computed := a.Sum()
		for i := 0; i < len(a); i++ {
			sum.Add(&sum, &a[i])
		}

		return sum.Equal(&computed)
	}

	innerProductVector := func(a, b Vector) bool {
		computed := a.InnerProduct(b)
		var innerProduct E4
		for i := 0; i < len(a); i++ {
			var tmp E4
			tmp.Mul(&a[i], &b[i])
			innerProduct.Add(&innerProduct, &tmp)
		}

		return innerProduct.Equal(&computed)
	}

	mulVector := func(a, b Vector) bool {
		c := make(Vector, len(a))
		a[0].B0.A0.SetUint64(0x24)
		b[0].B0.A0.SetUint64(0x42)
		c.Mul(a, b)

		for i := 0; i < len(a); i++ {
			var tmp E4
			tmp.Mul(&a[i], &b[i])
			if !tmp.Equal(&c[i]) {
				return false
			}
		}
		return true
	}

	sizes := []int{1, 2, 3, 4, 8, 9, 15, 16, 24, 32, 509, 510, 511, 512, 513, 514}
	type genPair struct {
		g1, g2 gopter.Gen
		label  string
	}

	for _, size := range sizes {
		generators := []genPair{
			{genZeroVector(size), genZeroVector(size), "zero vectors"},
			{genMaxVector(size), genMaxVector(size), "max vectors"},
			{genVector(size), genVector(size), "random vectors"},
			{genVector(size), genZeroVector(size), "random and zero vectors"},
		}
		for _, gp := range generators {
			properties.Property(fmt.Sprintf("vector addition %d - %s", size, gp.label), prop.ForAll(
				addVector,
				gp.g1,
				gp.g2,
			))

			properties.Property(fmt.Sprintf("vector subtraction %d - %s", size, gp.label), prop.ForAll(
				subVector,
				gp.g1,
				gp.g2,
			))

			properties.Property(fmt.Sprintf("vector scalar multiplication %d - %s", size, gp.label), prop.ForAll(
				scalarMulVector,
				gp.g1,
				genE4(),
			))

			properties.Property(fmt.Sprintf("vector sum %d - %s", size, gp.label), prop.ForAll(
				sumVector,
				gp.g1,
			))

			properties.Property(fmt.Sprintf("vector inner product %d - %s", size, gp.label), prop.ForAll(
				innerProductVector,
				gp.g1,
				gp.g2,
			))

			properties.Property(fmt.Sprintf("vector multiplication %d - %s", size, gp.label), prop.ForAll(
				mulVector,
				gp.g1,
				gp.g2,
			))

			properties.Property(fmt.Sprintf("vector scalar multiplication by element %d - %s", size, gp.label), prop.ForAll(
				func(a Vector, b fr.Element) bool {
					c := make(Vector, len(a))
					c.ScalarMulByElement(a, &b)
					for i := 0; i < len(a); i++ {
						var tmp E4
						tmp.MulByElement(&a[i], &b)
						if !tmp.Equal(&c[i]) {
							return false
						}
					}
					return true
				},
				gp.g1,
				genFr(),
			))

			properties.Property(fmt.Sprintf("vector multiplication by element %d - %s", size, gp.label), prop.ForAll(
				func(a Vector, b fr.Vector) bool {
					c := make(Vector, len(a))
					c.MulByElement(a, b)
					for i := 0; i < len(a); i++ {
						var tmp E4
						tmp.MulByElement(&a[i], &b[i])
						if !tmp.Equal(&c[i]) {
							return false
						}
					}
					return true
				},
				gp.g1,
				genFrVector(size),
			))

			// checking that in-place butterfly works as intended;
			properties.Property(fmt.Sprintf("vector butterfly %d - %s", size, gp.label), prop.ForAll(
				func(a, b Vector) bool {
					if len(a) != len(b) {
						return false
					}
					c := make(Vector, len(a))
					d := make(Vector, len(a))
					copy(c, a)
					copy(d, b)
					c.Butterfly(d)
					for i := range a {
						Butterfly(&a[i], &b[i])
					}
					for i := range a {
						if !a[i].Equal(&c[i]) {
							return false
						}
						if !b[i].Equal(&d[i]) {
							return false
						}
					}
					return true
				},
				genVector(256),
				genVector(256),
			))

			properties.Property(fmt.Sprintf("vector butterfly pair %d - %s", size, gp.label), prop.ForAll(
				func(a Vector) bool {
					if len(a)%2 != 0 {
						return true // skip odd-sized vectors
					}
					c := make(Vector, len(a))
					copy(c, a)
					c.ButterflyPair()
					for i := 0; i < len(a); i += 2 {
						var x, y E4
						x.Set(&a[i])
						y.Set(&a[i+1])
						Butterfly(&x, &y)
						if !c[i].Equal(&x) || !c[i+1].Equal(&y) {
							return false
						}
					}
					return true
				},
				gp.g1,
			))

			properties.Property(fmt.Sprintf("vector inner product by element %d - %s", size, gp.label), prop.ForAll(
				func(a Vector, b fr.Vector) bool {
					computed := a.InnerProductByElement(b)
					var innerProduct E4
					for i := 0; i < len(a); i++ {
						var tmp E4
						tmp.MulByElement(&a[i], &b[i])
						innerProduct.Add(&innerProduct, &tmp)
					}
					return innerProduct.Equal(&computed)
				},
				gp.g1,
				genFrVector(size),
			))

		}
	}

	properties.TestingRun(t, gopter.NewFormatedReporter(false, 260, os.Stdout))
}

// TestVectorExp tests the Exp method for Vector type.
func TestVectorExp(t *testing.T) {
	assert := require.New(t)

	// Test with empty vector
	empty := make(Vector, 0)
	expEmpty := make(Vector, 0)
	expEmpty.Exp(empty, 5)
	assert.Equal(0, len(expEmpty), "Exp of empty vector should be empty")

	// Test with vector of ones and exponent 0
	const size = 32
	v := make(Vector, size)
	for i := range v {
		v[i].SetOne()
	}
	expZero := make(Vector, size)
	expZero.Exp(v, 0)
	for i := range expZero {
		assert.True(expZero[i].IsOne(), "Exp(x, 0) should be one for all elements")
	}

	// Test with random vector and exponent 1
	for i := range v {
		v[i].MustSetRandom()
	}
	expOne := make(Vector, size)
	expOne.Exp(v, 1)
	for i := range v {
		assert.True(expOne[i].Equal(&v[i]), "Exp(x, 1) should be x for all elements")
	}

	// Test with random vector and exponent 2
	expTwo := make(Vector, size)
	expTwo.Exp(v, 2)
	for i := range v {
		var sq E4
		sq.Square(&v[i])
		assert.True(expTwo[i].Equal(&sq), "Exp(x, 2) should be x squared for all elements")
	}

	// Test with random vector and exponent k
	k := int64(7)
	expK := make(Vector, size)
	expK.Exp(v, k)
	for i := range v {
		var mul E4
		mul.SetOne()
		for j := int64(0); j < k; j++ {
			mul.Mul(&mul, &v[i])
		}
		assert.True(expK[i].Equal(&mul), "Exp(x, k) should match repeated multiplication for all elements")
	}

	// Test to check v.Exp(v, k) is correct (no modification of v during the process)
	vCopy := make(Vector, size)
	copy(vCopy, v)
	vCopy.Exp(vCopy, k)
	for i := range v {
		assert.True(vCopy[i].Equal(&expK[i]), "Exp(x, k) should be consistent for all elements")
	}

	// Test with random vector and negative exponent -1
	expNegOne := make(Vector, size)
	expNegOne.Exp(v, -1)
	for i := range v {
		var inv E4
		inv.Inverse(&v[i])
		assert.True(expNegOne[i].Equal(&inv), "Exp(x, -1) should be inverse for all elements")
	}

}

// prefixProductGeneric computes the prefix product of the vector in place (single-threaded).
func prefixProductGeneric(vector Vector) {
	if len(vector) == 0 {
		return
	}
	for i := 1; i < len(vector); i++ {
		vector[i].Mul(&vector[i-1], &vector[i])
	}
}

func randomVector(size int) Vector {
	v := make(Vector, size)
	for i := range v {
		v[i].MustSetRandom()
	}
	return v
}

func TestPrefixProduct_EmptyVector(t *testing.T) {
	assert := require.New(t)
	v := make(Vector, 0)
	expected := make(Vector, 0)
	prefixProductGeneric(expected)
	v.PrefixProduct()
	assert.Equal(expected, v)
}

func TestPrefixProduct_VariousNbTasks(t *testing.T) {
	assert := require.New(t)
	sizes := []int{1, 2, 256, 1024}
	nbTasksList := []int{1, 16, 32, runtime.NumCPU()}
	for _, size := range sizes {
		for _, nbTasks := range nbTasksList {
			v := randomVector(size)
			expected := make(Vector, size)
			copy(expected, v)
			prefixProductGeneric(expected)
			v.PrefixProduct(nbTasks)
			assert.Equal(expected, v, "size=%d nbTasks=%d", size, nbTasks)
		}
	}
}

func TestVectorEmptyOps(t *testing.T) {
	assert := require.New(t)

	var sum, inner, scalar E4
	scalar.MustSetRandom()
	empty := make(Vector, 0)
	result := make(Vector, 0)

	assert.NotPanics(func() { result.Add(empty, empty) })
	assert.NotPanics(func() { result.Sub(empty, empty) })
	assert.NotPanics(func() { result.ScalarMul(empty, &scalar) })
	assert.NotPanics(func() { result.Mul(empty, empty) })
	assert.NotPanics(func() { sum = empty.Sum() })
	assert.NotPanics(func() { inner = empty.InnerProduct(empty) })

	assert.True(sum.IsZero())
	assert.True(inner.IsZero())
}

func TestVectorSort(t *testing.T) {
	assert := require.New(t)

	v := make(Vector, 3)
	v[0].B0.A0.SetUint64(2)
	v[1].B0.A0.SetUint64(3)
	v[2].B0.A0.SetUint64(1)

	expected := make(Vector, 3)
	expected[0].B0.A0.SetUint64(1)
	expected[1].B0.A0.SetUint64(2)
	expected[2].B0.A0.SetUint64(3)

	assert.False(v.Equal(expected))

	sort.Sort(v)

	assert.True(v.Equal(expected))
}

func TestVectorRoundTrip(t *testing.T) {
	assert := require.New(t)

	v1 := make(Vector, 3)
	v1[0].MustSetRandom()
	v1[1].MustSetRandom()
	v1[2].MustSetRandom()

	b, err := v1.MarshalBinary()
	assert.NoError(err)

	var v2, v3 Vector

	err = v2.UnmarshalBinary(b)
	assert.NoError(err)

	err = v3.unmarshalBinaryAsync(b)
	assert.NoError(err)

	assert.True(reflect.DeepEqual(v1, v2))
	assert.True(reflect.DeepEqual(v3, v2))
}

func TestVectorEmptyRoundTrip(t *testing.T) {
	assert := require.New(t)

	v1 := make(Vector, 0)

	b, err := v1.MarshalBinary()
	assert.NoError(err)

	var v2, v3 Vector

	err = v2.UnmarshalBinary(b)
	assert.NoError(err)

	err = v3.unmarshalBinaryAsync(b)
	assert.NoError(err)

	assert.True(reflect.DeepEqual(v1, v2))
	assert.True(reflect.DeepEqual(v3, v2))
}

func (vector *Vector) unmarshalBinaryAsync(data []byte) error {
	r := bytes.NewReader(data)
	_, err, chErr := vector.AsyncReadFrom(r)
	if err != nil {
		return err
	}
	return <-chErr
}

// ------------------------------------------------------------
// benches

func BenchmarkE4Add(b *testing.B) {
	var a, c E4
	a.MustSetRandom()
	c.MustSetRandom()
	b.ResetTimer()
	for i := 0; i < b.N; i++ {
		a.Add(&a, &c)
	}
}

func BenchmarkE4Sub(b *testing.B) {
	var a, c E4
	a.MustSetRandom()
	c.MustSetRandom()
	b.ResetTimer()
	for i := 0; i < b.N; i++ {
		a.Sub(&a, &c)
	}
}

func BenchmarkE4Mul(b *testing.B) {
	var a, c E4
	a.MustSetRandom()
	c.MustSetRandom()
	b.ResetTimer()
	for i := 0; i < b.N; i++ {
		a.Mul(&a, &c)
	}
}

func BenchmarkE4MulByElement(b *testing.B) {
	var a E4
	var c fr.Element
	_, _ = a.SetRandom()
	_, _ = c.SetRandom()
	b.ResetTimer()
	for i := 0; i < b.N; i++ {
		a.MulByElement(&a, &c)
	}
}

func BenchmarkE4Square(b *testing.B) {
	var a E4
	a.MustSetRandom()
	b.ResetTimer()
	for i := 0; i < b.N; i++ {
		a.Square(&a)
	}
}

func BenchmarkE4Sqrt(b *testing.B) {
	var a E4
	a.MustSetRandom()
	b.ResetTimer()
	for i := 0; i < b.N; i++ {
		a.Sqrt(&a)
	}
}

func BenchmarkE4Inverse(b *testing.B) {
	var a E4
	a.MustSetRandom()
	b.ResetTimer()
	for i := 0; i < b.N; i++ {
		a.Inverse(&a)
	}
}

func BenchmarkE4MulNonRes(b *testing.B) {
	var a E4
	a.MustSetRandom()
	b.ResetTimer()
	for i := 0; i < b.N; i++ {
		a.MulByNonResidue(&a)
	}
}

func BenchmarkE4Conjugate(b *testing.B) {
	var a E4
	a.MustSetRandom()
	b.ResetTimer()
	for i := 0; i < b.N; i++ {
		a.Conjugate(&a)
	}
}

func BenchmarkVectorOps(b *testing.B) {
	// note; to benchmark against "no asm" version, use the following
	// build tag: -tags purego
	const N = 1 << 20
	a1 := make(Vector, N)
	b1 := make(Vector, N)
	c1 := make(Vector, N)
	b2 := make(fr.Vector, N)
	for i := 1; i < N; i++ {
		a1[i-1].MustSetRandom()
		b1[i-1].MustSetRandom()
		b2[i-1].MustSetRandom()
	}

	for n := 4; n <= N; n <<= 1 {
		_a := a1[:n]
		_b := b1[:n]
		_c := c1[:n]
		_b2 := b2[:n]

		b.Run(fmt.Sprintf("add %d", n), func(b *testing.B) {
			b.ResetTimer()
			for i := 0; i < b.N; i++ {
				_c.Add(_a, _b)
			}
		})

		b.Run(fmt.Sprintf("sub %d", n), func(b *testing.B) {
			b.ResetTimer()
			for i := 0; i < b.N; i++ {
				_c.Sub(_a, _b)
			}
		})

		b.Run(fmt.Sprintf("scalarMul %d", n), func(b *testing.B) {
			b.ResetTimer()
			for i := 0; i < b.N; i++ {
				_c.ScalarMul(_a, &b1[0])
			}
		})

		b.Run(fmt.Sprintf("sum %d", n), func(b *testing.B) {
			b.ResetTimer()
			for i := 0; i < b.N; i++ {
				_ = _a.Sum()
			}
		})

		b.Run(fmt.Sprintf("innerProduct %d", n), func(b *testing.B) {
			b.ResetTimer()
			for i := 0; i < b.N; i++ {
				_ = _a.InnerProduct(_b)
			}
		})

		b.Run(fmt.Sprintf("innerProductByElement %d", n), func(b *testing.B) {
			b.ResetTimer()
			for i := 0; i < b.N; i++ {
				_ = _a.InnerProductByElement(_b2)
			}
		})

		b.Run(fmt.Sprintf("mul %d", n), func(b *testing.B) {
			b.ResetTimer()
			for i := 0; i < b.N; i++ {
				_c.Mul(_a, _b)
			}
		})

		b.Run(fmt.Sprintf("exp %d", n), func(b *testing.B) {
			b.ResetTimer()
			for i := 0; i < b.N; i++ {
				_c.Exp(_a, int64(2013265921>>2))
			}
		})

		b.Run(fmt.Sprintf("exp neg %d", n), func(b *testing.B) {
			b.ResetTimer()
			for i := 0; i < b.N; i++ {
				_c.Exp(_a, -int64(2013265921>>2))
			}
		})
	}
}

func BenchmarkPrefixProduct(b *testing.B) {
	const N = 1 << 19
	a1 := make(Vector, N)
	for i := 0; i < N; i++ {
		a1[i].MustSetRandom()
	}

	b.Run("generic", func(b *testing.B) {
		b.ResetTimer()
		for i := 0; i < b.N; i++ {
			prefixProductGeneric(a1)
		}
	})

	b.Run("PrefixProduct", func(b *testing.B) {
		b.ResetTimer()
		for i := 0; i < b.N; i++ {
			a1.PrefixProduct()
		}
	})

}

func BenchmarkVectorSerialization(b *testing.B) {
	const N = 1 << 15
	a1 := make(Vector, N)
	for i := 1; i < N; i++ {
		a1[i-1].MustSetRandom()
	}
	b.Run("MarshalBinary", func(b *testing.B) {
		b.ResetTimer()
		for i := 0; i < b.N; i++ {
			_, err := a1.MarshalBinary()
			if err != nil {
				b.Fatal(err)
			}
		}
	})

	data, err := a1.MarshalBinary()
	if err != nil {
		b.Fatal(err)
	}

	b.Run("UnmarshalBinary", func(b *testing.B) {
		var a2 Vector
		b.ResetTimer()
		for i := 0; i < b.N; i++ {
			err := a2.UnmarshalBinary(data)
			if err != nil {
				b.Fatal(err)
			}
		}
	})

	b.Run("unmarshalBinaryAsync", func(b *testing.B) {
		var a2 Vector
		b.ResetTimer()
		for i := 0; i < b.N; i++ {
			err := a2.unmarshalBinaryAsync(data)
			if err != nil {
				b.Fatal(err)
			}
		}
	})
}

func genZeroVector(size int) gopter.Gen {
	return func(*gopter.GenParameters) *gopter.GenResult {
		return gopter.NewGenResult(make(Vector, size), gopter.NoShrinker)
	}
}

func genMaxVector(size int) gopter.Gen {
	return func(*gopter.GenParameters) *gopter.GenResult {
		qMinusOne := fr.Element{2013265921}
		qMinusOne[0]--
		v := make(Vector, size)
		for i := range v {
			v[i].B0.A0 = qMinusOne
			v[i].B0.A1 = qMinusOne
			v[i].B1.A0 = qMinusOne
			v[i].B1.A1 = qMinusOne
		}
		return gopter.NewGenResult(v, gopter.NoShrinker)
	}
}

func genVector(size int) gopter.Gen {
	return func(genParams *gopter.GenParameters) *gopter.GenResult {
		v := make(Vector, size)
		gen := genE4()
		for i := range v {
			val, ok := gen(genParams).Retrieve()
			if !ok {
				panic("genE4 failed")
			}
			v[i] = val.(E4)
		}
		return gopter.NewGenResult(v, gopter.NoShrinker)
	}
}

// genE4 generates an E4 element
func genE4() gopter.Gen {
	return gopter.CombineGens(
		genE2(),
		genE2(),
	).Map(func(values []interface{}) E4 {
		return E4{B0: values[0].(E2), B1: values[1].(E2)}
	})
}

func genFrVector(size int) gopter.Gen {
	return func(genParams *gopter.GenParameters) *gopter.GenResult {
		v := make(fr.Vector, size)
		gen := genFr()
		for i := range v {
			val, ok := gen(genParams).Retrieve()
			if !ok {
				panic("genFr failed")
			}
			v[i] = val.(fr.Element)
		}
		return gopter.NewGenResult(v, gopter.NoShrinker)
	}
}
