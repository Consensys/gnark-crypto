// Copyright 2020-2025 Consensys Software Inc.
// Licensed under the Apache License, Version 2.0. See the LICENSE file for details.

// Code generated by consensys/gnark-crypto DO NOT EDIT

package extensions

import (
	fr "github.com/consensys/gnark-crypto/field/babybear"
	"github.com/consensys/gnark-crypto/utils/cpu"
)

// Vector represents a vector of E4 elements
type Vector []E4

func (vector *Vector) Add(a, b Vector) {
	if len(a) != len(b) || len(a) != len(*vector) {
		panic("vector.Add: vectors don't have the same length")
	}

	for i := range a {
		(*vector)[i].Add(&a[i], &b[i])
	}
}

func (vector *Vector) AddMixed(a Vector, b fr.Vector) {
	if len(a) != len(b) || len(a) != len(*vector) {
		panic("vector.AddMixed: vectors don't have the same length")
	}
	for i := range a {
		(*vector)[i].Set(&a[i])
		(*vector)[i].B0.A0.Add(&(*vector)[i].B0.A0, &b[i])
	}
}

func (vector *Vector) ScalarMul(a Vector, b *E4) {
	if len(a) != len(*vector) {
		panic("vector.ScalarMul: vectors don't have the same length")
	}

	for i := range a {
		(*vector)[i].Mul(&a[i], b)
	}
}

func (vector *Vector) Sub(a, b Vector) {
	if len(a) != len(b) || len(a) != len(*vector) {
		panic("vector.Sub: vectors don't have the same length")
	}

	for i := range a {
		(*vector)[i].Sub(&a[i], &b[i])
	}
}

func (vector *Vector) SubMixed(a Vector, b fr.Vector) {
	if len(a) != len(b) || len(a) != len(*vector) {
		panic("vector.SubMixed: vectors don't have the same length")
	}
	for i := range a {
		(*vector)[i].Set(&a[i])
		(*vector)[i].B0.A0.Sub(&(*vector)[i].B0.A0, &b[i])
	}
}

func (vector *Vector) Mul(a, b Vector) {
	if len(a) != len(b) || len(a) != len(*vector) {
		panic("vector.Mul: vectors don't have the same length")
	}

	for i := range a {
		(*vector)[i].Mul(&a[i], &b[i])
	}
}

func (vector *Vector) MulMixed(a Vector, b fr.Vector) {
	if len(a) != len(b) || len(a) != len(*vector) {
		panic("vector.MulMixed: vectors don't have the same length")
	}
	for i := range a {
		(*vector)[i].Set(&a[i])
		(*vector)[i].MulByElement(&(*vector)[i], &b[i])
	}
}

func (vector *Vector) MulAcc(scale []fr.Element, alpha *E4) {
	N := len(*vector)
	if N != len(scale) {
		panic("MulAccE4: len(res) != len(scale)")
	}
	if !cpu.SupportAVX512 || N%4 != 0 {
		var tmp E4
		for i := 0; i < N; i++ {
			tmp.MulByElement(alpha, &scale[i])
			(*vector)[i].Add(&(*vector)[i], &tmp)
		}
		return
	}

	mulAccE4_avx512(alpha, &scale[0], &(*vector)[0], uint64(N))
}
