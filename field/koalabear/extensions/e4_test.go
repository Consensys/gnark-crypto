// Copyright 2020-2025 Consensys Software Inc.
// Licensed under the Apache License, Version 2.0. See the LICENSE file for details.

// Code generated by consensys/gnark-crypto DO NOT EDIT

package extensions

import (
	"github.com/leanovate/gopter"
	"github.com/leanovate/gopter/prop"
	"os"
	"testing"

	"fmt"
	fr "github.com/consensys/gnark-crypto/field/koalabear"
)

// ------------------------------------------------------------
// tests

func TestE4ReceiverIsOperand(t *testing.T) {

	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100

	properties := gopter.NewProperties(parameters)

	genA := GenE4()
	genB := GenE4()

	properties.Property("[koalabear] Having the receiver as operand (addition) should output the same result", prop.ForAll(
		func(a, b *E4) bool {
			var c, d E4
			d.Set(a)
			c.Add(a, b)
			a.Add(a, b)
			b.Add(&d, b)
			return a.Equal(b) && a.Equal(&c) && b.Equal(&c)
		},
		genA,
		genB,
	))

	properties.Property("[koalabear] Having the receiver as operand (sub) should output the same result", prop.ForAll(
		func(a, b *E4) bool {
			var c, d E4
			d.Set(a)
			c.Sub(a, b)
			a.Sub(a, b)
			b.Sub(&d, b)
			return a.Equal(b) && a.Equal(&c) && b.Equal(&c)
		},
		genA,
		genB,
	))

	properties.Property("[koalabear] Having the receiver as operand (mul) should output the same result", prop.ForAll(
		func(a, b *E4) bool {
			var c, d E4
			d.Set(a)
			c.Mul(a, b)
			a.Mul(a, b)
			b.Mul(&d, b)
			return a.Equal(b) && a.Equal(&c) && b.Equal(&c)
		},
		genA,
		genB,
	))

	properties.Property("[koalabear] Having the receiver as operand (square) should output the same result", prop.ForAll(
		func(a *E4) bool {
			var b E4
			b.Square(a)
			a.Square(a)
			return a.Equal(&b)
		},
		genA,
	))

	properties.Property("[koalabear] Having the receiver as operand (double) should output the same result", prop.ForAll(
		func(a *E4) bool {
			var b E4
			b.Double(a)
			a.Double(a)
			return a.Equal(&b)
		},
		genA,
	))

	properties.Property("[koalabear] Having the receiver as operand (mul by non residue) should output the same result", prop.ForAll(
		func(a *E4) bool {
			var b E4
			b.MulByNonResidue(a)
			a.MulByNonResidue(a)
			return a.Equal(&b)
		},
		genA,
	))

	properties.Property("[koalabear] Having the receiver as operand (Inverse) should output the same result", prop.ForAll(
		func(a *E4) bool {
			var b E4
			b.Inverse(a)
			a.Inverse(a)
			return a.Equal(&b)
		},
		genA,
	))

	properties.Property("[koalabear] Having the receiver as operand (Conjugate) should output the same result", prop.ForAll(
		func(a *E4) bool {
			var b E4
			b.Conjugate(a)
			a.Conjugate(a)
			return a.Equal(&b)
		},
		genA,
	))

	properties.Property("[koalabear] Having the receiver as operand (Sqrt) should output the same result", prop.ForAll(
		func(a *E4) bool {
			var b, c, d, s E4

			s.Square(a)
			a.Set(&s)
			b.Set(&s)

			a.Sqrt(a)
			b.Sqrt(&b)

			c.Square(a)
			d.Square(&b)
			return c.Equal(&d)
		},
		genA,
	))

	properties.TestingRun(t, gopter.ConsoleReporter(false))
}

func TestE4Ops(t *testing.T) {

	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100

	properties := gopter.NewProperties(parameters)

	genA := GenE4()
	genB := GenE4()

	properties.Property("[koalabear] sub & add should leave an element invariant", prop.ForAll(
		func(a, b *E4) bool {
			var c E4
			c.Set(a)
			c.Add(&c, b).Sub(&c, b)
			return c.Equal(a)
		},
		genA,
		genB,
	))

	properties.Property("[koalabear] mul & inverse should leave an element invariant", prop.ForAll(
		func(a, b *E4) bool {
			var c, d E4
			d.Inverse(b)
			c.Set(a)
			c.Mul(&c, b).Mul(&c, &d)
			return c.Equal(a)
		},
		genA,
		genB,
	))

	properties.Property("[koalabear] BatchInvertE4 should output the same result as Inverse", prop.ForAll(
		func(a, b, c *E4) bool {

			batch := BatchInvertE4([]E4{*a, *b, *c})
			a.Inverse(a)
			b.Inverse(b)
			c.Inverse(c)
			return a.Equal(&batch[0]) && b.Equal(&batch[1]) && c.Equal(&batch[2])
		},
		genA,
		genA,
		genB,
	))

	properties.Property("[koalabear] inverse twice should leave an element invariant", prop.ForAll(
		func(a *E4) bool {
			var b E4
			b.Inverse(a).Inverse(&b)
			return a.Equal(&b)
		},
		genA,
	))

	properties.Property("[koalabear] square and mul should output the same result", prop.ForAll(
		func(a *E4) bool {
			var b, c E4
			b.Mul(a, a)
			c.Square(a)
			return b.Equal(&c)
		},
		genA,
	))

	properties.Property("[koalabear] Legendre on square should output 1", prop.ForAll(
		func(a *E4) bool {
			var b E4
			b.Square(a)
			c := b.Legendre()
			return c == 1
		},
		genA,
	))

	properties.Property("[koalabear] square(sqrt) should leave an element invariant", prop.ForAll(
		func(a *E4) bool {
			var b, c, d, e E4
			b.Square(a)
			c.Sqrt(&b)
			d.Square(&c)
			e.Neg(a)
			return (c.Equal(a) || c.Equal(&e)) && d.Equal(&b)
		},
		genA,
	))

	properties.TestingRun(t, gopter.ConsoleReporter(false))
}

// TODO @gbotrel keeping for debug.
// // test func vectorGather_avx512(res *fr.Element, a, b *E4)
// func TestGatherAVX(t *testing.T) {
// 	// we have a, b, vectors of 16 E4 each.
// 	// res should hold the 16*4 uint32, but transposed.
// 	var a, b [16]E4

// 	// set deterministic values for a and b
// 	for i := 0; i < 16; i++ {
// 		s := i * 4
// 		a[i].B0.A0.SetUint64(uint64(s))
// 		a[i].B0.A1.SetUint64(uint64(s + 1))
// 		a[i].B1.A0.SetUint64(uint64(s + 2))
// 		a[i].B1.A1.SetUint64(uint64(s + 3))
// 	}

// 	// same for b, but we do s= i * 4 * 16
// 	for i := 0; i < 16; i++ {
// 		s := i * 4 * 16
// 		b[i].B0.A0.SetUint64(uint64(s))
// 		b[i].B0.A1.SetUint64(uint64(s + 1))
// 		b[i].B1.A0.SetUint64(uint64(s + 2))
// 		b[i].B1.A1.SetUint64(uint64(s + 3))
// 	}

// 	var res [16 * 8]fr.Element
// 	vectorGather_avx512(&res[0], &a[0], &b[0])

// 	// we should have
// 	zmm0 := res[0:16]
// 	zmm1 := res[16:32]
// 	zmm2 := res[32:48]
// 	zmm3 := res[48:64]
// 	zmm4 := res[64:80]
// 	zmm5 := res[80:96]
// 	zmm6 := res[96:112]
// 	zmm7 := res[112:128]

// 	// zmm0[0] == a[0].B0.A0, zmm0[1] = a[1].B0.A0, ...
// 	// zmm1[0] == a[0].B0.A1, zmm1[1] = a[1].B0.A1, ...

// 	assert := require.New(t)
// 	for i := 0; i < 16; i++ {
// 		assert.Equal(zmm0[i], a[i].B0.A0)
// 		assert.Equal(zmm1[i], a[i].B0.A1)
// 		assert.Equal(zmm2[i], a[i].B1.A0)
// 		assert.Equal(zmm3[i], a[i].B1.A1)
// 		assert.Equal(zmm4[i], b[i].B0.A0)
// 		assert.Equal(zmm5[i], b[i].B0.A1)
// 		assert.Equal(zmm6[i], b[i].B1.A0)
// 		assert.Equal(zmm7[i], b[i].B1.A1)
// 	}

// 	// now let's scatter it again
// 	aReconstructed := make([]E4, 16)
// 	vectorScatter_avx512(&res[0], &aReconstructed[0])

// 	// check that aReconstructed match a
// 	for i := 0; i < 16; i++ {
// 		assert.Equal(aReconstructed[i], a[i])
// 	}

// }

func TestVectorOps(t *testing.T) {
	parameters := gopter.DefaultTestParameters()
	if testing.Short() {
		parameters.MinSuccessfulTests = 2
	} else {
		parameters.MinSuccessfulTests = 10
	}
	properties := gopter.NewProperties(parameters)

	addVector := func(a, b Vector) bool {
		c := make(Vector, len(a))
		c.Add(a, b)

		for i := 0; i < len(a); i++ {
			var tmp E4
			tmp.Add(&a[i], &b[i])
			if !tmp.Equal(&c[i]) {
				return false
			}
		}
		return true
	}

	subVector := func(a, b Vector) bool {
		c := make(Vector, len(a))
		c.Sub(a, b)

		for i := 0; i < len(a); i++ {
			var tmp E4
			tmp.Sub(&a[i], &b[i])
			if !tmp.Equal(&c[i]) {
				return false
			}
		}
		return true
	}

	scalarMulVector := func(a Vector, b *E4) bool {
		c := make(Vector, len(a))
		c.ScalarMul(a, b)

		for i := 0; i < len(a); i++ {
			var tmp E4
			tmp.Mul(&a[i], b)
			if !tmp.Equal(&c[i]) {
				return false
			}
		}
		return true
	}

	sumVector := func(a Vector) bool {
		var sum E4
		computed := a.Sum()
		for i := 0; i < len(a); i++ {
			sum.Add(&sum, &a[i])
		}

		return sum.Equal(&computed)
	}

	innerProductVector := func(a, b Vector) bool {
		computed := a.InnerProduct(b)
		var innerProduct E4
		for i := 0; i < len(a); i++ {
			var tmp E4
			tmp.Mul(&a[i], &b[i])
			innerProduct.Add(&innerProduct, &tmp)
		}

		return innerProduct.Equal(&computed)
	}

	mulVector := func(a, b Vector) bool {
		c := make(Vector, len(a))
		a[0].B0.A0.SetUint64(0x24)
		b[0].B0.A0.SetUint64(0x42)
		c.Mul(a, b)

		for i := 0; i < len(a); i++ {
			var tmp E4
			tmp.Mul(&a[i], &b[i])
			if !tmp.Equal(&c[i]) {
				return false
			}
		}
		return true
	}

	sizes := []int{1, 2, 3, 4, 8, 9, 15, 16, 24, 32, 509, 510, 511, 512, 513, 514}
	type genPair struct {
		g1, g2 gopter.Gen
		label  string
	}

	for _, size := range sizes {
		generators := []genPair{
			{genZeroVector(size), genZeroVector(size), "zero vectors"},
			{genMaxVector(size), genMaxVector(size), "max vectors"},
			{genVector(size), genVector(size), "random vectors"},
			{genVector(size), genZeroVector(size), "random and zero vectors"},
		}
		for _, gp := range generators {
			properties.Property(fmt.Sprintf("vector addition %d - %s", size, gp.label), prop.ForAll(
				addVector,
				gp.g1,
				gp.g2,
			))

			properties.Property(fmt.Sprintf("vector subtraction %d - %s", size, gp.label), prop.ForAll(
				subVector,
				gp.g1,
				gp.g2,
			))

			properties.Property(fmt.Sprintf("vector scalar multiplication %d - %s", size, gp.label), prop.ForAll(
				scalarMulVector,
				gp.g1,
				GenE4(),
			))

			properties.Property(fmt.Sprintf("vector sum %d - %s", size, gp.label), prop.ForAll(
				sumVector,
				gp.g1,
			))

			properties.Property(fmt.Sprintf("vector inner product %d - %s", size, gp.label), prop.ForAll(
				innerProductVector,
				gp.g1,
				gp.g2,
			))

			properties.Property(fmt.Sprintf("vector multiplication %d - %s", size, gp.label), prop.ForAll(
				mulVector,
				gp.g1,
				gp.g2,
			))
		}
	}

	properties.TestingRun(t, gopter.NewFormatedReporter(false, 260, os.Stdout))
}

// ------------------------------------------------------------
// benches

func BenchmarkE4Add(b *testing.B) {
	var a, c E4
	a.MustSetRandom()
	c.MustSetRandom()
	b.ResetTimer()
	for i := 0; i < b.N; i++ {
		a.Add(&a, &c)
	}
}

func BenchmarkE4Sub(b *testing.B) {
	var a, c E4
	a.MustSetRandom()
	c.MustSetRandom()
	b.ResetTimer()
	for i := 0; i < b.N; i++ {
		a.Sub(&a, &c)
	}
}

func BenchmarkE4Mul(b *testing.B) {
	var a, c E4
	a.MustSetRandom()
	c.MustSetRandom()
	b.ResetTimer()
	for i := 0; i < b.N; i++ {
		a.Mul(&a, &c)
	}
}

func BenchmarkE4MulByElement(b *testing.B) {
	var a E4
	var c fr.Element
	_, _ = a.SetRandom()
	_, _ = c.SetRandom()
	b.ResetTimer()
	for i := 0; i < b.N; i++ {
		a.MulByElement(&a, &c)
	}
}

func BenchmarkE4Square(b *testing.B) {
	var a E4
	a.MustSetRandom()
	b.ResetTimer()
	for i := 0; i < b.N; i++ {
		a.Square(&a)
	}
}

func BenchmarkE4Sqrt(b *testing.B) {
	var a E4
	a.MustSetRandom()
	b.ResetTimer()
	for i := 0; i < b.N; i++ {
		a.Sqrt(&a)
	}
}

func BenchmarkE4Inverse(b *testing.B) {
	var a E4
	a.MustSetRandom()
	b.ResetTimer()
	for i := 0; i < b.N; i++ {
		a.Inverse(&a)
	}
}

func BenchmarkE4MulNonRes(b *testing.B) {
	var a E4
	a.MustSetRandom()
	b.ResetTimer()
	for i := 0; i < b.N; i++ {
		a.MulByNonResidue(&a)
	}
}

func BenchmarkE4Conjugate(b *testing.B) {
	var a E4
	a.MustSetRandom()
	b.ResetTimer()
	for i := 0; i < b.N; i++ {
		a.Conjugate(&a)
	}
}

func BenchmarkVectorOps(b *testing.B) {
	// note; to benchmark against "no asm" version, use the following
	// build tag: -tags purego
	const N = 1 << 20
	a1 := make(Vector, N)
	b1 := make(Vector, N)
	c1 := make(Vector, N)
	for i := 1; i < N; i++ {
		a1[i-1].MustSetRandom()
		b1[i-1].MustSetRandom()
	}

	for n := 4; n <= N; n <<= 1 {
		b.Run(fmt.Sprintf("add %d", n), func(b *testing.B) {
			_a := a1[:n]
			_b := b1[:n]
			_c := c1[:n]
			b.ResetTimer()
			for i := 0; i < b.N; i++ {
				_c.Add(_a, _b)
			}
		})

		b.Run(fmt.Sprintf("sub %d", n), func(b *testing.B) {
			_a := a1[:n]
			_b := b1[:n]
			_c := c1[:n]
			b.ResetTimer()
			for i := 0; i < b.N; i++ {
				_c.Sub(_a, _b)
			}
		})

		b.Run(fmt.Sprintf("scalarMul %d", n), func(b *testing.B) {
			_a := a1[:n]
			_c := c1[:n]
			b.ResetTimer()
			for i := 0; i < b.N; i++ {
				_c.ScalarMul(_a, &b1[0])
			}
		})

		b.Run(fmt.Sprintf("sum %d", n), func(b *testing.B) {
			_a := a1[:n]
			b.ResetTimer()
			for i := 0; i < b.N; i++ {
				_ = _a.Sum()
			}
		})

		b.Run(fmt.Sprintf("innerProduct %d", n), func(b *testing.B) {
			_a := a1[:n]
			_b := b1[:n]
			b.ResetTimer()
			for i := 0; i < b.N; i++ {
				_ = _a.InnerProduct(_b)
			}
		})

		b.Run(fmt.Sprintf("mul %d", n), func(b *testing.B) {
			_a := a1[:n]
			_b := b1[:n]
			_c := c1[:n]
			b.ResetTimer()
			for i := 0; i < b.N; i++ {
				_c.Mul(_a, _b)
			}
		})
	}
}

func genZeroVector(size int) gopter.Gen {
	return func(genParams *gopter.GenParameters) *gopter.GenResult {
		g := make(Vector, size)
		genResult := gopter.NewGenResult(g, gopter.NoShrinker)
		return genResult
	}
}

func genMaxVector(size int) gopter.Gen {
	return func(genParams *gopter.GenParameters) *gopter.GenResult {
		g := make(Vector, size)

		qMinusOne := fr.Element{2130706433}
		qMinusOne[0]--

		for i := 0; i < size; i++ {
			g[i].B0.A0 = qMinusOne
			g[i].B0.A1 = qMinusOne
			g[i].B1.A0 = qMinusOne
			g[i].B1.A1 = qMinusOne
		}
		genResult := gopter.NewGenResult(g, gopter.NoShrinker)
		return genResult
	}
}

func genVector(size int) gopter.Gen {
	return func(genParams *gopter.GenParameters) *gopter.GenResult {
		vec := make(Vector, size)
		for i := 0; i < size; i++ {
			e4Gen := GenE4()
			genRes := e4Gen(genParams)
			val, ok := genRes.Retrieve()
			if !ok {
				return gopter.NewGenResult(vec, gopter.NoShrinker)
			}
			vec[i] = *val.(*E4)
		}
		return gopter.NewGenResult(vec, gopter.NoShrinker)
	}
}
