// Copyright 2020-2025 Consensys Software Inc.
// Licensed under the Apache License, Version 2.0. See the LICENSE file for details.

// Code generated by consensys/gnark-crypto DO NOT EDIT

package extensions

import (
	"math/big"

	fr "github.com/consensys/gnark-crypto/field/koalabear"
)

// E4D is a degree two finite field extension of fr2
type E4D struct {
	A0, A1, A2, A3 fr.Element
}

// Equal returns true if z equals x, false otherwise
func (z *E4D) Equal(x *E4D) bool {
	return z.A0.Equal(&x.A0) && z.A1.Equal(&x.A1) && z.A2.Equal(&x.A2) && z.A3.Equal(&x.A3)
}

// SetString sets a E4D element from strings
func (z *E4D) SetString(s1, s2, s3, s4 string) *E4D {
	z.A0.SetString(s1)
	z.A1.SetString(s2)
	z.A2.SetString(s3)
	z.A3.SetString(s4)
	return z
}

// SetZero sets an E4D elmt to zero
func (z *E4D) SetZero() *E4D {
	z.A0.SetZero()
	z.A1.SetZero()
	z.A2.SetZero()
	z.A3.SetZero()
	return z
}

// Set sets an E4D from x
func (z *E4D) Set(x *E4D) *E4D {
	z.A0 = x.A0
	z.A1 = x.A1
	z.A2 = x.A2
	z.A3 = x.A3
	return z
}

// SetOne sets z to 1 in Montgomery form and returns z
func (z *E4D) SetOne() *E4D {
	z.A0.SetOne()
	z.A1.SetZero()
	z.A2.SetZero()
	z.A3.SetZero()
	return z
}

// SetRandom sets a0 and a1 to random values
func (z *E4D) SetRandom() (*E4D, error) {
	if _, err := z.A0.SetRandom(); err != nil {
		return nil, err
	}
	if _, err := z.A1.SetRandom(); err != nil {
		return nil, err
	}
	if _, err := z.A2.SetRandom(); err != nil {
		return nil, err
	}
	if _, err := z.A3.SetRandom(); err != nil {
		return nil, err
	}
	return z, nil
}

// IsZero returns true if z is zero, false otherwise
func (z *E4D) IsZero() bool {
	return z.A0.IsZero() && z.A1.IsZero() && z.A2.IsZero() && z.A3.IsZero()
}

// IsOne returns true if z is one, false otherwise
func (z *E4D) IsOne() bool {
	return z.A0.IsOne() && z.A1.IsZero() && z.A2.IsZero() && z.A3.IsZero()
}

// Add adds two elements of E4D
func (z *E4D) Add(x, y *E4D) *E4D {
	z.A0.Add(&x.A0, &y.A0)
	z.A1.Add(&x.A1, &y.A1)
	z.A2.Add(&x.A2, &y.A2)
	z.A3.Add(&x.A3, &y.A3)
	return z
}

// Sub subtracts two elements of E4D
func (z *E4D) Sub(x, y *E4D) *E4D {
	z.A0.Sub(&x.A0, &y.A0)
	z.A1.Sub(&x.A1, &y.A1)
	z.A2.Sub(&x.A2, &y.A2)
	z.A3.Sub(&x.A3, &y.A3)
	return z
}

// Double doubles an E4D element
func (z *E4D) Double(x *E4D) *E4D {
	z.A0.Double(&x.A0)
	z.A1.Double(&x.A1)
	z.A2.Double(&x.A2)
	z.A3.Double(&x.A3)
	return z
}

// Neg negates an E4D element
func (z *E4D) Neg(x *E4D) *E4D {
	z.A0.Neg(&x.A0)
	z.A1.Neg(&x.A1)
	z.A2.Neg(&x.A2)
	z.A3.Neg(&x.A3)
	return z
}

// String implements Stringer interface for fancy printing
func (z *E4D) String() string {
	return z.A0.String() + "+" + z.A1.String() + "*u+" + z.A2.String() + "*u^2+" + z.A3.String() + "*u^3"
}

// MulByElement multiplies an element in E4D by an element in fr
func (z *E4D) MulByElement(x *E4D, y *fr.Element) *E4D {
	var yCopy fr.Element
	yCopy.Set(y)
	z.A0.Mul(&x.A0, &yCopy)
	z.A1.Mul(&x.A1, &yCopy)
	z.A2.Mul(&x.A2, &yCopy)
	z.A3.Mul(&x.A3, &yCopy)
	return z
}

// Conjugate conjugates an element in E4D
func (z *E4D) Conjugate(x *E4D) *E4D {
	z.A0 = x.A0
	z.A1.Neg(&x.A1)
	z.A2 = x.A2
	z.A3.Neg(&x.A3)
	return z
}

// Halve sets z to z / 2
func (z *E4D) Halve() {
	z.A0.Halve()
	z.A1.Halve()
	z.A2.Halve()
	z.A3.Halve()
}

// Exp sets z=xᵏ (mod q²) and returns it
func (z *E4D) Exp(x E4D, k *big.Int) *E4D {
	if k.IsUint64() && k.Uint64() == 0 {
		return z.SetOne()
	}

	e := k
	if k.Sign() == -1 {
		// negative k, we invert
		// if k < 0: xᵏ (mod q²) == (x⁻¹)ᵏ (mod q²)
		x.Inverse(&x)

		// we negate k in a temp big.Int since
		// Int.Bit(_) of k and -k is different
		e = bigIntPool.Get().(*big.Int)
		defer bigIntPool.Put(e)
		e.Neg(k)
	}

	z.SetOne()
	b := e.Bytes()
	for i := 0; i < len(b); i++ {
		w := b[i]
		for j := 0; j < 8; j++ {
			z.Square(z)
			if (w & (0b10000000 >> j)) != 0 {
				z.Mul(z, &x)
			}
		}
	}

	return z
}

// BatchInvertE4D returns a new slice with every element in a inverted.
// It uses Montgomery batch inversion trick.
//
// if a[i] == 0, returns result[i] = a[i]
func BatchInvertE4D(a []E4D) []E4D {
	res := make([]E4D, len(a))
	if len(a) == 0 {
		return res
	}

	zeroes := make([]bool, len(a))
	var accumulator E4D
	accumulator.SetOne()

	for i := 0; i < len(a); i++ {
		if a[i].IsZero() {
			zeroes[i] = true
			continue
		}
		res[i].Set(&accumulator)
		accumulator.Mul(&accumulator, &a[i])
	}

	accumulator.Inverse(&accumulator)

	for i := len(a) - 1; i >= 0; i-- {
		if zeroes[i] {
			continue
		}
		res[i].Mul(&res[i], &accumulator)
		accumulator.Mul(&accumulator, &a[i])
	}

	return res
}

// Select is conditional move.
// If cond = 0, it sets z to caseZ and returns it. otherwise caseNz.
func (z *E4D) Select(cond int, caseZ *E4D, caseNz *E4D) *E4D {
	//Might be able to save a nanosecond or two by an aggregate implementation

	z.A0.Select(cond, &caseZ.A0, &caseNz.A0)
	z.A1.Select(cond, &caseZ.A1, &caseNz.A1)
	z.A2.Select(cond, &caseZ.A2, &caseNz.A2)
	z.A3.Select(cond, &caseZ.A3, &caseNz.A3)

	return z
}

// Div divides an element in E4D by an element in E4D
func (z *E4D) Div(x *E4D, y *E4D) *E4D {
	var r E4D
	r.Inverse(y).Mul(x, &r)
	return z.Set(&r)
}

// Mul sets z to the E4D-product of x,y, returns z
func (z *E4D) Mul(x, y *E4D) *E4D {
	return z.mulTower(x, y)
}

func (z *E4D) mulTower(x, y *E4D) *E4D {
	_x := ToTower(x)
	_y := ToTower(y)
	_x.Mul(_x, _y)
	_z := FromTower(_x)
	return z.Set(_z)
}

// Square sets z to the E4D-product of x,x returns z
func (z *E4D) Square(x *E4D) *E4D {
	return z.squareTower(x)
}

func (z *E4D) squareTower(x *E4D) *E4D {
	_x := ToTower(x)
	_x.Square(_x)
	_z := FromTower(_x)
	return z.Set(_z)
}

// Inverse sets z to the E4D-inverse of x, returns z
//
// if x == 0, sets and returns z = x
func (z *E4D) Inverse(x *E4D) *E4D {
	_x := ToTower(x)
	_x.Inverse(_x)
	_z := FromTower(_x)
	return z.Set(_z)
}

// FromTower
func FromTower(x *E4) *E4D {
	// isomorphism between the quadratic over quadratic extension of Fp, and
	// the direct quartic extension.
	// 		a00 a10 a01 a11
	// 		A0  A1  A2  A3
	var z E4D
	z.A0.Set(&x.B0.A0)
	z.A1.Set(&x.B1.A0)
	z.A2.Set(&x.B0.A1)
	z.A3.Set(&x.B1.A1)
	return &z
}

// ToTower
func ToTower(x *E4D) *E4 {
	// isomorphism between the quadratic over quadratic extension of Fp, and
	// the direct quartic extension.
	// 		a00 a10 a01 a11
	// 		A0  A1  A2  A3
	var z E4
	z.B0.A0.Set(&x.A0)
	z.B1.A0.Set(&x.A1)
	z.B0.A1.Set(&x.A2)
	z.B1.A1.Set(&x.A3)
	return &z
}
