// SPDX-License-Identifier: Apache-2.0

// Copyright 2023 Consensys Software Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Code generated by gnark DO NOT EDIT

pragma solidity ^0.8.0;

contract Poseidon2 {

  uint32 private constant R_MOD = 2130706433;
  uint256 private constant WORD_MOD = 4294967296; // 2**32
  
  // poseidon2 params (vortex on koalabear)
  uint32 private constant WIDTH = 16;
  uint32 private constant NB_FULL_ROUNDS = 6;
  uint32 private constant NB_PARTIAL_ROUNDS = 21;

  // precompile
  uint8 private constant MOD_EXP = 0x5;

  uint256 private constant ERROR_STRING_ID = 0x08c379a000000000000000000000000000000000000000000000000000000000; // selector for function Error(string)

  event PrintUint32(uint32 res);
  event PrintUint256(uint256 res);

  /// Hash
  function Hash() public returns(bool success) {

    uint32[] memory input = new uint32[](8);
    input[0] = 0x10;
    input[1] = 0x11;
    input[2] = 0x12;
    input[3] = 0x13;
    input[4] = 0x14;
    input[5] = 0x15;
    input[6] = 0x16;
    input[7] = 0x17;

    // uint256 z = 431359146781120966242552843855944128473473360879759082526070001369111;

    uint256 check;

    // params vortex t=16, rf=6, rp=21
    assembly {

      // permutation x = [16]koalabear
      let mPtr := mload(0x40)

      let a0 := 111323
	    let a1 := 3789269
	    let a2 := 23980
	    let a3 := 98723

      a0, a1, a2, a3 := matMulM4(a0, a1, a2, a3)

      check := a3

      /// matMulM4 computes
      /// s <- diag_4(M4)*s
      /// where M4=
      /// (2 3 1 1)
      /// (1 2 3 1)
      /// (1 1 2 3)
      /// (3 1 1 2)
      /// on chunks of 4 elemts on each part of the buffer
      /// for the addition chain, see:
      /// https://github.com/Plonky3/Plonky3/blob/f91c76545cf5c4ae9182897bcc557715817bcbdc/poseidon2/src/external.rs#L43
      /// this MDS matrix is more efficient than
      /// https://eprint.iacr.org/2023/323.pdf appendix Bb
      /// @param ptr pointer to 2 uint256 elements, interpreted as 16 uint32 elements
      /// the result is stored in ptr.
      function mathMulM4InPlace(ptr) {

        let a := mload(ptr)
        let s0 := ithChunk(a, 0)
        let s1 := ithChunk(a, 1)
        let s2 := ithChunk(a, 2)
        let s3 := ithChunk(a, 3)
        let s4 := ithChunk(a, 4)
        let s5 := ithChunk(a, 5)
        let s6 := ithChunk(a, 6)
        let s7 := ithChunk(a, 7)

        a := mload(add(ptr, 0x20))
        s0 := ithChunk(a, 0)
        s1 := ithChunk(a, 1)
        s2 := ithChunk(a, 2)
        s3 := ithChunk(a, 3)
        s4 := ithChunk(a, 4)
        s5 := ithChunk(a, 5)
        s6 := ithChunk(a, 6)
        s7 := ithChunk(a, 7)

      }

      /// computes M4*[a, b , c, d]
      /// where M4=
      /// (2 3 1 1)
      /// (1 2 3 1)
      /// (1 1 2 3)
      /// (3 1 1 2)
      function matMulM4(a, b, c, d)->u,v,w,x {
        
        let t01, t23, t0123, t01123, t01233
        
        t01 := addmod(a, b, R_MOD)
        t23 := addmod(c, d, R_MOD)
        t0123 := addmod(t01, t23, R_MOD)
        t01123 := addmod(t0123, b, R_MOD)
        t01233 := addmod(t0123, d, R_MOD)

        d := addmod(a, a, R_MOD)
        d := addmod(d, t01233, R_MOD)
        b := addmod(c, c, R_MOD)
        b := addmod(b, t01123, R_MOD)
        a := addmod(t01, t01123, R_MOD)
        c := addmod(t23, t01233, R_MOD)

        u := a
        v := b
        w := c
        x := d
      }

      // query i-th 32bits chunk of a uint256 number N.
      // The 8-th chunk corresponds to the LSB of N,
      // the 0-th chunk corresponds to the MSB of N.
      function ithChunk(n, i)->m {
        m := shr(mul(sub(7,i), 32), n)
        m := mod(m, WORD_MOD)
      }

      // sbox
      function sbox(x)->res {
        let tmp := mulmod(x, x, R_MOD)
        res := mulmod(tmp, x, R_MOD)
      }

    }

    emit PrintUint256(check);
    // emit PrintUint32(input[0]);

    success = true;
  }
}
