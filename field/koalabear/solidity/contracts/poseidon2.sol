// SPDX-License-Identifier: Apache-2.0

// Copyright 2023 Consensys Software Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Code generated by gnark DO NOT EDIT

pragma solidity ^0.8.0;

contract Poseidon2 {

  uint32 private constant R_MOD = 2130706433;
  uint256 private constant WORD_MOD = 4294967296; // 2**32

  // precompile
  uint8 private constant MOD_EXP = 0x5;

  uint256 private constant ERROR_STRING_ID = 0x08c379a000000000000000000000000000000000000000000000000000000000; // selector for function Error(string)

  event PrintUint32(uint32 res);
  event PrintUint256(uint256 res);

  // round keys
  uint256 private constant RK_0_0 = 52691802021506155758914962750280372212207119203515444126415105344946620971042;
  uint256 private constant RK_0_1 = 32207471970256316655474490955553459742787419335289228299095903266455798739660;
  uint256 private constant RK_1_0 = 22163791677048831312463448776400028385347383911100916908889018061663075177430;
  uint256 private constant RK_1_1 = 52176870515245694198691020358647906763460864198395806999480367588806463375956;
  uint256 private constant RK_2_0 = 20057732892593326318373784289292844513497509146673516636435948826170767804894;
  uint256 private constant RK_2_1 = 18178750968836063378915279115560606579387492034215281114134869585318875352069;
  uint256 private constant RK_3 = 271263440;
  uint256 private constant RK_4 = 648183298;
  uint256 private constant RK_5 = 1662653166;
  uint256 private constant RK_6 = 1984135584;
  uint256 private constant RK_7 = 594964655;
  uint256 private constant RK_8 = 108023522;
  uint256 private constant RK_9 = 849546096;
  uint256 private constant RK_10 = 1961993938;
  uint256 private constant RK_11 = 1546336947;
  uint256 private constant RK_12 = 1036613726;
  uint256 private constant RK_13 = 452088758;
  uint256 private constant RK_14 = 275827416;
  uint256 private constant RK_15 = 763236035;
  uint256 private constant RK_16 = 1068717067;
  uint256 private constant RK_17 = 1580958419;
  uint256 private constant RK_18 = 1376393748;
  uint256 private constant RK_19 = 892777736;
  uint256 private constant RK_20 = 1345121022;
  uint256 private constant RK_21 = 908739241;
  uint256 private constant RK_22 = 908871000;
  uint256 private constant RK_23 = 1053550888;
  uint256 private constant RK_24_0 = 7748602703960850726417234176553190502144764796409545305676706613632081374108;
  uint256 private constant RK_24_1 = 14236178139181542176197168604443439317755831764127965411495610808590768539130;
  uint256 private constant RK_25_0 = 4390545490380878999875851257118004037103299792992754784803412502652715488373;
  uint256 private constant RK_25_1 = 15895992674755709583772916119416271803214403026810424648839392700430632374893;
  uint256 private constant RK_26_0 = 37373517675827041221658956101645979913006475784844873469590649853964048342988;
  uint256 private constant RK_26_1 = 46010512812451809471058691124553676654818408969360806522307687423952321374687;

  /// Hash
  function Hash() public returns(bool success) {

    uint256 aa = 431359146781120966242552843855944128473473360879759082526070001369111;
    // uint256 bb = 431359146781120966242552843855944128473473360879759082526070001369111;

    uint256 check;

    // params vortex t=16, rf=6, rp=21
    assembly {

      // permutation x = [16]koalabear
      // aa, bb := matMulExternalInPlace(aa, bb)

      check := sboxUint256(aa)
      check := ithChunk(check, 7)

      /// interpret ptr as a sequence of 16 uint32 elmts and sums them
      function computeSum(a, b)->s {
        for {let i} lt(i, 8) {i:=add(i,1)} 
        {
          s := addmod(s, ithChunk(a, i), R_MOD)
          s := addmod(s, ithChunk(b, i), R_MOD)
        }
      }

      function matMulInternalInPlace(a, b)->ra,rb {
        let s := computeSum(a, b)
        ra := matMulInternalInPlaceFirstHalf(a, s)
        rb := matMulInternalInPlaceSecondHalf(b, s)
      }

      function matMulInternalInPlaceFirstHalf(a, sum)->ma {
        
        let t0, t1, t2, t3, t4, t5, t6, t7

        t0 := addmod(sum, sub(R_MOD, mulmod(ithChunk(a, 0), 2, R_MOD)), R_MOD)
        t1 := addmod(sum, ithChunk(a, 1), R_MOD)
        t2 := ithChunk(a, 2)
        t2 := addmod(sum, addmod(t2, t2, R_MOD), R_MOD)
        t3 := addmod(sum, mulmod(ithChunk(a, 3), 1065353217, R_MOD), R_MOD) // 1065353217 -> 1/2
        t4 := addmod(sum, mulmod(ithChunk(a, 4), 3, R_MOD), R_MOD)
        t5 := addmod(sum, mulmod(ithChunk(a, 5), 4, R_MOD), R_MOD)
        t6 := addmod(sum, mulmod(ithChunk(a, 6), 1065353216, R_MOD), R_MOD) // 1065353216 -> -1/2
        t7 := addmod(sum, sub(R_MOD, mulmod(ithChunk(a, 7), 3, R_MOD)), R_MOD)
        ma := packToUint256(t0, t1, t2, t3, t4, t5, t6, t7)

      } 

       function matMulInternalInPlaceSecondHalf(b, sum)->mb {
        
        let t0, t1, t2, t3, t4, t5, t6, t7

        t0 := addmod(sum, sub(R_MOD, mulmod(ithChunk(b, 0), 4, R_MOD)), R_MOD)
        t1 := addmod(sum, mulmod(ithChunk(b, 1), 2122383361, R_MOD), R_MOD) // 2122383361 -> 1/2^8
        t2 := addmod(sum, mulmod(ithChunk(b, 2),1864368129, R_MOD), R_MOD) // 1864368129 -> 1/8
        t3 := addmod(sum, mulmod(ithChunk(b, 3),2130706306, R_MOD), R_MOD) // 2130706306 -> 1/2^24
        t4 := addmod(sum, mulmod(ithChunk(b, 4),8323072, R_MOD), R_MOD) // 8323072 ->  -1/2^8
        t5 := addmod(sum, mulmod(ithChunk(b, 5),266338304, R_MOD), R_MOD) // 266338304 -> -1/8
        t6 := addmod(sum, mulmod(ithChunk(b, 6),133169152, R_MOD), R_MOD) // 133169152 -> -1/16
        t7 := addmod(sum, mulmod(ithChunk(b, 7),127, R_MOD), R_MOD) // 127 -> -1/2^24
        mb :=  packToUint256(t0, t1, t2, t3, t4, t5, t6, t7)
      } 

      function matMulExternalInPlaceFirstHalf(a, t0, t1, t2, t3)->ra {
        let a0, a1, a2, a3, a4, a5, a6, a7
        a0 := addmod(t0, ithChunk(a, 0), R_MOD)
        a1 := addmod(t1, ithChunk(a, 1), R_MOD)
        a2 := addmod(t2, ithChunk(a, 2), R_MOD)
        a3 := addmod(t3, ithChunk(a, 3), R_MOD)
        a4 := addmod(t0, ithChunk(a, 4), R_MOD)
        a5 := addmod(t1, ithChunk(a, 5), R_MOD)
        a6 := addmod(t2, ithChunk(a, 6), R_MOD)
        a7 := addmod(t3, ithChunk(a, 7), R_MOD)
        ra := packToUint256(a0, a1, a2, a3, a4, a5, a6, a7)
      }

      function matMulExternalInPlaceSecondHalf(b, t0, t1, t2, t3)->rb {
        let a0, a1, a2, a3, a4, a5, a6, a7
        a0 := addmod(t0, ithChunk(b, 0), R_MOD)
        a1 := addmod(t1, ithChunk(b, 1), R_MOD)
        a2 := addmod(t2, ithChunk(b, 2), R_MOD)
        a3 := addmod(t3, ithChunk(b, 3), R_MOD)
        a4 := addmod(t0, ithChunk(b, 4), R_MOD)
        a5 := addmod(t1, ithChunk(b, 5), R_MOD)
        a6 := addmod(t2, ithChunk(b, 6), R_MOD)
        a7 := addmod(t3, ithChunk(b, 7), R_MOD)
        rb := packToUint256(a0, a1, a2, a3, a4, a5, a6, a7)
      }

      /// @param ptr pointer to 2 uint256 elements, We interpret them as 4 packs of 4 uint32 elmts ->
      /// [[a0,a1,a2,a3],..,[a12,a13,a14,a15]]:=[v0,v1,v2,v3]
      /// and we multiply [v0,v1,v2,v3] by circ(2M4,M4,..,M4)
      function matMulExternalInPlace(a, b)->ra, rb {
        
        a := matMulM4uint256(a)
        b := matMulM4uint256(b)
        
        let t0, t1, t2, t3 := sumColumns(a, b)

       ra := matMulExternalInPlaceFirstHalf(a, t0, t1, t2, t3)
       rb := matMulExternalInPlaceFirstHalf(b, t0, t1, t2, t3)
      }

      /// @param ptr pointer to 2 uint256 elements. We interpret them as 4 packs of 4 uint32 elmts ->
      /// [[a0,a1,a2,a3],..,[a12,a13,a14,a15]] and we sum them:
      /// [[a0+a4+a8+a12, .., a3+a7+a11+a15]]
      function sumColumns(a, b)->t0, t1, t2, t3 {
        
        t0 := addmod(t0, ithChunk(a, 0), R_MOD)
        t1 := addmod(t1, ithChunk(a, 1), R_MOD)
        t2 := addmod(t2, ithChunk(a, 2), R_MOD)
        t3 := addmod(t3, ithChunk(a, 3), R_MOD)

        t0 := addmod(t0, ithChunk(a, 4), R_MOD)
        t1 := addmod(t1, ithChunk(a, 5), R_MOD)
        t2 := addmod(t2, ithChunk(a, 6), R_MOD)
        t3 := addmod(t3, ithChunk(a, 7), R_MOD)

        t0 := addmod(t0, ithChunk(b, 0), R_MOD)
        t1 := addmod(t1, ithChunk(b, 1), R_MOD)
        t2 := addmod(t2, ithChunk(b, 2), R_MOD)
        t3 := addmod(t3, ithChunk(b, 3), R_MOD)

        t0 := addmod(t0, ithChunk(b, 4), R_MOD)
        t1 := addmod(t1, ithChunk(b, 5), R_MOD)
        t2 := addmod(t2, ithChunk(b, 6), R_MOD)
        t3 := addmod(t3, ithChunk(b, 7), R_MOD)
      }

      /// matMulM4 computes
      /// s <- diag_4(M4)*s
      /// where M4=
      /// (2 3 1 1)
      /// (1 2 3 1)
      /// (1 1 2 3)
      /// (3 1 1 2)
      /// on chunks of 4 elemts on each part of the buffer
      /// for the addition chain, see:
      /// https://github.com/Plonky3/Plonky3/blob/f91c76545cf5c4ae9182897bcc557715817bcbdc/poseidon2/src/external.rs#L43
      /// this MDS matrix is more efficient than
      /// https://eprint.iacr.org/2023/323.pdf appendix Bb
      /// @param ptr pointer to 2 uint256 elements, interpreted as 4 blocks of 4 uint32 elements
      /// that we multiply by M4. The resut is 4 blocks of 4 uint32 elements, aligned in ptr
      function mathMulM4InPlace(ptr) {
        
        let a := mload(ptr)
        a := matMulM4uint256(a)
        mstore(ptr, a)
        
        a := mload(add(ptr, 0x20))
        a := matMulM4uint256(a)
        mstore(add(ptr, 0x20), a)
      }

      /// matMulM4uint256 splits a:= (c1<<128) || c2 in two chunks c1 c2 of 4 32bits elmts
      /// and computes d1=M4*c1, d2=M4*c2, and returns (d1<<128) || d2
      function matMulM4uint256(a)->b {
        let s0 := ithChunk(a, 0)
        let s1 := ithChunk(a, 1)
        let s2 := ithChunk(a, 2)
        let s3 := ithChunk(a, 3)
        s0, s1, s2, s3 := matMulM4(s0, s1, s2, s3)
        let s4 := ithChunk(a, 4)
        let s5 := ithChunk(a, 5)
        let s6 := ithChunk(a, 6)
        let s7 := ithChunk(a, 7)
        s4, s5, s6, s7 := matMulM4(s4, s5, s6, s7)
        b := packToUint256(s0, s1, s2, s3, s4, s5, s6, s7)
      }

      /// computes M4*[a, b , c, d]
      /// where M4=
      /// (2 3 1 1)
      /// (1 2 3 1)
      /// (1 1 2 3)
      /// (3 1 1 2)
      /// a, b, c, d are uint32 elmts
      function matMulM4(a, b, c, d)->u,v,w,x {
        
        let t01, t23, t0123, t01123, t01233
        
        t01 := addmod(a, b, R_MOD)
        t23 := addmod(c, d, R_MOD)
        t0123 := addmod(t01, t23, R_MOD)
        t01123 := addmod(t0123, b, R_MOD)
        t01233 := addmod(t0123, d, R_MOD)

        d := addmod(a, a, R_MOD)
        d := addmod(d, t01233, R_MOD)
        b := addmod(c, c, R_MOD)
        b := addmod(b, t01123, R_MOD)
        a := addmod(t01, t01123, R_MOD)
        c := addmod(t23, t01233, R_MOD)

        u := a
        v := b
        w := c
        x := d
      }

      /// @return u = a << 224 || b << 192 || .. || h
      function packToUint256(a, b, c, d, e, f, g, h) -> u {
        u := shl(224, a)
        u := add(u, shl(192, b))
        u := add(u, shl(160, c))
        u := add(u, shl(128, d))
        u := add(u, shl(96, e))
        u := add(u, shl(64, f))
        u := add(u, shl(32, g))
        u := add(u, h)
      }

      // query i-th 32bits chunk of a uint256 number N.
      // The 8-th chunk corresponds to the LSB of N,
      // the 0-th chunk corresponds to the MSB of N.
      function ithChunk(n, i)->m {
        m := mod(shr(mul(sub(7,i), 32), n), WORD_MOD)
      }

      // sbox
      function sboxSingleEntry(x)->rx {
        rx := mulmod(x, mulmod(x, x, R_MOD), R_MOD)
      }

      // sbox
      function sboxUint256(x)->rx {
        let tmp := mulmod(x, x, R_MOD)
        let t0, t1, t2, t3, t4, t5, t6, t7
        t0 := sboxSingleEntry(ithChunk(x, 0))
        t1 := sboxSingleEntry(ithChunk(x, 1))
        t2 := sboxSingleEntry(ithChunk(x, 2))
        t3 := sboxSingleEntry(ithChunk(x, 3))
        t4 := sboxSingleEntry(ithChunk(x, 4))
        t5 := sboxSingleEntry(ithChunk(x, 5))
        t6 := sboxSingleEntry(ithChunk(x, 6))
        t7 := sboxSingleEntry(ithChunk(x, 7))
        rx := packToUint256(t0, t1, t2, t3, t4, t5, t6, t7)
      }

      function sboxFirstEntry(x)->rx {
        let tmp := ithChunk(x, 0)
        let t0 := tmp
        tmp := shl(224, tmp)
        rx := sub(x, tmp)
        t0 := sboxSingleEntry(t0)
        rx := add(rx, shl(224, t0))
      }

    }

    emit PrintUint256(check);

    success = true;
  }
}
