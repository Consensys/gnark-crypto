// SPDX-License-Identifier: Apache-2.0

// Copyright 2023 Consensys Software Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Code generated by gnark DO NOT EDIT

pragma solidity ^0.8.0;

contract Poseidon2 {

  uint32 private constant R_MOD = 2130706433;
  uint256 private constant WORD_MOD = 4294967296; // 2**32
  
  // poseidon2 params (vortex on koalabear)
  uint32 private constant WIDTH = 16;
  uint32 private constant NB_FULL_ROUNDS = 6;
  uint32 private constant NB_PARTIAL_ROUNDS = 21;

  // precompile
  uint8 private constant MOD_EXP = 0x5;

  uint256 private constant ERROR_STRING_ID = 0x08c379a000000000000000000000000000000000000000000000000000000000; // selector for function Error(string)

  event PrintUint32(uint32 res);
  event PrintUint256(uint256 res);

  /// Hash
  function Hash() public returns(bool success) {

    uint32[] memory input = new uint32[](8);
    input[0] = 0x10;
    input[1] = 0x11;
    input[2] = 0x12;
    input[3] = 0x13;
    input[4] = 0x14;
    input[5] = 0x15;
    input[6] = 0x16;
    input[7] = 0x17;

    uint256 aa = 431359146781120966242552843855944128473473360879759082526070001369111;
    uint256 bb = 431359146781120966242552843855944128473473360879759082526070001369111;

    uint256 check;

    // params vortex t=16, rf=6, rp=21
    assembly {

      // permutation x = [16]koalabear
      let mPtr := mload(0x40)

      mstore(mPtr, aa)
      mstore(add(mPtr, 0x20), bb)
      matMulExternalInPlace(mPtr)

      bb := mload(add(mPtr, 0x20))
      check := ithChunk(bb, 3)

      /// @param ptr pointer to 2 uint256 elements, We interpret them as 4 packs of 4 uint32 elmts ->
      /// [[a0,a1,a2,a3],..,[a12,a13,a14,a15]]:=[v0,v1,v2,v3]
      /// and we multiply [v0,v1,v2,v3] by circ(2M4,M4,..,M4)
      function matMulExternalInPlace(ptr) {
        mathMulM4InPlace(ptr)
        let t0, t1, t2, t3 := sumColumns(ptr)

        let n := mload(ptr)
        let a, b, c, d, e, f, g, h
        a := addmod(t0, ithChunk(n, 0), R_MOD)
        b := addmod(t1, ithChunk(n, 1), R_MOD)
        c := addmod(t2, ithChunk(n, 2), R_MOD)
        d := addmod(t3, ithChunk(n, 3), R_MOD)
        e := addmod(t0, ithChunk(n, 4), R_MOD)
        f := addmod(t1, ithChunk(n, 5), R_MOD)
        g := addmod(t2, ithChunk(n, 6), R_MOD)
        h := addmod(t3, ithChunk(n, 7), R_MOD)
        n := packToUint256(a, b, c, d, e, f, g, h)
        mstore(ptr, n)

        n := mload(add(ptr, 0x20))
        a := addmod(t0, ithChunk(n, 0), R_MOD)
        b := addmod(t1, ithChunk(n, 1), R_MOD)
        c := addmod(t2, ithChunk(n, 2), R_MOD)
        d := addmod(t3, ithChunk(n, 3), R_MOD)
        e := addmod(t0, ithChunk(n, 4), R_MOD)
        f := addmod(t1, ithChunk(n, 5), R_MOD)
        g := addmod(t2, ithChunk(n, 6), R_MOD)
        h := addmod(t3, ithChunk(n, 7), R_MOD)
        n := packToUint256(a, b, c, d, e, f, g, h)
        mstore(add(ptr, 0x20), n)
      }

      /// @param ptr pointer to 2 uint256 elements. We interpret them as 4 packs of 4 uint32 elmts ->
      /// [[a0,a1,a2,a3],..,[a12,a13,a14,a15]] and we sum them:
      /// [[a0+a4+a8+a12, .., a3+a7+a11+a15]]
      function sumColumns(ptr)->t0, t1, t2, t3 {
        
        let a := mload(ptr)
        
        t0 := addmod(t0, ithChunk(a, 0), R_MOD)
        t1 := addmod(t1, ithChunk(a, 1), R_MOD)
        t2 := addmod(t2, ithChunk(a, 2), R_MOD)
        t3 := addmod(t3, ithChunk(a, 3), R_MOD)

        t0 := addmod(t0, ithChunk(a, 4), R_MOD)
        t1 := addmod(t1, ithChunk(a, 5), R_MOD)
        t2 := addmod(t2, ithChunk(a, 6), R_MOD)
        t3 := addmod(t3, ithChunk(a, 7), R_MOD)

        a := mload(add(ptr, 0x20))
        t0 := addmod(t0, ithChunk(a, 0), R_MOD)
        t1 := addmod(t1, ithChunk(a, 1), R_MOD)
        t2 := addmod(t2, ithChunk(a, 2), R_MOD)
        t3 := addmod(t3, ithChunk(a, 3), R_MOD)

        t0 := addmod(t0, ithChunk(a, 4), R_MOD)
        t1 := addmod(t1, ithChunk(a, 5), R_MOD)
        t2 := addmod(t2, ithChunk(a, 6), R_MOD)
        t3 := addmod(t3, ithChunk(a, 7), R_MOD)
      }

      /// matMulM4 computes
      /// s <- diag_4(M4)*s
      /// where M4=
      /// (2 3 1 1)
      /// (1 2 3 1)
      /// (1 1 2 3)
      /// (3 1 1 2)
      /// on chunks of 4 elemts on each part of the buffer
      /// for the addition chain, see:
      /// https://github.com/Plonky3/Plonky3/blob/f91c76545cf5c4ae9182897bcc557715817bcbdc/poseidon2/src/external.rs#L43
      /// this MDS matrix is more efficient than
      /// https://eprint.iacr.org/2023/323.pdf appendix Bb
      /// @param ptr pointer to 2 uint256 elements, interpreted as 4 blocks of 4 uint32 elements
      /// that we multiply by M4. The resut is 4 blocks of 4 uint32 elements, aligned in ptr
      function mathMulM4InPlace(ptr) {
        
        let a := mload(ptr)
        a := matMulM4uint256(a)
        mstore(ptr, a)
        
        a := mload(add(ptr, 0x20))
        a := matMulM4uint256(a)
        mstore(add(ptr, 0x20), a)
      }

      /// matMulM4uint256 splits a:= (c1<<128) || c2 in two chunks c1 c2 of 4 32bits elmts
      /// and computes d1=M4*c1, d2=M4*c2, and returns (d1<<128) || d2
      function matMulM4uint256(a)->b {
        let s0 := ithChunk(a, 0)
        let s1 := ithChunk(a, 1)
        let s2 := ithChunk(a, 2)
        let s3 := ithChunk(a, 3)
        s0, s1, s2, s3 := matMulM4(s0, s1, s2, s3)
        let s4 := ithChunk(a, 4)
        let s5 := ithChunk(a, 5)
        let s6 := ithChunk(a, 6)
        let s7 := ithChunk(a, 7)
        s4, s5, s6, s7 := matMulM4(s4, s5, s6, s7)
        b := packToUint256(s0, s1, s2, s3, s4, s5, s6, s7)
      }

      /// computes M4*[a, b , c, d]
      /// where M4=
      /// (2 3 1 1)
      /// (1 2 3 1)
      /// (1 1 2 3)
      /// (3 1 1 2)
      /// a, b, c, d are uint32 elmts
      function matMulM4(a, b, c, d)->u,v,w,x {
        
        let t01, t23, t0123, t01123, t01233
        
        t01 := addmod(a, b, R_MOD)
        t23 := addmod(c, d, R_MOD)
        t0123 := addmod(t01, t23, R_MOD)
        t01123 := addmod(t0123, b, R_MOD)
        t01233 := addmod(t0123, d, R_MOD)

        d := addmod(a, a, R_MOD)
        d := addmod(d, t01233, R_MOD)
        b := addmod(c, c, R_MOD)
        b := addmod(b, t01123, R_MOD)
        a := addmod(t01, t01123, R_MOD)
        c := addmod(t23, t01233, R_MOD)

        u := a
        v := b
        w := c
        x := d
      }

      /// @return u = a << 224 || b << 192 || .. || h
      function packToUint256(a, b, c, d, e, f, g, h) -> u {
        u := shl(224, a)
        u := add(u, shl(192, b))
        u := add(u, shl(160, c))
        u := add(u, shl(128, d))
        u := add(u, shl(96, e))
        u := add(u, shl(64, f))
        u := add(u, shl(32, g))
        u := add(u, h)
      }

      // query i-th 32bits chunk of a uint256 number N.
      // The 8-th chunk corresponds to the LSB of N,
      // the 0-th chunk corresponds to the MSB of N.
      function ithChunk(n, i)->m {
        m := shr(mul(sub(7,i), 32), n)
        m := mod(m, WORD_MOD)
      }

      // sbox
      function sbox(x)->res {
        let tmp := mulmod(x, x, R_MOD)
        res := mulmod(tmp, x, R_MOD)
      }

    }

    emit PrintUint256(check);
    // emit PrintUint32(input[0]);

    success = true;
  }
}
