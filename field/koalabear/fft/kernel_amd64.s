//go:build !purego
// Code generated by gnark-crypto/generator. DO NOT EDIT.
#include "textflag.h"
#include "funcdata.h"
#include "go_asm.h"

// performs a butterfly between 2 vectors of dwords
// in0 = (in0 + in1) mod q
// in1 = (in0 - in1) mod 2q
// in2: q broadcasted on all dwords lanes
// in3: temporary Z register
#define BUTTERFLYD2Q(in0, in1, in2, in3) \
	VPADDD  in0, in1, in3 \
	VPSUBD  in1, in0, in1 \
	VPSUBD  in2, in3, in0 \
	VPMINUD in3, in0, in0 \
	VPADDD  in2, in1, in1 \

// same as butterflyD2Q but reduces in1 to [0,q)
#define BUTTERFLYD1Q(in0, in1, in2, in3, in4) \
	VPADDD  in0, in1, in3 \
	VPSUBD  in1, in0, in1 \
	VPSUBD  in2, in3, in0 \
	VPMINUD in3, in0, in0 \
	VPADDD  in2, in1, in4 \
	VPMINUD in4, in1, in1 \

// same as butterflyD2Q but for qwords
// in2: must be broadcasted on all qwords lanes
#define BUTTERFLYQ2Q(in0, in1, in2, in3) \
	VPADDQ  in0, in1, in3 \
	VPSUBQ  in1, in0, in1 \
	VPSUBQ  in2, in3, in0 \
	VPMINUQ in3, in0, in0 \
	VPADDQ  in2, in1, in1 \

#define BUTTERFLYQ1Q(in0, in1, in2, in3, in4) \
	VPADDQ  in0, in1, in3 \
	VPSUBQ  in1, in0, in1 \
	VPSUBQ  in2, in3, in0 \
	VPMINUQ in3, in0, in0 \
	VPADDQ  in2, in1, in4 \
	VPMINUQ in4, in1, in1 \

// performs a multiplication in place between 2 vectors of qwords (values should be dwords zero extended)
// in0 = (in0 * in1) mod q
// in1: second operand
// in2: mask for low dword in each qword
// in3: q broadcasted on all qwords lanes
// in4: qInvNeg broadcasted on all qwords lanes
// in5: temporary Z register
// in6: temporary Z register
#define MUL(in0, in1, in2, in3, in4, in5, in6) \
	VPMULUDQ in0, in1, in5 \
	VPANDQ   in2, in5, in6 \
	VPMULUDQ in6, in4, in6 \
	VPANDQ   in2, in6, in6 \
	VPMULUDQ in6, in3, in6 \
	VPADDQ   in5, in6, in5 \
	VPSRLQ   $32, in5, in5 \
	VPSUBQ   in3, in5, in6 \
	VPMINUQ  in5, in6, in0 \

// goes from
// Z1 = A A A A B B B B
// Z2 = C C C C D D D D
// we want
// Z1 = A A A A C C C C
// Z2 = B B B B D D D D
#define PERMUTE4X4(in0, in1, in2, in3) \
	VSHUFI64X2 $0x000000000000004e, in1, in0, in2 \
	VPBLENDMQ  in0, in2, in3, in0                 \
	VPBLENDMQ  in2, in1, in3, in1                 \

// Z1 = A A B B C C D D
// Z2 = L L M M N N O O
// we want
// Z1 = A A L L C C N N
// Z2 = B B M M D D O O
#define PERMUTE2X2(in0, in1, in2, in3, in4) \
	VMOVDQA64 in2, in3           \
	VPERMI2Q  in1, in0, in3      \
	VPBLENDMQ in0, in3, in4, in0 \
	VPBLENDMQ in3, in1, in4, in1 \

#define PERMUTE1X1(in0, in1, in2, in3) \
	VPSHRDQ   $32, in1, in0, in2 \
	VPBLENDMD in0, in2, in3, in0 \
	VPBLENDMD in2, in1, in3, in1 \

#define PACK_DWORDS(in0, in1, in2, in3) \
	VPMOVQD      in0, in1          \
	VPMOVQD      in2, in3          \
	VINSERTI64X4 $1, in3, in0, in0 \

TEXT ·innerDITWithTwiddles_avx512(SB), NOSPLIT, $0-72
	// prepare constants needed for mul and reduce ops
	MOVD         $const_q, AX
	VPBROADCASTQ AX, Z8
	MOVD         $const_qInvNeg, AX
	VPBROADCASTQ AX, Z9
	VPCMPEQB     Y0, Y0, Y0
	VPMOVZXDQ    Y0, Z11

	// load arguments
	MOVQ a+0(FP), R15
	MOVQ twiddles+24(FP), CX
	MOVQ end+56(FP), SI
	MOVQ m+64(FP), BX
	CMPQ BX, $0x0000000000000008
	JL   smallerThan8_1          // m < 8
	SHRQ $3, SI                  // we are processing 8 elements at a time
	SHLQ $2, BX                  // offset = m * 4bytes
	MOVQ R15, DX
	ADDQ BX, DX

loop_3:
	TESTQ     SI, SI
	JEQ       done_2     // n == 0, we are done
	VPMOVZXDQ 0(R15), Z0 // load a[i]
	VPMOVZXDQ 0(DX), Z1  // load a[i+m]
	VPMOVZXDQ 0(CX), Z15
	MUL(Z1, Z15, Z11, Z8, Z9, Z12, Z10)
	BUTTERFLYQ1Q(Z0, Z1, Z8, Z3, Z4)
	VPMOVQD   Z0, 0(R15) // store a[i]
	VPMOVQD   Z1, 0(DX)  // store a[i+m]
	ADDQ      $32, R15
	ADDQ      $32, DX
	ADDQ      $32, CX
	DECQ      SI         // decrement n
	JMP       loop_3

done_2:
	RET

smallerThan8_1:
	// m < 8, we call the generic one
	// note that this should happen only when doing a FFT smaller than the smallest generated kernel
	MOVQ a+0(FP), AX
	MOVQ AX, (SP)
	MOVQ twiddles+24(FP), AX
	MOVQ AX, 24(SP)
	MOVQ start+48(FP), AX
	MOVQ AX, 48(SP)
	MOVQ end+56(FP), AX
	MOVQ AX, 56(SP)
	MOVQ m+64(FP), AX
	MOVQ AX, 64(SP)
	CALL ·innerDITWithTwiddlesGeneric(SB)
	RET

TEXT ·innerDIFWithTwiddles_avx512(SB), NOSPLIT, $0-72
	// prepare constants needed for mul and reduce ops
	MOVD         $const_q, AX
	VPBROADCASTD AX, Z2
	VPBROADCASTQ AX, Z8
	MOVD         $const_qInvNeg, AX
	VPBROADCASTQ AX, Z9
	VPCMPEQB     Y0, Y0, Y0
	VPMOVZXDQ    Y0, Z11

	// load arguments
	MOVQ a+0(FP), R15
	MOVQ twiddles+24(FP), CX
	MOVQ end+56(FP), SI
	MOVQ m+64(FP), BX
	CMPQ BX, $0x0000000000000010
	JL   smallerThan16_4         // m < 16
	SHRQ $4, SI                  // we are processing 16 elements at a time
	SHLQ $2, BX                  // offset = m * 4bytes
	MOVQ R15, DX
	ADDQ BX, DX

loop_6:
	TESTQ         SI, SI
	JEQ           done_5      // n == 0, we are done
	VMOVDQA32     0(R15), Z0  // load a[i]
	VMOVDQA32     0(DX), Z1   // load a[i+m]
	BUTTERFLYD2Q(Z0, Z1, Z2, Z3)
	VMOVDQA32     Z0, 0(R15)  // store a[i]
	VEXTRACTI32X8 $0, Z1, Y20
	VEXTRACTI32X8 $1, Z1, Y21
	VPMOVZXDQ     Y20, Z13
	VPMOVZXDQ     Y21, Z14
	VPMOVZXDQ     0(CX), Z15
	VPMOVZXDQ     32(CX), Z16
	MUL(Z13, Z15, Z11, Z8, Z9, Z12, Z10)
	MUL(Z14, Z16, Z11, Z8, Z9, Z12, Z10)
	VPMOVQD       Z13, 0(DX)
	VPMOVQD       Z14, 32(DX)
	ADDQ          $64, R15
	ADDQ          $64, DX
	ADDQ          $64, CX
	DECQ          SI          // decrement n
	JMP           loop_6

done_5:
	RET

smallerThan16_4:
	// m < 16, we call the generic one
	// note that this should happen only when doing a FFT smaller than the smallest generated kernel
	MOVQ a+0(FP), AX
	MOVQ AX, (SP)
	MOVQ twiddles+24(FP), AX
	MOVQ AX, 24(SP)
	MOVQ start+48(FP), AX
	MOVQ AX, 48(SP)
	MOVQ end+56(FP), AX
	MOVQ AX, 56(SP)
	MOVQ m+64(FP), AX
	MOVQ AX, 64(SP)
	CALL ·innerDIFWithTwiddlesGeneric(SB)
	RET

// kerDIFNP_128_avx512(a []{{ .FF }}.Element, twiddles [][]{{ .FF }}.Element, stage int)
TEXT ·kerDIFNP_128_avx512(SB), NOSPLIT, $0-56
	// prepare constants needed for mul and reduce ops
	MOVD         $const_q, AX
	VPBROADCASTQ AX, Z17
	MOVD         $const_qInvNeg, AX
	VPBROADCASTQ AX, Z18
	VPCMPEQB     Y0, Y0, Y0
	VPMOVZXDQ    Y0, Z20

	// load arguments
	MOVQ  a+0(FP), R15
	MOVQ  twiddles+24(FP), CX
	MOVQ  stage+48(FP), AX
	IMULQ $24, AX
	ADDQ  AX, CX              // we want twiddles[stage] as starting point

	// load a[:128] in registers
	VPMOVZXDQ    0(R15), Z0
	VPMOVZXDQ    32(R15), Z1
	VPMOVZXDQ    64(R15), Z2
	VPMOVZXDQ    96(R15), Z3
	VPMOVZXDQ    128(R15), Z4
	VPMOVZXDQ    160(R15), Z5
	VPMOVZXDQ    192(R15), Z6
	VPMOVZXDQ    224(R15), Z7
	VPMOVZXDQ    256(R15), Z8
	VPMOVZXDQ    288(R15), Z9
	VPMOVZXDQ    320(R15), Z10
	VPMOVZXDQ    352(R15), Z11
	VPMOVZXDQ    384(R15), Z12
	VPMOVZXDQ    416(R15), Z13
	VPMOVZXDQ    448(R15), Z14
	VPMOVZXDQ    480(R15), Z15
	MOVQ         $0x0000000000000f0f, AX
	KMOVQ        AX, K1
	MOVQ         0(CX), BX
	VPMOVZXDQ    0(BX), Z23
	VPMOVZXDQ    32(BX), Z24
	VPMOVZXDQ    64(BX), Z25
	VPMOVZXDQ    96(BX), Z26
	VPMOVZXDQ    128(BX), Z27
	VPMOVZXDQ    160(BX), Z28
	VPMOVZXDQ    192(BX), Z29
	VPMOVZXDQ    224(BX), Z30
	BUTTERFLYQ2Q(Z0, Z8, Z17, Z21)
	MUL(Z8, Z23, Z20, Z17, Z18, Z16, Z19)
	BUTTERFLYQ2Q(Z1, Z9, Z17, Z21)
	MUL(Z9, Z24, Z20, Z17, Z18, Z16, Z19)
	BUTTERFLYQ2Q(Z2, Z10, Z17, Z21)
	MUL(Z10, Z25, Z20, Z17, Z18, Z16, Z19)
	BUTTERFLYQ2Q(Z3, Z11, Z17, Z21)
	MUL(Z11, Z26, Z20, Z17, Z18, Z16, Z19)
	BUTTERFLYQ2Q(Z4, Z12, Z17, Z21)
	MUL(Z12, Z27, Z20, Z17, Z18, Z16, Z19)
	BUTTERFLYQ2Q(Z5, Z13, Z17, Z21)
	MUL(Z13, Z28, Z20, Z17, Z18, Z16, Z19)
	BUTTERFLYQ2Q(Z6, Z14, Z17, Z21)
	MUL(Z14, Z29, Z20, Z17, Z18, Z16, Z19)
	BUTTERFLYQ2Q(Z7, Z15, Z17, Z21)
	MUL(Z15, Z30, Z20, Z17, Z18, Z16, Z19)
	ADDQ         $24, CX
	MOVQ         0(CX), BX
	VPMOVZXDQ    0(BX), Z23
	VPMOVZXDQ    32(BX), Z24
	VPMOVZXDQ    64(BX), Z25
	VPMOVZXDQ    96(BX), Z26
	BUTTERFLYQ2Q(Z0, Z4, Z17, Z21)
	MUL(Z4, Z23, Z20, Z17, Z18, Z16, Z19)
	BUTTERFLYQ2Q(Z1, Z5, Z17, Z21)
	MUL(Z5, Z24, Z20, Z17, Z18, Z16, Z19)
	BUTTERFLYQ2Q(Z2, Z6, Z17, Z21)
	MUL(Z6, Z25, Z20, Z17, Z18, Z16, Z19)
	BUTTERFLYQ2Q(Z3, Z7, Z17, Z21)
	MUL(Z7, Z26, Z20, Z17, Z18, Z16, Z19)
	BUTTERFLYQ2Q(Z8, Z12, Z17, Z21)
	MUL(Z12, Z23, Z20, Z17, Z18, Z16, Z19)
	BUTTERFLYQ2Q(Z9, Z13, Z17, Z21)
	MUL(Z13, Z24, Z20, Z17, Z18, Z16, Z19)
	BUTTERFLYQ2Q(Z10, Z14, Z17, Z21)
	MUL(Z14, Z25, Z20, Z17, Z18, Z16, Z19)
	BUTTERFLYQ2Q(Z11, Z15, Z17, Z21)
	MUL(Z15, Z26, Z20, Z17, Z18, Z16, Z19)
	ADDQ         $24, CX
	MOVQ         0(CX), BX
	VPMOVZXDQ    0(BX), Z23
	VPMOVZXDQ    32(BX), Z24
	BUTTERFLYQ2Q(Z0, Z2, Z17, Z21)
	MUL(Z2, Z23, Z20, Z17, Z18, Z16, Z19)
	BUTTERFLYQ2Q(Z1, Z3, Z17, Z21)
	MUL(Z3, Z24, Z20, Z17, Z18, Z16, Z19)
	BUTTERFLYQ2Q(Z4, Z6, Z17, Z21)
	MUL(Z6, Z23, Z20, Z17, Z18, Z16, Z19)
	BUTTERFLYQ2Q(Z5, Z7, Z17, Z21)
	MUL(Z7, Z24, Z20, Z17, Z18, Z16, Z19)
	BUTTERFLYQ2Q(Z8, Z10, Z17, Z21)
	MUL(Z10, Z23, Z20, Z17, Z18, Z16, Z19)
	BUTTERFLYQ2Q(Z9, Z11, Z17, Z21)
	MUL(Z11, Z24, Z20, Z17, Z18, Z16, Z19)
	BUTTERFLYQ2Q(Z12, Z14, Z17, Z21)
	MUL(Z14, Z23, Z20, Z17, Z18, Z16, Z19)
	BUTTERFLYQ2Q(Z13, Z15, Z17, Z21)
	MUL(Z15, Z24, Z20, Z17, Z18, Z16, Z19)
	ADDQ         $24, CX
	MOVQ         0(CX), BX
	VPMOVZXDQ    0(BX), Z23
	BUTTERFLYQ2Q(Z0, Z1, Z17, Z21)
	MUL(Z1, Z23, Z20, Z17, Z18, Z16, Z19)
	BUTTERFLYQ2Q(Z2, Z3, Z17, Z21)
	MUL(Z3, Z23, Z20, Z17, Z18, Z16, Z19)
	BUTTERFLYQ2Q(Z4, Z5, Z17, Z21)
	MUL(Z5, Z23, Z20, Z17, Z18, Z16, Z19)
	BUTTERFLYQ2Q(Z6, Z7, Z17, Z21)
	MUL(Z7, Z23, Z20, Z17, Z18, Z16, Z19)
	BUTTERFLYQ2Q(Z8, Z9, Z17, Z21)
	MUL(Z9, Z23, Z20, Z17, Z18, Z16, Z19)
	BUTTERFLYQ2Q(Z10, Z11, Z17, Z21)
	MUL(Z11, Z23, Z20, Z17, Z18, Z16, Z19)
	BUTTERFLYQ2Q(Z12, Z13, Z17, Z21)
	MUL(Z13, Z23, Z20, Z17, Z18, Z16, Z19)
	BUTTERFLYQ2Q(Z14, Z15, Z17, Z21)
	MUL(Z15, Z23, Z20, Z17, Z18, Z16, Z19)
	ADDQ         $24, CX
	MOVQ         0(CX), BX
	VPMOVZXDQ    0(BX), Y23                         // zero extend 4x uint32 to 4x uint64
	VINSERTI64X4 $1, Y23, Z23, Z23
	PERMUTE4X4(Z0, Z1, Z21, K1)
	BUTTERFLYQ2Q(Z0, Z1, Z17, Z21)
	MUL(Z1, Z23, Z20, Z17, Z18, Z16, Z19)
	PERMUTE4X4(Z0, Z1, Z21, K1)
	PERMUTE4X4(Z2, Z3, Z21, K1)
	BUTTERFLYQ2Q(Z2, Z3, Z17, Z21)
	MUL(Z3, Z23, Z20, Z17, Z18, Z16, Z19)
	PERMUTE4X4(Z2, Z3, Z21, K1)
	PERMUTE4X4(Z4, Z5, Z21, K1)
	BUTTERFLYQ2Q(Z4, Z5, Z17, Z21)
	MUL(Z5, Z23, Z20, Z17, Z18, Z16, Z19)
	PERMUTE4X4(Z4, Z5, Z21, K1)
	PERMUTE4X4(Z6, Z7, Z21, K1)
	BUTTERFLYQ2Q(Z6, Z7, Z17, Z21)
	MUL(Z7, Z23, Z20, Z17, Z18, Z16, Z19)
	PERMUTE4X4(Z6, Z7, Z21, K1)
	PERMUTE4X4(Z8, Z9, Z21, K1)
	BUTTERFLYQ2Q(Z8, Z9, Z17, Z21)
	MUL(Z9, Z23, Z20, Z17, Z18, Z16, Z19)
	PERMUTE4X4(Z8, Z9, Z21, K1)
	PERMUTE4X4(Z10, Z11, Z21, K1)
	BUTTERFLYQ2Q(Z10, Z11, Z17, Z21)
	MUL(Z11, Z23, Z20, Z17, Z18, Z16, Z19)
	PERMUTE4X4(Z10, Z11, Z21, K1)
	PERMUTE4X4(Z12, Z13, Z21, K1)
	BUTTERFLYQ2Q(Z12, Z13, Z17, Z21)
	MUL(Z13, Z23, Z20, Z17, Z18, Z16, Z19)
	PERMUTE4X4(Z12, Z13, Z21, K1)
	PERMUTE4X4(Z14, Z15, Z21, K1)
	BUTTERFLYQ2Q(Z14, Z15, Z17, Z21)
	MUL(Z15, Z23, Z20, Z17, Z18, Z16, Z19)
	PERMUTE4X4(Z14, Z15, Z21, K1)
	ADDQ         $24, CX
	MOVQ         0(CX), BX
	VPMOVZXDQ    0(BX), X23                         // zero extend 2x uint32 to 2x uint64
	VINSERTI64X2 $1, X23, Z23, Z23
	VINSERTI64X2 $0x0000000000000002, X23, Z23, Z23
	VINSERTI64X2 $0x0000000000000003, X23, Z23, Z23
	MOVQ         $0x0000000000000033, AX
	KMOVQ        AX, K2
	MOVQ         ·vInterleaveIndices+0(SB), DI
	VMOVDQU64    0(DI), Z30
	PERMUTE2X2(Z0, Z1, Z30, Z29, K2)
	BUTTERFLYQ2Q(Z0, Z1, Z17, Z21)
	MUL(Z1, Z23, Z20, Z17, Z18, Z16, Z19)
	PERMUTE2X2(Z0, Z1, Z30, Z29, K2)
	PERMUTE2X2(Z2, Z3, Z30, Z29, K2)
	BUTTERFLYQ2Q(Z2, Z3, Z17, Z21)
	MUL(Z3, Z23, Z20, Z17, Z18, Z16, Z19)
	PERMUTE2X2(Z2, Z3, Z30, Z29, K2)
	PERMUTE2X2(Z4, Z5, Z30, Z29, K2)
	BUTTERFLYQ2Q(Z4, Z5, Z17, Z21)
	MUL(Z5, Z23, Z20, Z17, Z18, Z16, Z19)
	PERMUTE2X2(Z4, Z5, Z30, Z29, K2)
	PERMUTE2X2(Z6, Z7, Z30, Z29, K2)
	BUTTERFLYQ2Q(Z6, Z7, Z17, Z21)
	MUL(Z7, Z23, Z20, Z17, Z18, Z16, Z19)
	PERMUTE2X2(Z6, Z7, Z30, Z29, K2)
	PERMUTE2X2(Z8, Z9, Z30, Z29, K2)
	BUTTERFLYQ2Q(Z8, Z9, Z17, Z21)
	MUL(Z9, Z23, Z20, Z17, Z18, Z16, Z19)
	PERMUTE2X2(Z8, Z9, Z30, Z29, K2)
	PERMUTE2X2(Z10, Z11, Z30, Z29, K2)
	BUTTERFLYQ2Q(Z10, Z11, Z17, Z21)
	MUL(Z11, Z23, Z20, Z17, Z18, Z16, Z19)
	PERMUTE2X2(Z10, Z11, Z30, Z29, K2)
	PERMUTE2X2(Z12, Z13, Z30, Z29, K2)
	BUTTERFLYQ2Q(Z12, Z13, Z17, Z21)
	MUL(Z13, Z23, Z20, Z17, Z18, Z16, Z19)
	PERMUTE2X2(Z12, Z13, Z30, Z29, K2)
	PERMUTE2X2(Z14, Z15, Z30, Z29, K2)
	BUTTERFLYQ2Q(Z14, Z15, Z17, Z21)
	MUL(Z15, Z23, Z20, Z17, Z18, Z16, Z19)
	PERMUTE2X2(Z14, Z15, Z30, Z29, K2)
	MOVQ         $0x0000000000005555, AX
	KMOVD        AX, K3
	MOVD         $const_q, AX
	VPBROADCASTD AX, Z17                            // rebroadcast q, but on dword lanes
	PACK_DWORDS(Z0, Y0, Z1, Y1)
	PACK_DWORDS(Z2, Y2, Z3, Y3)
	PERMUTE1X1(Z0, Z2, Z21, K3)
	BUTTERFLYD1Q(Z0, Z2, Z17, Z21, Z22)
	PERMUTE1X1(Z0, Z2, Z21, K3)
	PACK_DWORDS(Z4, Y4, Z5, Y5)
	PACK_DWORDS(Z6, Y6, Z7, Y7)
	PERMUTE1X1(Z4, Z6, Z21, K3)
	BUTTERFLYD1Q(Z4, Z6, Z17, Z21, Z22)
	PERMUTE1X1(Z4, Z6, Z21, K3)
	PACK_DWORDS(Z8, Y8, Z9, Y9)
	PACK_DWORDS(Z10, Y10, Z11, Y11)
	PERMUTE1X1(Z8, Z10, Z21, K3)
	BUTTERFLYD1Q(Z8, Z10, Z17, Z21, Z22)
	PERMUTE1X1(Z8, Z10, Z21, K3)
	PACK_DWORDS(Z12, Y12, Z13, Y13)
	PACK_DWORDS(Z14, Y14, Z15, Y15)
	PERMUTE1X1(Z12, Z14, Z21, K3)
	BUTTERFLYD1Q(Z12, Z14, Z17, Z21, Z22)
	PERMUTE1X1(Z12, Z14, Z21, K3)

	// store a[:128] in memory
	VMOVDQA32 Z0, 0(R15)
	VMOVDQA32 Z2, 64(R15)
	VMOVDQA32 Z4, 128(R15)
	VMOVDQA32 Z6, 192(R15)
	VMOVDQA32 Z8, 256(R15)
	VMOVDQA32 Z10, 320(R15)
	VMOVDQA32 Z12, 384(R15)
	VMOVDQA32 Z14, 448(R15)
	RET
