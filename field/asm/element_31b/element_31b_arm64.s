// Code generated by gnark-crypto/generator. DO NOT EDIT.
#include "textflag.h"
#include "funcdata.h"
#include "go_asm.h"

// addVec(res, a, b *Element, n uint64)
// n is the number of blocks of 4 uint32 to process
TEXT ·addVec(SB), NOFRAME|NOSPLIT, $0-32
	LDP   res+0(FP), (R0, R1)
	LDP   b+16(FP), (R2, R3)
	VMOVS $const_q, V8
	VDUP  V8.S[0], V8.S4      // broadcast q into V8

loop1:
	CMP    $0x4, R3
	BLT    lastBlock2
	VLD1.P 64(R1), [V0.S4, V1.S4, V2.S4, V3.S4]
	VLD1.P 64(R2), [V4.S4, V5.S4, V6.S4, V7.S4]
	VADD   V0.S4, V4.S4, V4.S4
	VADD   V1.S4, V5.S4, V5.S4
	VADD   V2.S4, V6.S4, V6.S4
	VADD   V3.S4, V7.S4, V7.S4
	VSUB   V8.S4, V4.S4, V0.S4
	VSUB   V8.S4, V5.S4, V1.S4
	VSUB   V8.S4, V6.S4, V2.S4
	VSUB   V8.S4, V7.S4, V3.S4
	VUMIN  V0.S4, V4.S4, V4.S4
	VUMIN  V1.S4, V5.S4, V5.S4
	VUMIN  V2.S4, V6.S4, V6.S4
	VUMIN  V3.S4, V7.S4, V7.S4
	VST1.P [V4.S4, V5.S4, V6.S4, V7.S4], 64(R0)
	SUB    $0x4, R3, R3
	JMP    loop1

lastBlock2:
loop3:
	CBZ    R3, done4
	SUB    $1, R3, R3
	VLD1.P 16(R1), [V0.S4]
	VLD1.P 16(R2), [V4.S4]
	VADD   V0.S4, V4.S4, V4.S4 // b = a + b
	VSUB   V8.S4, V4.S4, V0.S4 // a = b - q
	VUMIN  V0.S4, V4.S4, V4.S4 // b = min(a, b)
	VST1.P [V4.S4], 16(R0)     // res = b
	JMP    loop3

done4:
	RET

// subVec(res, a, b *Element, n uint64)
// n is the number of blocks of 4 uint32 to process
TEXT ·subVec(SB), NOFRAME|NOSPLIT, $0-32
	LDP   res+0(FP), (R0, R1)
	LDP   b+16(FP), (R2, R3)
	VMOVS $const_q, V8
	VDUP  V8.S[0], V8.S4      // broadcast q into V8

loop5:
	CMP    $0x4, R3
	BLT    lastBlock6
	VLD1.P 64(R1), [V0.S4, V1.S4, V2.S4, V3.S4]
	VLD1.P 64(R2), [V4.S4, V5.S4, V6.S4, V7.S4]
	VSUB   V4.S4, V0.S4, V4.S4
	VSUB   V5.S4, V1.S4, V5.S4
	VSUB   V6.S4, V2.S4, V6.S4
	VSUB   V7.S4, V3.S4, V7.S4
	VADD   V4.S4, V8.S4, V0.S4
	VADD   V5.S4, V8.S4, V1.S4
	VADD   V6.S4, V8.S4, V2.S4
	VADD   V7.S4, V8.S4, V3.S4
	VUMIN  V0.S4, V4.S4, V4.S4
	VUMIN  V1.S4, V5.S4, V5.S4
	VUMIN  V2.S4, V6.S4, V6.S4
	VUMIN  V3.S4, V7.S4, V7.S4
	VST1.P [V4.S4, V5.S4, V6.S4, V7.S4], 64(R0)
	SUB    $0x4, R3, R3
	JMP    loop5

lastBlock6:
loop7:
	CBZ    R3, done8
	SUB    $1, R3, R3
	VLD1.P 16(R1), [V0.S4]
	VLD1.P 16(R2), [V4.S4]
	VSUB   V4.S4, V0.S4, V4.S4 // b = a - b
	VADD   V4.S4, V8.S4, V0.S4 // t = b + q
	VUMIN  V0.S4, V4.S4, V4.S4 // b = min(t, b)
	VST1.P [V4.S4], 16(R0)     // res = b
	JMP    loop7

done8:
	RET

// mulVec(res, a, b *Element, n uint64)
// n is the number of blocks of 4 uint32 to process
TEXT ·mulVec(SB), NOFRAME|NOSPLIT, $0-32
	LDP   res+0(FP), (R0, R1)
	LDP   b+16(FP), (R2, R3)
	VMOVS $const_q, V7
	VDUP  V7.S[0], V7.S4      // broadcast P
	MOVD  $const_mu, R4
	VDUP  R4, V8.S4           // broadcast MU
	VMOVQ $0, $0, V9

loop9:
	CBZ    R3, done10
	SUB    $1, R3, R3
	VLD1.P 16(R1), [V0.S4]
	VLD1.P 16(R2), [V1.S4]
	WORD   $0x2ea1c002              // UMULL V2.2D, V0.2S, V1.2S - cLow = a * b (lower halves)
	WORD   $0x6ea1c003              // UMULL2 V3.2D, V0.4S, V1.4S - cHigh = a * b (upper halves)
	WORD   $0x4ea19c0c              // MUL V12.4S, V0.4S, V1.4S - temp = a * b (low 32 bits)
	WORD   $0x4ea89d84              // MUL V4.4S, V12.4S, V8.4S - q = temp * mu (low 32 bits)
	WORD   $0x2ea7c085              // UMULL V5.2D, V4.2S, V7.2S - mLow = q * p (lower halves)
	WORD   $0x6ea7c086              // UMULL2 V6.2D, V4.4S, V7.4S - mHigh = q * p (upper halves)
	VSUB   V5.D2, V2.D2, V2.D2      // cLow = cLow - mLow
	VSUB   V6.D2, V3.D2, V3.D2      // cHigh = cHigh - mHigh
	WORD   $0x4e835840              // UZP2 V0.4S, V2.4S, V3.4S - a = high 32 bits of [cLow, cHigh]
	WORD   $0x4ea0352a              // CMGT V10.4S, V9.4S, V0.4S - mask = (0 > a) ? all 1s : 0
	VAND   V7.B16, V10.B16, V11.B16 // corr = mask & P
	VADD   V0.S4, V11.S4, V0.S4
	VST1.P [V0.S4], 16(R0)          // res = a
	JMP    loop9

done10:
	RET

// sumVec(t *uint64, a *[]uint32, n uint64) res = sum(a[0...n])
// n is the number of blocks of 16 uint32 to process
TEXT ·sumVec(SB), NOFRAME|NOSPLIT, $0-24
	// zeroing accumulators
	VMOVQ $0, $0, V4
	VMOVQ $0, $0, V5
	VMOVQ $0, $0, V6
	VMOVQ $0, $0, V7
	LDP   t+0(FP), (R1, R0)
	MOVD  n+16(FP), R2

loop11:
	CMP $0x4, R2
	BLT lastBlock12

	// blockSize is 16 uint32; we load 4 vectors of 4 uint32 at a time
	// (4*4)*4 = 64 bytes ~= 1 cache line
	// since our values are 31 bits, we can add 2 by 2 these vectors
	// we are left with 2 vectors of 4x32 bits values
	// that we accumulate in 4*2*64bits accumulators
	// the caller will reduce mod q the accumulators.
	VLD2.P  32(R0), [V0.S4, V1.S4]
	VADD    V0.S4, V1.S4, V0.S4    // a1 += a2
	VLD2.P  32(R0), [V2.S4, V3.S4]
	VADD    V2.S4, V3.S4, V2.S4    // a3 += a4
	VUSHLL  $0, V0.S2, V1.D2       // convert low words to 64 bits
	VADD    V1.D2, V5.D2, V5.D2    // acc2 += a2
	VUSHLL2 $0, V0.S4, V0.D2       // convert high words to 64 bits
	VADD    V0.D2, V4.D2, V4.D2    // acc1 += a1
	VUSHLL  $0, V2.S2, V3.D2       // convert low words to 64 bits
	VADD    V3.D2, V7.D2, V7.D2    // acc4 += a4
	VUSHLL2 $0, V2.S4, V2.D2       // convert high words to 64 bits
	VADD    V2.D2, V6.D2, V6.D2    // acc3 += a3
	VLD2.P  32(R0), [V0.S4, V1.S4]
	VADD    V0.S4, V1.S4, V0.S4    // a1 += a2
	VLD2.P  32(R0), [V2.S4, V3.S4]
	VADD    V2.S4, V3.S4, V2.S4    // a3 += a4
	VUSHLL  $0, V0.S2, V1.D2       // convert low words to 64 bits
	VADD    V1.D2, V5.D2, V5.D2    // acc2 += a2
	VUSHLL2 $0, V0.S4, V0.D2       // convert high words to 64 bits
	VADD    V0.D2, V4.D2, V4.D2    // acc1 += a1
	VUSHLL  $0, V2.S2, V3.D2       // convert low words to 64 bits
	VADD    V3.D2, V7.D2, V7.D2    // acc4 += a4
	VUSHLL2 $0, V2.S4, V2.D2       // convert high words to 64 bits
	VADD    V2.D2, V6.D2, V6.D2    // acc3 += a3
	VLD2.P  32(R0), [V0.S4, V1.S4]
	VADD    V0.S4, V1.S4, V0.S4    // a1 += a2
	VLD2.P  32(R0), [V2.S4, V3.S4]
	VADD    V2.S4, V3.S4, V2.S4    // a3 += a4
	VUSHLL  $0, V0.S2, V1.D2       // convert low words to 64 bits
	VADD    V1.D2, V5.D2, V5.D2    // acc2 += a2
	VUSHLL2 $0, V0.S4, V0.D2       // convert high words to 64 bits
	VADD    V0.D2, V4.D2, V4.D2    // acc1 += a1
	VUSHLL  $0, V2.S2, V3.D2       // convert low words to 64 bits
	VADD    V3.D2, V7.D2, V7.D2    // acc4 += a4
	VUSHLL2 $0, V2.S4, V2.D2       // convert high words to 64 bits
	VADD    V2.D2, V6.D2, V6.D2    // acc3 += a3
	VLD2.P  32(R0), [V0.S4, V1.S4]
	VADD    V0.S4, V1.S4, V0.S4    // a1 += a2
	VLD2.P  32(R0), [V2.S4, V3.S4]
	VADD    V2.S4, V3.S4, V2.S4    // a3 += a4
	VUSHLL  $0, V0.S2, V1.D2       // convert low words to 64 bits
	VADD    V1.D2, V5.D2, V5.D2    // acc2 += a2
	VUSHLL2 $0, V0.S4, V0.D2       // convert high words to 64 bits
	VADD    V0.D2, V4.D2, V4.D2    // acc1 += a1
	VUSHLL  $0, V2.S2, V3.D2       // convert low words to 64 bits
	VADD    V3.D2, V7.D2, V7.D2    // acc4 += a4
	VUSHLL2 $0, V2.S4, V2.D2       // convert high words to 64 bits
	VADD    V2.D2, V6.D2, V6.D2    // acc3 += a3
	SUB     $0x4, R2, R2
	JMP     loop11

lastBlock12:
loop13:
	CBZ     R2, done14
	SUB     $1, R2, R2
	VLD2.P  32(R0), [V0.S4, V1.S4]
	VADD    V0.S4, V1.S4, V0.S4    // a1 += a2
	VLD2.P  32(R0), [V2.S4, V3.S4]
	VADD    V2.S4, V3.S4, V2.S4    // a3 += a4
	VUSHLL  $0, V0.S2, V1.D2       // convert low words to 64 bits
	VADD    V1.D2, V5.D2, V5.D2    // acc2 += a2
	VUSHLL2 $0, V0.S4, V0.D2       // convert high words to 64 bits
	VADD    V0.D2, V4.D2, V4.D2    // acc1 += a1
	VUSHLL  $0, V2.S2, V3.D2       // convert low words to 64 bits
	VADD    V3.D2, V7.D2, V7.D2    // acc4 += a4
	VUSHLL2 $0, V2.S4, V2.D2       // convert high words to 64 bits
	VADD    V2.D2, V6.D2, V6.D2    // acc3 += a3
	JMP     loop13

done14:
	VADD   V4.D2, V6.D2, V4.D2   // acc1 += acc3
	VADD   V5.D2, V7.D2, V5.D2   // acc2 += acc4
	VST2.P [V4.D2, V5.D2], 0(R1) // store acc1 and acc2
	RET

// scalarMulVec(res, a, b *Element, n uint64) res[0...n] = a[0...n] * b
// n is the number of blocks of 4 uint32 to process
TEXT ·scalarMulVec(SB), NOFRAME|NOSPLIT, $0-32
	LDP   res+0(FP), (R0, R1)
	LDP   b+16(FP), (R2, R3)
	VMOVS $const_q, V7
	VDUP  V7.S[0], V7.S4      // broadcast P
	MOVD  $const_mu, R4
	VDUP  R4, V8.S4           // broadcast MU
	MOVWU 0(R2), R4
	VDUP  R4, V1.S4           // broadcast scalar b
	VMOVQ $0, $0, V9

loop15:
	CBZ    R3, done16
	SUB    $1, R3, R3
	VLD1.P 16(R1), [V0.S4]
	WORD   $0x2ea1c002              // UMULL V2.2D, V0.2S, V1.2S - cLow = a * b (lower halves)
	WORD   $0x6ea1c003              // UMULL2 V3.2D, V0.4S, V1.4S - cHigh = a * b (upper halves)
	WORD   $0x4ea19c0c              // MUL V12.4S, V0.4S, V1.4S - temp = a * b (low 32 bits)
	WORD   $0x4ea89d84              // MUL V4.4S, V12.4S, V8.4S - q = temp * mu (low 32 bits)
	WORD   $0x2ea7c085              // UMULL V5.2D, V4.2S, V7.2S - mLow = q * p (lower halves)
	WORD   $0x6ea7c086              // UMULL2 V6.2D, V4.4S, V7.4S - mHigh = q * p (upper halves)
	VSUB   V5.D2, V2.D2, V2.D2      // cLow = cLow - mLow
	VSUB   V6.D2, V3.D2, V3.D2      // cHigh = cHigh - mHigh
	WORD   $0x4e835840              // UZP2 V0.4S, V2.4S, V3.4S - a = high 32 bits of [cLow, cHigh]
	WORD   $0x4ea0352a              // CMGT V10.4S, V9.4S, V0.4S - mask = (0 > a) ? all 1s : 0
	VAND   V7.B16, V10.B16, V11.B16 // corr = mask & P
	VADD   V0.S4, V11.S4, V0.S4
	VST1.P [V0.S4], 16(R0)          // res = a
	JMP    loop15

done16:
	RET

// innerProdVec(t *uint64, a, b *[]uint32, n uint64) res = sum(a[0...n] * b[0...n])
// n is the number of blocks of 4 uint32 to process
// We do most of the montgomery multiplication but accumulate the
// temporary result (without final reduction) and let the caller reduce.
TEXT ·innerProdVec(SB), NOFRAME|NOSPLIT, $0-32
	LDP   t+0(FP), (R0, R1)
	LDP   b+16(FP), (R2, R3)
	VMOVS $const_q, V7
	VDUP  V7.S[0], V7.S4            // broadcast P
	MOVD  $const_mu, R4
	VDUP  R4, V8.S4                 // broadcast MU
	VMOVQ $0, $0, V9
	VMOVQ $0, $0, V10
	VEOR  V11.B16, V11.B16, V11.B16 // zero = 0

loop17:
	CBZ     R3, done18
	SUB     $1, R3, R3
	VLD1.P  16(R1), [V0.S4]
	VLD1.P  16(R2), [V1.S4]
	WORD    $0x2ea1c002              // UMULL V2.2D, V0.2S, V1.2S - cLow = a * b (lower halves)
	WORD    $0x6ea1c003              // UMULL2 V3.2D, V0.4S, V1.4S - cHigh = a * b (upper halves)
	WORD    $0x4ea19c0c              // MUL V12.4S, V0.4S, V1.4S - temp = a * b (low 32 bits)
	WORD    $0x4ea89d84              // MUL V4.4S, V12.4S, V8.4S - q = temp * mu (low 32 bits)
	WORD    $0x2ea7c085              // UMULL V5.2D, V4.2S, V7.2S - mLow = q * p (lower halves)
	WORD    $0x6ea7c086              // UMULL2 V6.2D, V4.4S, V7.4S - mHigh = q * p (upper halves)
	VSUB    V5.D2, V2.D2, V2.D2      // cLow = cLow - mLow
	VSUB    V6.D2, V3.D2, V3.D2      // cHigh = cHigh - mHigh
	WORD    $0x4e835842              // UZP2 V2.4S, V2.4S, V3.4S - cLow = high 32 bits of [cLow, cHigh]
	WORD    $0x4ea2356d              // CMGT V13.4S, V11.4S, V2.4S - mask = (0 > cLow) ? all 1s : 0
	VAND    V7.B16, V13.B16, V14.B16 // corr = mask & P
	VADD    V2.S4, V14.S4, V2.S4     // cLow = cLow + corr
	VUSHLL  $0, V2.S2, V5.D2         // mLow = extend(cLow[0,1])
	VUSHLL2 $0, V2.S4, V6.D2         // mHigh = extend(cLow[2,3])
	VADD    V5.D2, V9.D2, V9.D2      // acc0 += mLow
	VADD    V6.D2, V10.D2, V10.D2    // acc1 += mHigh
	JMP     loop17

done18:
	VADD   V9.D2, V10.D2, V9.D2 // acc0 += acc1
	VST1.P [V9.D2], 16(R0)      // store accumulator
	RET
