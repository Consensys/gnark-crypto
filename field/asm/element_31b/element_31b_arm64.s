// Code generated by gnark-crypto/generator. DO NOT EDIT.
#include "textflag.h"
#include "funcdata.h"
#include "go_asm.h"

// addVec(res, a, b *Element, n uint64)
// n is the number of blocks of 16 uint32 to process
TEXT 路addVec(SB), NOFRAME|NOSPLIT, $0-32
	LDP   res+0(FP), (R0, R1)
	LDP   b+16(FP), (R2, R3)
	VMOVS $const_q, V8
	VDUP  V8.S[0], V8.S4      // broadcast q into V8

loop1:
	CMP    $0x4, R3
	BLT    lastBlock3
	VLD1.P 64(R1), [V0.S4, V1.S4, V2.S4, V3.S4]
	VLD1.P 64(R2), [V4.S4, V5.S4, V6.S4, V7.S4]
	VADD   V0.S4, V4.S4, V4.S4
	VADD   V1.S4, V5.S4, V5.S4
	VADD   V2.S4, V6.S4, V6.S4
	VADD   V3.S4, V7.S4, V7.S4
	VSUB   V8.S4, V4.S4, V0.S4
	VSUB   V8.S4, V5.S4, V1.S4
	VSUB   V8.S4, V6.S4, V2.S4
	VSUB   V8.S4, V7.S4, V3.S4
	VUMIN  V0.S4, V4.S4, V4.S4
	VUMIN  V1.S4, V5.S4, V5.S4
	VUMIN  V2.S4, V6.S4, V6.S4
	VUMIN  V3.S4, V7.S4, V7.S4
	VST1.P [V4.S4, V5.S4, V6.S4, V7.S4], 64(R0)
	SUB    $0x4, R3, R3
	JMP    loop1

lastBlock3:
	CBZ    R3, done2
	VLD1.P 16(R1), [V0.S4]
	VLD1.P 16(R2), [V4.S4]
	VADD   V0.S4, V4.S4, V4.S4 // b = a + b
	VSUB   V8.S4, V4.S4, V0.S4 // a = b - q
	VUMIN  V0.S4, V4.S4, V4.S4 // b = min(a, b)
	VST1.P [V4.S4], 16(R0)     // res = b
	SUB    $1, R3, R3
	JMP    lastBlock3

done2:
	RET

// subVec(res, a, b *Element, n uint64)
// n is the number of blocks of 4 uint32 to process
TEXT 路subVec(SB), NOFRAME|NOSPLIT, $0-32
	LDP   res+0(FP), (R0, R1)
	LDP   b+16(FP), (R2, R3)
	VMOVS $const_q, V8
	VDUP  V8.S[0], V8.S4      // broadcast q into V8

loop4:
	CMP    $0x4, R3
	BLT    lastBlock6
	VLD1.P 64(R1), [V0.S4, V1.S4, V2.S4, V3.S4]
	VLD1.P 64(R2), [V4.S4, V5.S4, V6.S4, V7.S4]
	VSUB   V4.S4, V0.S4, V4.S4
	VSUB   V5.S4, V1.S4, V5.S4
	VSUB   V6.S4, V2.S4, V6.S4
	VSUB   V7.S4, V3.S4, V7.S4
	VADD   V4.S4, V8.S4, V0.S4
	VADD   V5.S4, V8.S4, V1.S4
	VADD   V6.S4, V8.S4, V2.S4
	VADD   V7.S4, V8.S4, V3.S4
	VUMIN  V0.S4, V4.S4, V4.S4
	VUMIN  V1.S4, V5.S4, V5.S4
	VUMIN  V2.S4, V6.S4, V6.S4
	VUMIN  V3.S4, V7.S4, V7.S4
	VST1.P [V4.S4, V5.S4, V6.S4, V7.S4], 64(R0)
	SUB    $0x4, R3, R3
	JMP    loop4

lastBlock6:
	CBZ    R3, done5
	VLD1.P 16(R1), [V0.S4]
	VLD1.P 16(R2), [V4.S4]
	VSUB   V4.S4, V0.S4, V4.S4 // b = a - b
	VADD   V4.S4, V8.S4, V0.S4 // t = b + q
	VUMIN  V0.S4, V4.S4, V4.S4 // b = min(t, b)
	VST1.P [V4.S4], 16(R0)     // res = b
	SUB    $1, R3, R3
	JMP    lastBlock6

done5:
	RET

// mulVec(res, a, b *Element, n uint64)
// n is the number of blocks of 4 uint32 to process
TEXT 路mulVec(SB), NOFRAME|NOSPLIT, $0-32
	LDP   res+0(FP), (R0, R1)
	LDP   b+16(FP), (R2, R3)
	VMOVS $const_q, V7
	VDUP  V7.S[0], V7.S4      // broadcast P
	MOVD  $const_mu, R4
	VDUP  R4, V8.S4           // broadcast MU
	VMOVQ $0, $0, V9

loop7:
	CBZ    R3, done8
	VLD1.P 16(R1), [V0.S4]
	VLD1.P 16(R2), [V1.S4]
	WORD   $0x2ea1c002          // UMULL V2.2D, V0.2S, V1.2S
	WORD   $0x6ea1c003          // UMULL2 V3.2D, V0.4S, V1.4S
	WORD   $0x4ea19c0c          // MUL V12.4S, V0.4S, V1.4S
	WORD   $0x4ea89d84          // MUL V4.4S, V12.4S, V8.4S
	WORD   $0x2ea7c085          // UMULL V5.2D, V4.2S, V7.2S
	WORD   $0x6ea7c086          // UMULL2 V6.2D, V4.4S, V7.4S
	VSUB   V5.D2, V2.D2, V2.D2
	VSUB   V6.D2, V3.D2, V3.D2
	WORD   $0x4e835840          // UZP2 V0.4S, V2.4S, V3.4S
	WORD   $0x4ea0352a          // CMGT V10.4S, V9.4S, V0.4S
	WORD   $0x4e2a1ceb          // AND V11.16B, V7.16B, V10.16B
	VADD   V0.S4, V11.S4, V0.S4
	VST1.P [V0.S4], 16(R0)      // res = a
	SUB    $1, R3, R3
	JMP    loop7

done8:
	RET

// sumVec(t *uint64, a *[]uint32, n uint64) res = sum(a[0...n])
// n is the number of blocks of 16 uint32 to process
TEXT 路sumVec(SB), NOFRAME|NOSPLIT, $0-24
	// zeroing accumulators
	VMOVQ $0, $0, V4
	VMOVQ $0, $0, V5
	VMOVQ $0, $0, V6
	VMOVQ $0, $0, V7
	LDP   t+0(FP), (R1, R0)
	MOVD  n+16(FP), R2

loop9:
	CMP $0x4, R2
	BLT lastBlock11

	// blockSize is 16 uint32; we load 4 vectors of 4 uint32 at a time
	// (4*4)*4 = 64 bytes ~= 1 cache line
	// since our values are 31 bits, we can add 2 by 2 these vectors
	// we are left with 2 vectors of 4x32 bits values
	// that we accumulate in 4*2*64bits accumulators
	// the caller will reduce mod q the accumulators.

	VLD2.P  32(R0), [V0.S4, V1.S4]
	VADD    V0.S4, V1.S4, V0.S4    // a1 += a2
	VLD2.P  32(R0), [V2.S4, V3.S4]
	VADD    V2.S4, V3.S4, V2.S4    // a3 += a4
	VUSHLL  $0, V0.S2, V1.D2       // convert low words to 64 bits
	VADD    V1.D2, V5.D2, V5.D2    // acc2 += a2
	VUSHLL2 $0, V0.S4, V0.D2       // convert high words to 64 bits
	VADD    V0.D2, V4.D2, V4.D2    // acc1 += a1
	VUSHLL  $0, V2.S2, V3.D2       // convert low words to 64 bits
	VADD    V3.D2, V7.D2, V7.D2    // acc4 += a4
	VUSHLL2 $0, V2.S4, V2.D2       // convert high words to 64 bits
	VADD    V2.D2, V6.D2, V6.D2    // acc3 += a3
	VLD2.P  32(R0), [V0.S4, V1.S4]
	VADD    V0.S4, V1.S4, V0.S4    // a1 += a2
	VLD2.P  32(R0), [V2.S4, V3.S4]
	VADD    V2.S4, V3.S4, V2.S4    // a3 += a4
	VUSHLL  $0, V0.S2, V1.D2       // convert low words to 64 bits
	VADD    V1.D2, V5.D2, V5.D2    // acc2 += a2
	VUSHLL2 $0, V0.S4, V0.D2       // convert high words to 64 bits
	VADD    V0.D2, V4.D2, V4.D2    // acc1 += a1
	VUSHLL  $0, V2.S2, V3.D2       // convert low words to 64 bits
	VADD    V3.D2, V7.D2, V7.D2    // acc4 += a4
	VUSHLL2 $0, V2.S4, V2.D2       // convert high words to 64 bits
	VADD    V2.D2, V6.D2, V6.D2    // acc3 += a3
	VLD2.P  32(R0), [V0.S4, V1.S4]
	VADD    V0.S4, V1.S4, V0.S4    // a1 += a2
	VLD2.P  32(R0), [V2.S4, V3.S4]
	VADD    V2.S4, V3.S4, V2.S4    // a3 += a4
	VUSHLL  $0, V0.S2, V1.D2       // convert low words to 64 bits
	VADD    V1.D2, V5.D2, V5.D2    // acc2 += a2
	VUSHLL2 $0, V0.S4, V0.D2       // convert high words to 64 bits
	VADD    V0.D2, V4.D2, V4.D2    // acc1 += a1
	VUSHLL  $0, V2.S2, V3.D2       // convert low words to 64 bits
	VADD    V3.D2, V7.D2, V7.D2    // acc4 += a4
	VUSHLL2 $0, V2.S4, V2.D2       // convert high words to 64 bits
	VADD    V2.D2, V6.D2, V6.D2    // acc3 += a3
	VLD2.P  32(R0), [V0.S4, V1.S4]
	VADD    V0.S4, V1.S4, V0.S4    // a1 += a2
	VLD2.P  32(R0), [V2.S4, V3.S4]
	VADD    V2.S4, V3.S4, V2.S4    // a3 += a4
	VUSHLL  $0, V0.S2, V1.D2       // convert low words to 64 bits
	VADD    V1.D2, V5.D2, V5.D2    // acc2 += a2
	VUSHLL2 $0, V0.S4, V0.D2       // convert high words to 64 bits
	VADD    V0.D2, V4.D2, V4.D2    // acc1 += a1
	VUSHLL  $0, V2.S2, V3.D2       // convert low words to 64 bits
	VADD    V3.D2, V7.D2, V7.D2    // acc4 += a4
	VUSHLL2 $0, V2.S4, V2.D2       // convert high words to 64 bits
	VADD    V2.D2, V6.D2, V6.D2    // acc3 += a3
	SUB     $0x4, R2, R2
	JMP     loop9

lastBlock11:
	CBZ     R2, done10
	VLD2.P  32(R0), [V0.S4, V1.S4]
	VADD    V0.S4, V1.S4, V0.S4    // a1 += a2
	VLD2.P  32(R0), [V2.S4, V3.S4]
	VADD    V2.S4, V3.S4, V2.S4    // a3 += a4
	VUSHLL  $0, V0.S2, V1.D2       // convert low words to 64 bits
	VADD    V1.D2, V5.D2, V5.D2    // acc2 += a2
	VUSHLL2 $0, V0.S4, V0.D2       // convert high words to 64 bits
	VADD    V0.D2, V4.D2, V4.D2    // acc1 += a1
	VUSHLL  $0, V2.S2, V3.D2       // convert low words to 64 bits
	VADD    V3.D2, V7.D2, V7.D2    // acc4 += a4
	VUSHLL2 $0, V2.S4, V2.D2       // convert high words to 64 bits
	VADD    V2.D2, V6.D2, V6.D2    // acc3 += a3
	SUB     $1, R2, R2
	JMP     lastBlock11

done10:
	VADD   V4.D2, V6.D2, V4.D2   // acc1 += acc3
	VADD   V5.D2, V7.D2, V5.D2   // acc2 += acc4
	VST2.P [V4.D2, V5.D2], 0(R1) // store acc1 and acc2
	RET
