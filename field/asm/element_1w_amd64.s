// Code generated by gnark-crypto/generator. DO NOT EDIT.
#include "textflag.h"
#include "funcdata.h"
#include "go_asm.h"

// Vector operations are partially derived from Plonky3 https://github.com/Plonky3/Plonky3
// addVec(res, a, b *Element, n uint64) res[0...n] = a[0...n] + b[0...n]
TEXT 路addVec(SB), NOSPLIT, $0-32
	MOVD         $const_q, AX
	VPBROADCASTD AX, Z3
	MOVQ         res+0(FP), CX
	MOVQ         a+8(FP), AX
	MOVQ         b+16(FP), DX
	MOVQ         n+24(FP), BX

loop_1:
	TESTQ     BX, BX
	JEQ       done_2     // n == 0, we are done
	VMOVDQU32 0(AX), Z0
	VMOVDQU32 0(DX), Z1
	VPADDD    Z0, Z1, Z0
	VPSUBD    Z3, Z0, Z2
	VPMINUD   Z0, Z2, Z1
	VMOVDQU32 Z1, 0(CX)

	// increment pointers to visit next element
	ADDQ $64, AX
	ADDQ $64, DX
	ADDQ $64, CX
	DECQ BX      // decrement n
	JMP  loop_1

done_2:
	RET

// subVec(res, a, b *Element, n uint64) res[0...n] = a[0...n] - b[0...n]
TEXT 路subVec(SB), NOSPLIT, $0-32
	MOVD         $const_q, AX
	VPBROADCASTD AX, Z3
	MOVQ         res+0(FP), CX
	MOVQ         a+8(FP), AX
	MOVQ         b+16(FP), DX
	MOVQ         n+24(FP), BX

loop_3:
	TESTQ     BX, BX
	JEQ       done_4     // n == 0, we are done
	VMOVDQU32 0(AX), Z0
	VMOVDQU32 0(DX), Z1
	VPSUBD    Z1, Z0, Z0
	VPADDD    Z3, Z0, Z2
	VPMINUD   Z0, Z2, Z1
	VMOVDQU32 Z1, 0(CX)

	// increment pointers to visit next element
	ADDQ $64, AX
	ADDQ $64, DX
	ADDQ $64, CX
	DECQ BX      // decrement n
	JMP  loop_3

done_4:
	RET

// sumVec(res *uint64, a *[]uint32, n uint64) res = sum(a[0...n])

// We are load 8 31bits values at a time and accumulate them into an accumulator of
// 8 quadwords (64bits). The caller then needs to reduce the result mod q.
// We can safely accumulate ~2**33 31bits values into a single accumulator.
// That gives us a maximum of 2**33 * 8 = 2**36 31bits values to sum safely.

TEXT 路sumVec(SB), NOSPLIT, $0-24
	MOVQ      t+0(FP), R15
	MOVQ      a+8(FP), R14
	MOVQ      n+16(FP), CX
	VXORPS    Z2, Z2, Z2
	VMOVDQA64 Z2, Z3

loop_5:
	TESTQ     CX, CX
	JEQ       done_6      // n == 0, we are done
	VPMOVZXDQ 0(R14), Z0
	VPMOVZXDQ 32(R14), Z1
	VPADDQ    Z0, Z2, Z2
	VPADDQ    Z1, Z3, Z3

	// increment pointers to visit next element
	ADDQ $64, R14
	DECQ CX       // decrement n
	JMP  loop_5

done_6:
	VPADDQ    Z2, Z3, Z2
	VMOVDQU64 Z2, 0(R15)
	RET

// mulVec(res, a, b *Element, n uint64) res[0...n] = a[0...n] * b[0...n]
TEXT 路mulVec(SB), NOSPLIT, $0-32
	MOVD         $const_q, AX
	VPBROADCASTQ AX, Z3
	MOVD         $const_qInvNeg, AX
	VPBROADCASTQ AX, Z4

	// Create mask for low dword in each qword
	VPCMPEQB  Y0, Y0, Y0
	VPMOVZXDQ Y0, Z6
	MOVQ      res+0(FP), CX
	MOVQ      a+8(FP), AX
	MOVQ      b+16(FP), DX
	MOVQ      n+24(FP), BX

loop_7:
	TESTQ     BX, BX
	JEQ       done_8      // n == 0, we are done
	VPMOVZXDQ 0(AX), Z0
	VPMOVZXDQ 0(DX), Z1
	VPMULUDQ  Z0, Z1, Z2
	VPANDQ    Z6, Z2, Z5
	VPMULUDQ  Z5, Z4, Z5
	VPANDQ    Z6, Z5, Z5
	VPMULUDQ  Z5, Z3, Z5
	VPADDQ    Z2, Z5, Z2
	VPSRLQ    $32, Z2, Z2
	VPSUBD    Z3, Z2, Z5
	VPMINUD   Z2, Z5, Z2
	VPMOVQD   Z2, 0(CX)

	// increment pointers to visit next element
	ADDQ $32, AX
	ADDQ $32, DX
	ADDQ $32, CX
	DECQ BX      // decrement n
	JMP  loop_7

done_8:
	RET
